// THE AUTOGENERATED LICENSE. ALL THE RIGHTS ARE RESERVED BY ROBOTS.

// WARNING: This file has automatically been generated on Tue, 25 Nov 2025 19:14:43 CST.
// Code generated by https://git.io/c-for-go. DO NOT EDIT.

package vulkan

/*
#cgo CFLAGS: -I. -DVK_NO_PROTOTYPES
#include "vulkan/vulkan.h"
#include "vulkan/vulkan_beta.h"
#include "vk_wrapper.h"
#include "vk_bridge.h"
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"fmt"
	"runtime"
	"sync"
	"unsafe"
)

// cgoAllocMap stores pointers to C allocated memory for future reference.
type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	a.mux.Lock()
	if a.m == nil {
		a.m = make(map[unsafe.Pointer]struct{})
	}
	a.m[ptr] = struct{}{}
	a.mux.Unlock()
}

func (a *cgoAllocMap) IsEmpty() bool {
	a.mux.RLock()
	isEmpty := len(a.m) == 0
	a.mux.RUnlock()
	return isEmpty
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	if b == nil || b.IsEmpty() {
		return
	}
	b.mux.Lock()
	a.mux.Lock()
	for ptr := range b.m {
		if a.m == nil {
			a.m = make(map[unsafe.Pointer]struct{})
		}
		a.m[ptr] = struct{}{}
		delete(b.m, ptr)
	}
	a.mux.Unlock()
	b.mux.Unlock()
}

func (a *cgoAllocMap) Free() {
	a.mux.Lock()
	for ptr := range a.m {
		C.free(ptr)
		delete(a.m, ptr)
	}
	a.mux.Unlock()
}

// allocBaseInStructureMemory allocates memory for type C.VkBaseInStructure in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBaseInStructureMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBaseInStructureValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBaseInStructureValue = unsafe.Sizeof([1]C.VkBaseInStructure{})

type sliceHeader struct {
	Data unsafe.Pointer
	Len  int
	Cap  int
}

const sizeOfPtr = unsafe.Sizeof(&struct{}{})

// unpackSBaseInStructure transforms a sliced Go data structure into plain C format.
func unpackSBaseInStructure(x []BaseInStructure) (unpacked *C.VkBaseInStructure, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocBaseInStructureMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkBaseInStructure)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkBaseInStructure)(h.Data)
	return
}

// packSBaseInStructure reads sliced Go data structure out from plain C format.
func packSBaseInStructure(v []BaseInStructure, ptr0 *C.VkBaseInStructure) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfBaseInStructureValue]C.VkBaseInStructure)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewBaseInStructureRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BaseInStructure) Ref() *C.VkBaseInStructure {
	if x == nil {
		return nil
	}
	return x.refeae401a9
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BaseInStructure) Free() {
	if x != nil && x.allocseae401a9 != nil {
		x.allocseae401a9.(*cgoAllocMap).Free()
		x.refeae401a9 = nil
	}
}

// NewBaseInStructureRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBaseInStructureRef(ref unsafe.Pointer) *BaseInStructure {
	if ref == nil {
		return nil
	}
	obj := new(BaseInStructure)
	obj.refeae401a9 = (*C.VkBaseInStructure)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BaseInStructure) PassRef() (*C.VkBaseInStructure, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refeae401a9 != nil {
		return x.refeae401a9, nil
	}
	memeae401a9 := allocBaseInStructureMemory(1)
	refeae401a9 := (*C.VkBaseInStructure)(memeae401a9)
	allocseae401a9 := new(cgoAllocMap)
	allocseae401a9.Add(memeae401a9)

	refeae401a9.sType = (C.VkStructureType)(x.SType)

	var cpNext_allocs *cgoAllocMap
	refeae401a9.pNext, cpNext_allocs = unpackSBaseInStructure(x.PNext)
	allocseae401a9.Borrow(cpNext_allocs)

	x.refeae401a9 = refeae401a9
	x.allocseae401a9 = allocseae401a9
	return refeae401a9, allocseae401a9

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BaseInStructure) PassValue() (C.VkBaseInStructure, *cgoAllocMap) {
	if x.refeae401a9 != nil {
		return *x.refeae401a9, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BaseInStructure) Deref() {
	if x.refeae401a9 == nil {
		return
	}
	x.SType = (StructureType)(x.refeae401a9.sType)
	packSBaseInStructure(x.PNext, x.refeae401a9.pNext)
}

// allocBaseOutStructureMemory allocates memory for type C.VkBaseOutStructure in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBaseOutStructureMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBaseOutStructureValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBaseOutStructureValue = unsafe.Sizeof([1]C.VkBaseOutStructure{})

// unpackSBaseOutStructure transforms a sliced Go data structure into plain C format.
func unpackSBaseOutStructure(x []BaseOutStructure) (unpacked *C.VkBaseOutStructure, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocBaseOutStructureMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkBaseOutStructure)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkBaseOutStructure)(h.Data)
	return
}

// packSBaseOutStructure reads sliced Go data structure out from plain C format.
func packSBaseOutStructure(v []BaseOutStructure, ptr0 *C.VkBaseOutStructure) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfBaseOutStructureValue]C.VkBaseOutStructure)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewBaseOutStructureRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BaseOutStructure) Ref() *C.VkBaseOutStructure {
	if x == nil {
		return nil
	}
	return x.refd536fcd0
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BaseOutStructure) Free() {
	if x != nil && x.allocsd536fcd0 != nil {
		x.allocsd536fcd0.(*cgoAllocMap).Free()
		x.refd536fcd0 = nil
	}
}

// NewBaseOutStructureRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBaseOutStructureRef(ref unsafe.Pointer) *BaseOutStructure {
	if ref == nil {
		return nil
	}
	obj := new(BaseOutStructure)
	obj.refd536fcd0 = (*C.VkBaseOutStructure)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BaseOutStructure) PassRef() (*C.VkBaseOutStructure, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd536fcd0 != nil {
		return x.refd536fcd0, nil
	}
	memd536fcd0 := allocBaseOutStructureMemory(1)
	refd536fcd0 := (*C.VkBaseOutStructure)(memd536fcd0)
	allocsd536fcd0 := new(cgoAllocMap)
	allocsd536fcd0.Add(memd536fcd0)

	refd536fcd0.sType = (C.VkStructureType)(x.SType)

	var cpNext_allocs *cgoAllocMap
	refd536fcd0.pNext, cpNext_allocs = unpackSBaseOutStructure(x.PNext)
	allocsd536fcd0.Borrow(cpNext_allocs)

	x.refd536fcd0 = refd536fcd0
	x.allocsd536fcd0 = allocsd536fcd0
	return refd536fcd0, allocsd536fcd0

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BaseOutStructure) PassValue() (C.VkBaseOutStructure, *cgoAllocMap) {
	if x.refd536fcd0 != nil {
		return *x.refd536fcd0, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BaseOutStructure) Deref() {
	if x.refd536fcd0 == nil {
		return
	}
	x.SType = (StructureType)(x.refd536fcd0.sType)
	packSBaseOutStructure(x.PNext, x.refd536fcd0.pNext)
}

// allocBufferMemoryBarrierMemory allocates memory for type C.VkBufferMemoryBarrier in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBufferMemoryBarrierMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBufferMemoryBarrierValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBufferMemoryBarrierValue = unsafe.Sizeof([1]C.VkBufferMemoryBarrier{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BufferMemoryBarrier) Ref() *C.VkBufferMemoryBarrier {
	if x == nil {
		return nil
	}
	return x.refeaf4700b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BufferMemoryBarrier) Free() {
	if x != nil && x.allocseaf4700b != nil {
		x.allocseaf4700b.(*cgoAllocMap).Free()
		x.refeaf4700b = nil
	}
}

// NewBufferMemoryBarrierRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBufferMemoryBarrierRef(ref unsafe.Pointer) *BufferMemoryBarrier {
	if ref == nil {
		return nil
	}
	obj := new(BufferMemoryBarrier)
	obj.refeaf4700b = (*C.VkBufferMemoryBarrier)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BufferMemoryBarrier) PassRef() (*C.VkBufferMemoryBarrier, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refeaf4700b != nil {
		return x.refeaf4700b, nil
	}
	memeaf4700b := allocBufferMemoryBarrierMemory(1)
	refeaf4700b := (*C.VkBufferMemoryBarrier)(memeaf4700b)
	allocseaf4700b := new(cgoAllocMap)
	allocseaf4700b.Add(memeaf4700b)

	refeaf4700b.sType = (C.VkStructureType)(x.SType)

	refeaf4700b.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	refeaf4700b.srcAccessMask = (C.VkAccessFlags)(x.SrcAccessMask)

	refeaf4700b.dstAccessMask = (C.VkAccessFlags)(x.DstAccessMask)

	refeaf4700b.srcQueueFamilyIndex = (C.uint32_t)(x.SrcQueueFamilyIndex)

	refeaf4700b.dstQueueFamilyIndex = (C.uint32_t)(x.DstQueueFamilyIndex)

	refeaf4700b.buffer = *(*C.VkBuffer)(unsafe.Pointer(&x.Buffer))

	refeaf4700b.offset = (C.VkDeviceSize)(x.Offset)

	refeaf4700b.size = (C.VkDeviceSize)(x.Size)

	x.refeaf4700b = refeaf4700b
	x.allocseaf4700b = allocseaf4700b
	return refeaf4700b, allocseaf4700b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BufferMemoryBarrier) PassValue() (C.VkBufferMemoryBarrier, *cgoAllocMap) {
	if x.refeaf4700b != nil {
		return *x.refeaf4700b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BufferMemoryBarrier) Deref() {
	if x.refeaf4700b == nil {
		return
	}
	x.SType = (StructureType)(x.refeaf4700b.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refeaf4700b.pNext))
	x.SrcAccessMask = (AccessFlags)(x.refeaf4700b.srcAccessMask)
	x.DstAccessMask = (AccessFlags)(x.refeaf4700b.dstAccessMask)
	x.SrcQueueFamilyIndex = (uint32)(x.refeaf4700b.srcQueueFamilyIndex)
	x.DstQueueFamilyIndex = (uint32)(x.refeaf4700b.dstQueueFamilyIndex)
	x.Buffer = *(*Buffer)(unsafe.Pointer(&x.refeaf4700b.buffer))
	x.Offset = (DeviceSize)(x.refeaf4700b.offset)
	x.Size = (DeviceSize)(x.refeaf4700b.size)
}

// allocImageMemoryBarrierMemory allocates memory for type C.VkImageMemoryBarrier in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageMemoryBarrierMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageMemoryBarrierValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfImageMemoryBarrierValue = unsafe.Sizeof([1]C.VkImageMemoryBarrier{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImageMemoryBarrier) Ref() *C.VkImageMemoryBarrier {
	if x == nil {
		return nil
	}
	return x.refd52734ec
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImageMemoryBarrier) Free() {
	if x != nil && x.allocsd52734ec != nil {
		x.allocsd52734ec.(*cgoAllocMap).Free()
		x.refd52734ec = nil
	}
}

// NewImageMemoryBarrierRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageMemoryBarrierRef(ref unsafe.Pointer) *ImageMemoryBarrier {
	if ref == nil {
		return nil
	}
	obj := new(ImageMemoryBarrier)
	obj.refd52734ec = (*C.VkImageMemoryBarrier)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImageMemoryBarrier) PassRef() (*C.VkImageMemoryBarrier, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd52734ec != nil {
		return x.refd52734ec, nil
	}
	memd52734ec := allocImageMemoryBarrierMemory(1)
	refd52734ec := (*C.VkImageMemoryBarrier)(memd52734ec)
	allocsd52734ec := new(cgoAllocMap)
	allocsd52734ec.Add(memd52734ec)

	refd52734ec.sType = (C.VkStructureType)(x.SType)

	refd52734ec.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	refd52734ec.srcAccessMask = (C.VkAccessFlags)(x.SrcAccessMask)

	refd52734ec.dstAccessMask = (C.VkAccessFlags)(x.DstAccessMask)

	refd52734ec.oldLayout = (C.VkImageLayout)(x.OldLayout)

	refd52734ec.newLayout = (C.VkImageLayout)(x.NewLayout)

	refd52734ec.srcQueueFamilyIndex = (C.uint32_t)(x.SrcQueueFamilyIndex)

	refd52734ec.dstQueueFamilyIndex = (C.uint32_t)(x.DstQueueFamilyIndex)

	refd52734ec.image = *(*C.VkImage)(unsafe.Pointer(&x.Image))

	refd52734ec.subresourceRange = *(*C.VkImageSubresourceRange)(unsafe.Pointer(&x.SubresourceRange))

	x.refd52734ec = refd52734ec
	x.allocsd52734ec = allocsd52734ec
	return refd52734ec, allocsd52734ec

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImageMemoryBarrier) PassValue() (C.VkImageMemoryBarrier, *cgoAllocMap) {
	if x.refd52734ec != nil {
		return *x.refd52734ec, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImageMemoryBarrier) Deref() {
	if x.refd52734ec == nil {
		return
	}
	x.SType = (StructureType)(x.refd52734ec.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refd52734ec.pNext))
	x.SrcAccessMask = (AccessFlags)(x.refd52734ec.srcAccessMask)
	x.DstAccessMask = (AccessFlags)(x.refd52734ec.dstAccessMask)
	x.OldLayout = (ImageLayout)(x.refd52734ec.oldLayout)
	x.NewLayout = (ImageLayout)(x.refd52734ec.newLayout)
	x.SrcQueueFamilyIndex = (uint32)(x.refd52734ec.srcQueueFamilyIndex)
	x.DstQueueFamilyIndex = (uint32)(x.refd52734ec.dstQueueFamilyIndex)
	x.Image = *(*Image)(unsafe.Pointer(&x.refd52734ec.image))
	x.SubresourceRange = *(*ImageSubresourceRange)(unsafe.Pointer(&x.refd52734ec.subresourceRange))
}

// allocPipelineCacheHeaderVersionOneMemory allocates memory for type C.VkPipelineCacheHeaderVersionOne in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineCacheHeaderVersionOneMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineCacheHeaderVersionOneValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPipelineCacheHeaderVersionOneValue = unsafe.Sizeof([1]C.VkPipelineCacheHeaderVersionOne{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineCacheHeaderVersionOne) Ref() *C.VkPipelineCacheHeaderVersionOne {
	if x == nil {
		return nil
	}
	return x.refa2162ec9
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineCacheHeaderVersionOne) Free() {
	if x != nil && x.allocsa2162ec9 != nil {
		x.allocsa2162ec9.(*cgoAllocMap).Free()
		x.refa2162ec9 = nil
	}
}

// NewPipelineCacheHeaderVersionOneRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineCacheHeaderVersionOneRef(ref unsafe.Pointer) *PipelineCacheHeaderVersionOne {
	if ref == nil {
		return nil
	}
	obj := new(PipelineCacheHeaderVersionOne)
	obj.refa2162ec9 = (*C.VkPipelineCacheHeaderVersionOne)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineCacheHeaderVersionOne) PassRef() (*C.VkPipelineCacheHeaderVersionOne, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa2162ec9 != nil {
		return x.refa2162ec9, nil
	}
	mema2162ec9 := allocPipelineCacheHeaderVersionOneMemory(1)
	refa2162ec9 := (*C.VkPipelineCacheHeaderVersionOne)(mema2162ec9)
	allocsa2162ec9 := new(cgoAllocMap)
	allocsa2162ec9.Add(mema2162ec9)

	refa2162ec9.headerSize = (C.uint32_t)(x.HeaderSize)

	refa2162ec9.headerVersion = (C.VkPipelineCacheHeaderVersion)(x.HeaderVersion)

	refa2162ec9.vendorID = (C.uint32_t)(x.VendorID)

	refa2162ec9.deviceID = (C.uint32_t)(x.DeviceID)

	refa2162ec9.pipelineCacheUUID = *(*[16]C.uint8_t)(unsafe.Pointer(&x.PipelineCacheUUID))

	x.refa2162ec9 = refa2162ec9
	x.allocsa2162ec9 = allocsa2162ec9
	return refa2162ec9, allocsa2162ec9

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineCacheHeaderVersionOne) PassValue() (C.VkPipelineCacheHeaderVersionOne, *cgoAllocMap) {
	if x.refa2162ec9 != nil {
		return *x.refa2162ec9, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineCacheHeaderVersionOne) Deref() {
	if x.refa2162ec9 == nil {
		return
	}
	x.HeaderSize = (uint32)(x.refa2162ec9.headerSize)
	x.HeaderVersion = (PipelineCacheHeaderVersion)(x.refa2162ec9.headerVersion)
	x.VendorID = (uint32)(x.refa2162ec9.vendorID)
	x.DeviceID = (uint32)(x.refa2162ec9.deviceID)
	x.PipelineCacheUUID = *(*[16]byte)(unsafe.Pointer(&x.refa2162ec9.pipelineCacheUUID))
}

// Ref returns a reference to C object as it is.
func (x *AllocationCallbacks) Ref() *C.VkAllocationCallbacks {
	if x == nil {
		return nil
	}
	return (*C.VkAllocationCallbacks)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *AllocationCallbacks) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewAllocationCallbacksRef converts the C object reference into a raw struct reference without wrapping.
func NewAllocationCallbacksRef(ref unsafe.Pointer) *AllocationCallbacks {
	return (*AllocationCallbacks)(ref)
}

// NewAllocationCallbacks allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewAllocationCallbacks() *AllocationCallbacks {
	return (*AllocationCallbacks)(allocAllocationCallbacksMemory(1))
}

// allocAllocationCallbacksMemory allocates memory for type C.VkAllocationCallbacks in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAllocationCallbacksMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAllocationCallbacksValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfAllocationCallbacksValue = unsafe.Sizeof([1]C.VkAllocationCallbacks{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *AllocationCallbacks) PassRef() *C.VkAllocationCallbacks {
	if x == nil {
		x = (*AllocationCallbacks)(allocAllocationCallbacksMemory(1))
	}
	return (*C.VkAllocationCallbacks)(unsafe.Pointer(x))
}

// allocApplicationInfoMemory allocates memory for type C.VkApplicationInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocApplicationInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfApplicationInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfApplicationInfoValue = unsafe.Sizeof([1]C.VkApplicationInfo{})

// copyPCharBytes copies the data from Go slice as *C.char.
func copyPCharBytes(slice *sliceHeader) (*C.char, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfCharValue) * slice.Len,
		Cap:  int(sizeOfCharValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.char)(mem0), allocs
}

// allocCharMemory allocates memory for type C.char in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCharMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCharValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCharValue = unsafe.Sizeof([1]C.char{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ApplicationInfo) Ref() *C.VkApplicationInfo {
	if x == nil {
		return nil
	}
	return x.refb0af7378
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ApplicationInfo) Free() {
	if x != nil && x.allocsb0af7378 != nil {
		x.allocsb0af7378.(*cgoAllocMap).Free()
		x.refb0af7378 = nil
	}
}

// NewApplicationInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewApplicationInfoRef(ref unsafe.Pointer) *ApplicationInfo {
	if ref == nil {
		return nil
	}
	obj := new(ApplicationInfo)
	obj.refb0af7378 = (*C.VkApplicationInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ApplicationInfo) PassRef() (*C.VkApplicationInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb0af7378 != nil {
		return x.refb0af7378, nil
	}
	memb0af7378 := allocApplicationInfoMemory(1)
	refb0af7378 := (*C.VkApplicationInfo)(memb0af7378)
	allocsb0af7378 := new(cgoAllocMap)
	allocsb0af7378.Add(memb0af7378)

	refb0af7378.sType = (C.VkStructureType)(x.SType)

	refb0af7378.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	var cpApplicationName_allocs *cgoAllocMap
	refb0af7378.pApplicationName, cpApplicationName_allocs = copyPCharBytes((*sliceHeader)(unsafe.Pointer(&x.PApplicationName)))
	allocsb0af7378.Borrow(cpApplicationName_allocs)

	refb0af7378.applicationVersion = (C.uint32_t)(x.ApplicationVersion)

	var cpEngineName_allocs *cgoAllocMap
	refb0af7378.pEngineName, cpEngineName_allocs = copyPCharBytes((*sliceHeader)(unsafe.Pointer(&x.PEngineName)))
	allocsb0af7378.Borrow(cpEngineName_allocs)

	refb0af7378.engineVersion = (C.uint32_t)(x.EngineVersion)

	refb0af7378.apiVersion = (C.uint32_t)(x.ApiVersion)

	x.refb0af7378 = refb0af7378
	x.allocsb0af7378 = allocsb0af7378
	return refb0af7378, allocsb0af7378

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ApplicationInfo) PassValue() (C.VkApplicationInfo, *cgoAllocMap) {
	if x.refb0af7378 != nil {
		return *x.refb0af7378, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ApplicationInfo) Deref() {
	if x.refb0af7378 == nil {
		return
	}
	x.SType = (StructureType)(x.refb0af7378.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refb0af7378.pNext))
	hxfc4425b := (*sliceHeader)(unsafe.Pointer(&x.PApplicationName))
	hxfc4425b.Data = unsafe.Pointer(x.refb0af7378.pApplicationName)
	hxfc4425b.Cap = 0x7fffffff
	// hxfc4425b.Len = ? x.PApplicationName x.refb0af7378.pApplicationName

	x.ApplicationVersion = (uint32)(x.refb0af7378.applicationVersion)
	hxf95e7c8 := (*sliceHeader)(unsafe.Pointer(&x.PEngineName))
	hxf95e7c8.Data = unsafe.Pointer(x.refb0af7378.pEngineName)
	hxf95e7c8.Cap = 0x7fffffff
	// hxf95e7c8.Len = ? x.PEngineName x.refb0af7378.pEngineName

	x.EngineVersion = (uint32)(x.refb0af7378.engineVersion)
	x.ApiVersion = (uint32)(x.refb0af7378.apiVersion)
}

// allocInstanceCreateInfoMemory allocates memory for type C.VkInstanceCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocInstanceCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfInstanceCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfInstanceCreateInfoValue = unsafe.Sizeof([1]C.VkInstanceCreateInfo{})

// allocPCharMemory allocates memory for type *C.char in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPCharMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPCharValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPCharValue = unsafe.Sizeof([1]*C.char{})

// unpackSString transforms a sliced Go data structure into plain C format.
func unpackSString(x []string) (unpacked **C.char, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPCharMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.char)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = unpackPCharString(x[i0])
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.char)(h.Data)
	return
}

// unpackPCharString copies the data from Go string as *C.char.
func unpackPCharString(str string) (*C.char, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CString(str))
	allocs.Add(mem0)
	return (*C.char)(mem0), allocs
}

type stringHeader struct {
	Data unsafe.Pointer
	Len  int
}

// packSString reads sliced Go data structure out from plain C format.
func packSString(v []string, ptr0 **C.char) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.char)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = packPCharString(ptr1)
	}
}

// packPCharString creates a Go string backed by *C.char and avoids copying.
func packPCharString(p *C.char) (raw string) {
	if p != nil && *p != 0 {
		h := (*stringHeader)(unsafe.Pointer(&raw))
		h.Data = unsafe.Pointer(p)
		for *p != 0 {
			p = (*C.char)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1)) // p++
		}
		h.Len = int(uintptr(unsafe.Pointer(p)) - uintptr(h.Data))
	}
	return
}

// RawString reperesents a string backed by data on the C side.
type RawString string

// Copy returns a Go-managed copy of raw string.
func (raw RawString) Copy() string {
	if len(raw) == 0 {
		return ""
	}
	h := (*stringHeader)(unsafe.Pointer(&raw))
	return C.GoStringN((*C.char)(h.Data), C.int(h.Len))
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *InstanceCreateInfo) Ref() *C.VkInstanceCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref9b760798
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *InstanceCreateInfo) Free() {
	if x != nil && x.allocs9b760798 != nil {
		x.allocs9b760798.(*cgoAllocMap).Free()
		x.ref9b760798 = nil
	}
}

// NewInstanceCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewInstanceCreateInfoRef(ref unsafe.Pointer) *InstanceCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(InstanceCreateInfo)
	obj.ref9b760798 = (*C.VkInstanceCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *InstanceCreateInfo) PassRef() (*C.VkInstanceCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9b760798 != nil {
		return x.ref9b760798, nil
	}
	mem9b760798 := allocInstanceCreateInfoMemory(1)
	ref9b760798 := (*C.VkInstanceCreateInfo)(mem9b760798)
	allocs9b760798 := new(cgoAllocMap)
	allocs9b760798.Add(mem9b760798)

	ref9b760798.sType = (C.VkStructureType)(x.SType)

	ref9b760798.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref9b760798.flags = (C.VkInstanceCreateFlags)(x.Flags)

	var cpApplicationInfo_allocs *cgoAllocMap
	ref9b760798.pApplicationInfo, cpApplicationInfo_allocs = x.PApplicationInfo.PassRef()
	allocs9b760798.Borrow(cpApplicationInfo_allocs)

	ref9b760798.enabledLayerCount = (C.uint32_t)(x.EnabledLayerCount)

	var cppEnabledLayerNames_allocs *cgoAllocMap
	ref9b760798.ppEnabledLayerNames, cppEnabledLayerNames_allocs = unpackSString(x.PpEnabledLayerNames)
	allocs9b760798.Borrow(cppEnabledLayerNames_allocs)

	ref9b760798.enabledExtensionCount = (C.uint32_t)(x.EnabledExtensionCount)

	var cppEnabledExtensionNames_allocs *cgoAllocMap
	ref9b760798.ppEnabledExtensionNames, cppEnabledExtensionNames_allocs = unpackSString(x.PpEnabledExtensionNames)
	allocs9b760798.Borrow(cppEnabledExtensionNames_allocs)

	x.ref9b760798 = ref9b760798
	x.allocs9b760798 = allocs9b760798
	return ref9b760798, allocs9b760798

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x InstanceCreateInfo) PassValue() (C.VkInstanceCreateInfo, *cgoAllocMap) {
	if x.ref9b760798 != nil {
		return *x.ref9b760798, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *InstanceCreateInfo) Deref() {
	if x.ref9b760798 == nil {
		return
	}
	x.SType = (StructureType)(x.ref9b760798.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref9b760798.pNext))
	x.Flags = (InstanceCreateFlags)(x.ref9b760798.flags)
	x.PApplicationInfo = NewApplicationInfoRef(unsafe.Pointer(x.ref9b760798.pApplicationInfo))
	x.EnabledLayerCount = (uint32)(x.ref9b760798.enabledLayerCount)
	packSString(x.PpEnabledLayerNames, x.ref9b760798.ppEnabledLayerNames)
	x.EnabledExtensionCount = (uint32)(x.ref9b760798.enabledExtensionCount)
	packSString(x.PpEnabledExtensionNames, x.ref9b760798.ppEnabledExtensionNames)
}

// allocPhysicalDevicePropertiesMemory allocates memory for type C.VkPhysicalDeviceProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDevicePropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDevicePropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDevicePropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceProperties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceProperties) Ref() *C.VkPhysicalDeviceProperties {
	if x == nil {
		return nil
	}
	return x.ref1080ca9d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceProperties) Free() {
	if x != nil && x.allocs1080ca9d != nil {
		x.allocs1080ca9d.(*cgoAllocMap).Free()
		x.ref1080ca9d = nil
	}
}

// NewPhysicalDevicePropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDevicePropertiesRef(ref unsafe.Pointer) *PhysicalDeviceProperties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceProperties)
	obj.ref1080ca9d = (*C.VkPhysicalDeviceProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceProperties) PassRef() (*C.VkPhysicalDeviceProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1080ca9d != nil {
		return x.ref1080ca9d, nil
	}
	mem1080ca9d := allocPhysicalDevicePropertiesMemory(1)
	ref1080ca9d := (*C.VkPhysicalDeviceProperties)(mem1080ca9d)
	allocs1080ca9d := new(cgoAllocMap)
	allocs1080ca9d.Add(mem1080ca9d)

	ref1080ca9d.apiVersion = (C.uint32_t)(x.ApiVersion)

	ref1080ca9d.driverVersion = (C.uint32_t)(x.DriverVersion)

	ref1080ca9d.vendorID = (C.uint32_t)(x.VendorID)

	ref1080ca9d.deviceID = (C.uint32_t)(x.DeviceID)

	ref1080ca9d.deviceType = (C.VkPhysicalDeviceType)(x.DeviceType)

	ref1080ca9d.deviceName = *(*[256]C.char)(unsafe.Pointer(&x.DeviceName))

	ref1080ca9d.pipelineCacheUUID = *(*[16]C.uint8_t)(unsafe.Pointer(&x.PipelineCacheUUID))

	ref1080ca9d.limits = *(*C.VkPhysicalDeviceLimits)(unsafe.Pointer(&x.Limits))

	ref1080ca9d.sparseProperties = *(*C.VkPhysicalDeviceSparseProperties)(unsafe.Pointer(&x.SparseProperties))

	x.ref1080ca9d = ref1080ca9d
	x.allocs1080ca9d = allocs1080ca9d
	return ref1080ca9d, allocs1080ca9d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceProperties) PassValue() (C.VkPhysicalDeviceProperties, *cgoAllocMap) {
	if x.ref1080ca9d != nil {
		return *x.ref1080ca9d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceProperties) Deref() {
	if x.ref1080ca9d == nil {
		return
	}
	x.ApiVersion = (uint32)(x.ref1080ca9d.apiVersion)
	x.DriverVersion = (uint32)(x.ref1080ca9d.driverVersion)
	x.VendorID = (uint32)(x.ref1080ca9d.vendorID)
	x.DeviceID = (uint32)(x.ref1080ca9d.deviceID)
	x.DeviceType = (PhysicalDeviceType)(x.ref1080ca9d.deviceType)
	x.DeviceName = *(*[256]byte)(unsafe.Pointer(&x.ref1080ca9d.deviceName))
	x.PipelineCacheUUID = *(*[16]byte)(unsafe.Pointer(&x.ref1080ca9d.pipelineCacheUUID))
	x.Limits = *(*PhysicalDeviceLimits)(unsafe.Pointer(&x.ref1080ca9d.limits))
	x.SparseProperties = *(*PhysicalDeviceSparseProperties)(unsafe.Pointer(&x.ref1080ca9d.sparseProperties))
}

// allocDeviceQueueCreateInfoMemory allocates memory for type C.VkDeviceQueueCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceQueueCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceQueueCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDeviceQueueCreateInfoValue = unsafe.Sizeof([1]C.VkDeviceQueueCreateInfo{})

// copyPFloatBytes copies the data from Go slice as *C.float.
func copyPFloatBytes(slice *sliceHeader) (*C.float, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfFloatValue) * slice.Len,
		Cap:  int(sizeOfFloatValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.float)(mem0), allocs
}

// allocFloatMemory allocates memory for type C.float in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFloatMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFloatValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFloatValue = unsafe.Sizeof([1]C.float{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DeviceQueueCreateInfo) Ref() *C.VkDeviceQueueCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref6087b30d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DeviceQueueCreateInfo) Free() {
	if x != nil && x.allocs6087b30d != nil {
		x.allocs6087b30d.(*cgoAllocMap).Free()
		x.ref6087b30d = nil
	}
}

// NewDeviceQueueCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDeviceQueueCreateInfoRef(ref unsafe.Pointer) *DeviceQueueCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(DeviceQueueCreateInfo)
	obj.ref6087b30d = (*C.VkDeviceQueueCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DeviceQueueCreateInfo) PassRef() (*C.VkDeviceQueueCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6087b30d != nil {
		return x.ref6087b30d, nil
	}
	mem6087b30d := allocDeviceQueueCreateInfoMemory(1)
	ref6087b30d := (*C.VkDeviceQueueCreateInfo)(mem6087b30d)
	allocs6087b30d := new(cgoAllocMap)
	allocs6087b30d.Add(mem6087b30d)

	ref6087b30d.sType = (C.VkStructureType)(x.SType)

	ref6087b30d.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref6087b30d.flags = (C.VkDeviceQueueCreateFlags)(x.Flags)

	ref6087b30d.queueFamilyIndex = (C.uint32_t)(x.QueueFamilyIndex)

	ref6087b30d.queueCount = (C.uint32_t)(x.QueueCount)

	if x.PQueuePriorities != nil {
		var cpQueuePriorities_allocs *cgoAllocMap
		ref6087b30d.pQueuePriorities, cpQueuePriorities_allocs = copyPFloatBytes((*sliceHeader)(unsafe.Pointer(&x.PQueuePriorities)))
		allocs6087b30d.Borrow(cpQueuePriorities_allocs)
	}

	x.ref6087b30d = ref6087b30d
	x.allocs6087b30d = allocs6087b30d
	return ref6087b30d, allocs6087b30d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DeviceQueueCreateInfo) PassValue() (C.VkDeviceQueueCreateInfo, *cgoAllocMap) {
	if x.ref6087b30d != nil {
		return *x.ref6087b30d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DeviceQueueCreateInfo) Deref() {
	if x.ref6087b30d == nil {
		return
	}
	x.SType = (StructureType)(x.ref6087b30d.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref6087b30d.pNext))
	x.Flags = (DeviceQueueCreateFlags)(x.ref6087b30d.flags)
	x.QueueFamilyIndex = (uint32)(x.ref6087b30d.queueFamilyIndex)
	x.QueueCount = (uint32)(x.ref6087b30d.queueCount)
	hxff2234b := (*sliceHeader)(unsafe.Pointer(&x.PQueuePriorities))
	hxff2234b.Data = unsafe.Pointer(x.ref6087b30d.pQueuePriorities)
	hxff2234b.Cap = 0x7fffffff
	// hxff2234b.Len = ? x.PQueuePriorities x.ref6087b30d.pQueuePriorities

}

// allocDeviceCreateInfoMemory allocates memory for type C.VkDeviceCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDeviceCreateInfoValue = unsafe.Sizeof([1]C.VkDeviceCreateInfo{})

// unpackSDeviceQueueCreateInfo transforms a sliced Go data structure into plain C format.
func unpackSDeviceQueueCreateInfo(x []DeviceQueueCreateInfo) (unpacked *C.VkDeviceQueueCreateInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocDeviceQueueCreateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkDeviceQueueCreateInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkDeviceQueueCreateInfo)(h.Data)
	return
}

// copyPPhysicalDeviceFeaturesBytes copies the data from Go slice as *C.VkPhysicalDeviceFeatures.
func copyPPhysicalDeviceFeaturesBytes(slice *sliceHeader) (*C.VkPhysicalDeviceFeatures, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfPhysicalDeviceFeaturesValue) * slice.Len,
		Cap:  int(sizeOfPhysicalDeviceFeaturesValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkPhysicalDeviceFeatures)(mem0), allocs
}

// allocPhysicalDeviceFeaturesMemory allocates memory for type C.VkPhysicalDeviceFeatures in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceFeaturesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceFeaturesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceFeatures{})

// packSDeviceQueueCreateInfo reads sliced Go data structure out from plain C format.
func packSDeviceQueueCreateInfo(v []DeviceQueueCreateInfo, ptr0 *C.VkDeviceQueueCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDeviceQueueCreateInfoValue]C.VkDeviceQueueCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDeviceQueueCreateInfoRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DeviceCreateInfo) Ref() *C.VkDeviceCreateInfo {
	if x == nil {
		return nil
	}
	return x.refc0d8b997
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DeviceCreateInfo) Free() {
	if x != nil && x.allocsc0d8b997 != nil {
		x.allocsc0d8b997.(*cgoAllocMap).Free()
		x.refc0d8b997 = nil
	}
}

// NewDeviceCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDeviceCreateInfoRef(ref unsafe.Pointer) *DeviceCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(DeviceCreateInfo)
	obj.refc0d8b997 = (*C.VkDeviceCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DeviceCreateInfo) PassRef() (*C.VkDeviceCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc0d8b997 != nil {
		return x.refc0d8b997, nil
	}
	memc0d8b997 := allocDeviceCreateInfoMemory(1)
	refc0d8b997 := (*C.VkDeviceCreateInfo)(memc0d8b997)
	allocsc0d8b997 := new(cgoAllocMap)
	allocsc0d8b997.Add(memc0d8b997)

	refc0d8b997.sType = (C.VkStructureType)(x.SType)

	refc0d8b997.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	refc0d8b997.flags = (C.VkDeviceCreateFlags)(x.Flags)

	refc0d8b997.queueCreateInfoCount = (C.uint32_t)(x.QueueCreateInfoCount)

	var cpQueueCreateInfos_allocs *cgoAllocMap
	refc0d8b997.pQueueCreateInfos, cpQueueCreateInfos_allocs = unpackSDeviceQueueCreateInfo(x.PQueueCreateInfos)
	allocsc0d8b997.Borrow(cpQueueCreateInfos_allocs)

	refc0d8b997.enabledLayerCount = (C.uint32_t)(x.EnabledLayerCount)

	var cppEnabledLayerNames_allocs *cgoAllocMap
	refc0d8b997.ppEnabledLayerNames, cppEnabledLayerNames_allocs = unpackSString(x.PpEnabledLayerNames)
	allocsc0d8b997.Borrow(cppEnabledLayerNames_allocs)

	refc0d8b997.enabledExtensionCount = (C.uint32_t)(x.EnabledExtensionCount)

	var cppEnabledExtensionNames_allocs *cgoAllocMap
	refc0d8b997.ppEnabledExtensionNames, cppEnabledExtensionNames_allocs = unpackSString(x.PpEnabledExtensionNames)
	allocsc0d8b997.Borrow(cppEnabledExtensionNames_allocs)

	if x.PEnabledFeatures != nil {
		var cpEnabledFeatures_allocs *cgoAllocMap
		refc0d8b997.pEnabledFeatures, cpEnabledFeatures_allocs = copyPPhysicalDeviceFeaturesBytes((*sliceHeader)(unsafe.Pointer(&x.PEnabledFeatures)))
		allocsc0d8b997.Borrow(cpEnabledFeatures_allocs)
	}

	x.refc0d8b997 = refc0d8b997
	x.allocsc0d8b997 = allocsc0d8b997
	return refc0d8b997, allocsc0d8b997

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DeviceCreateInfo) PassValue() (C.VkDeviceCreateInfo, *cgoAllocMap) {
	if x.refc0d8b997 != nil {
		return *x.refc0d8b997, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DeviceCreateInfo) Deref() {
	if x.refc0d8b997 == nil {
		return
	}
	x.SType = (StructureType)(x.refc0d8b997.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refc0d8b997.pNext))
	x.Flags = (DeviceCreateFlags)(x.refc0d8b997.flags)
	x.QueueCreateInfoCount = (uint32)(x.refc0d8b997.queueCreateInfoCount)
	packSDeviceQueueCreateInfo(x.PQueueCreateInfos, x.refc0d8b997.pQueueCreateInfos)
	x.EnabledLayerCount = (uint32)(x.refc0d8b997.enabledLayerCount)
	packSString(x.PpEnabledLayerNames, x.refc0d8b997.ppEnabledLayerNames)
	x.EnabledExtensionCount = (uint32)(x.refc0d8b997.enabledExtensionCount)
	packSString(x.PpEnabledExtensionNames, x.refc0d8b997.ppEnabledExtensionNames)
	hxff73280 := (*sliceHeader)(unsafe.Pointer(&x.PEnabledFeatures))
	hxff73280.Data = unsafe.Pointer(x.refc0d8b997.pEnabledFeatures)
	hxff73280.Cap = 0x7fffffff
	// hxff73280.Len = ? x.PEnabledFeatures x.refc0d8b997.pEnabledFeatures

}

// allocExtensionPropertiesMemory allocates memory for type C.VkExtensionProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocExtensionPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfExtensionPropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfExtensionPropertiesValue = unsafe.Sizeof([1]C.VkExtensionProperties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ExtensionProperties) Ref() *C.VkExtensionProperties {
	if x == nil {
		return nil
	}
	return x.ref2f001956
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ExtensionProperties) Free() {
	if x != nil && x.allocs2f001956 != nil {
		x.allocs2f001956.(*cgoAllocMap).Free()
		x.ref2f001956 = nil
	}
}

// NewExtensionPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewExtensionPropertiesRef(ref unsafe.Pointer) *ExtensionProperties {
	if ref == nil {
		return nil
	}
	obj := new(ExtensionProperties)
	obj.ref2f001956 = (*C.VkExtensionProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ExtensionProperties) PassRef() (*C.VkExtensionProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2f001956 != nil {
		return x.ref2f001956, nil
	}
	mem2f001956 := allocExtensionPropertiesMemory(1)
	ref2f001956 := (*C.VkExtensionProperties)(mem2f001956)
	allocs2f001956 := new(cgoAllocMap)
	allocs2f001956.Add(mem2f001956)

	ref2f001956.extensionName = *(*[256]C.char)(unsafe.Pointer(&x.ExtensionName))

	ref2f001956.specVersion = (C.uint32_t)(x.SpecVersion)

	x.ref2f001956 = ref2f001956
	x.allocs2f001956 = allocs2f001956
	return ref2f001956, allocs2f001956

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ExtensionProperties) PassValue() (C.VkExtensionProperties, *cgoAllocMap) {
	if x.ref2f001956 != nil {
		return *x.ref2f001956, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ExtensionProperties) Deref() {
	if x.ref2f001956 == nil {
		return
	}
	x.ExtensionName = *(*[256]byte)(unsafe.Pointer(&x.ref2f001956.extensionName))
	x.SpecVersion = (uint32)(x.ref2f001956.specVersion)
}

// allocLayerPropertiesMemory allocates memory for type C.VkLayerProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocLayerPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfLayerPropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfLayerPropertiesValue = unsafe.Sizeof([1]C.VkLayerProperties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *LayerProperties) Ref() *C.VkLayerProperties {
	if x == nil {
		return nil
	}
	return x.refd9407ce7
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *LayerProperties) Free() {
	if x != nil && x.allocsd9407ce7 != nil {
		x.allocsd9407ce7.(*cgoAllocMap).Free()
		x.refd9407ce7 = nil
	}
}

// NewLayerPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewLayerPropertiesRef(ref unsafe.Pointer) *LayerProperties {
	if ref == nil {
		return nil
	}
	obj := new(LayerProperties)
	obj.refd9407ce7 = (*C.VkLayerProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *LayerProperties) PassRef() (*C.VkLayerProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd9407ce7 != nil {
		return x.refd9407ce7, nil
	}
	memd9407ce7 := allocLayerPropertiesMemory(1)
	refd9407ce7 := (*C.VkLayerProperties)(memd9407ce7)
	allocsd9407ce7 := new(cgoAllocMap)
	allocsd9407ce7.Add(memd9407ce7)

	refd9407ce7.layerName = *(*[256]C.char)(unsafe.Pointer(&x.LayerName))

	refd9407ce7.specVersion = (C.uint32_t)(x.SpecVersion)

	refd9407ce7.implementationVersion = (C.uint32_t)(x.ImplementationVersion)

	refd9407ce7.description = *(*[256]C.char)(unsafe.Pointer(&x.Description))

	x.refd9407ce7 = refd9407ce7
	x.allocsd9407ce7 = allocsd9407ce7
	return refd9407ce7, allocsd9407ce7

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x LayerProperties) PassValue() (C.VkLayerProperties, *cgoAllocMap) {
	if x.refd9407ce7 != nil {
		return *x.refd9407ce7, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *LayerProperties) Deref() {
	if x.refd9407ce7 == nil {
		return
	}
	x.LayerName = *(*[256]byte)(unsafe.Pointer(&x.refd9407ce7.layerName))
	x.SpecVersion = (uint32)(x.refd9407ce7.specVersion)
	x.ImplementationVersion = (uint32)(x.refd9407ce7.implementationVersion)
	x.Description = *(*[256]byte)(unsafe.Pointer(&x.refd9407ce7.description))
}

// allocSubmitInfoMemory allocates memory for type C.VkSubmitInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSubmitInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSubmitInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSubmitInfoValue = unsafe.Sizeof([1]C.VkSubmitInfo{})

// copyPSemaphoreBytes copies the data from Go slice as *C.VkSemaphore.
func copyPSemaphoreBytes(slice *sliceHeader) (*C.VkSemaphore, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfSemaphoreValue) * slice.Len,
		Cap:  int(sizeOfSemaphoreValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkSemaphore)(mem0), allocs
}

// allocSemaphoreMemory allocates memory for type C.VkSemaphore in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSemaphoreMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSemaphoreValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSemaphoreValue = unsafe.Sizeof([1]C.VkSemaphore{})

// copyPPipelineStageFlagsBytes copies the data from Go slice as *C.VkPipelineStageFlags.
func copyPPipelineStageFlagsBytes(slice *sliceHeader) (*C.VkPipelineStageFlags, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfPipelineStageFlagsValue) * slice.Len,
		Cap:  int(sizeOfPipelineStageFlagsValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkPipelineStageFlags)(mem0), allocs
}

// allocPipelineStageFlagsMemory allocates memory for type C.VkPipelineStageFlags in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineStageFlagsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineStageFlagsValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPipelineStageFlagsValue = unsafe.Sizeof([1]C.VkPipelineStageFlags{})

// copyPCommandBufferBytes copies the data from Go slice as *C.VkCommandBuffer.
func copyPCommandBufferBytes(slice *sliceHeader) (*C.VkCommandBuffer, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfCommandBufferValue) * slice.Len,
		Cap:  int(sizeOfCommandBufferValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkCommandBuffer)(mem0), allocs
}

// allocCommandBufferMemory allocates memory for type C.VkCommandBuffer in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCommandBufferMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCommandBufferValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCommandBufferValue = unsafe.Sizeof([1]C.VkCommandBuffer{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SubmitInfo) Ref() *C.VkSubmitInfo {
	if x == nil {
		return nil
	}
	return x.ref22884025
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SubmitInfo) Free() {
	if x != nil && x.allocs22884025 != nil {
		x.allocs22884025.(*cgoAllocMap).Free()
		x.ref22884025 = nil
	}
}

// NewSubmitInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSubmitInfoRef(ref unsafe.Pointer) *SubmitInfo {
	if ref == nil {
		return nil
	}
	obj := new(SubmitInfo)
	obj.ref22884025 = (*C.VkSubmitInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SubmitInfo) PassRef() (*C.VkSubmitInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref22884025 != nil {
		return x.ref22884025, nil
	}
	mem22884025 := allocSubmitInfoMemory(1)
	ref22884025 := (*C.VkSubmitInfo)(mem22884025)
	allocs22884025 := new(cgoAllocMap)
	allocs22884025.Add(mem22884025)

	ref22884025.sType = (C.VkStructureType)(x.SType)

	ref22884025.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref22884025.waitSemaphoreCount = (C.uint32_t)(x.WaitSemaphoreCount)

	if x.PWaitSemaphores != nil {
		var cpWaitSemaphores_allocs *cgoAllocMap
		ref22884025.pWaitSemaphores, cpWaitSemaphores_allocs = copyPSemaphoreBytes((*sliceHeader)(unsafe.Pointer(&x.PWaitSemaphores)))
		allocs22884025.Borrow(cpWaitSemaphores_allocs)
	}

	if x.PWaitDstStageMask != nil {
		var cpWaitDstStageMask_allocs *cgoAllocMap
		ref22884025.pWaitDstStageMask, cpWaitDstStageMask_allocs = copyPPipelineStageFlagsBytes((*sliceHeader)(unsafe.Pointer(&x.PWaitDstStageMask)))
		allocs22884025.Borrow(cpWaitDstStageMask_allocs)
	}

	ref22884025.commandBufferCount = (C.uint32_t)(x.CommandBufferCount)

	if x.PCommandBuffers != nil {
		var cpCommandBuffers_allocs *cgoAllocMap
		ref22884025.pCommandBuffers, cpCommandBuffers_allocs = copyPCommandBufferBytes((*sliceHeader)(unsafe.Pointer(&x.PCommandBuffers)))
		allocs22884025.Borrow(cpCommandBuffers_allocs)
	}

	ref22884025.signalSemaphoreCount = (C.uint32_t)(x.SignalSemaphoreCount)

	if x.PSignalSemaphores != nil {
		var cpSignalSemaphores_allocs *cgoAllocMap
		ref22884025.pSignalSemaphores, cpSignalSemaphores_allocs = copyPSemaphoreBytes((*sliceHeader)(unsafe.Pointer(&x.PSignalSemaphores)))
		allocs22884025.Borrow(cpSignalSemaphores_allocs)
	}

	x.ref22884025 = ref22884025
	x.allocs22884025 = allocs22884025
	return ref22884025, allocs22884025

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SubmitInfo) PassValue() (C.VkSubmitInfo, *cgoAllocMap) {
	if x.ref22884025 != nil {
		return *x.ref22884025, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SubmitInfo) Deref() {
	if x.ref22884025 == nil {
		return
	}
	x.SType = (StructureType)(x.ref22884025.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref22884025.pNext))
	x.WaitSemaphoreCount = (uint32)(x.ref22884025.waitSemaphoreCount)
	hxfa9955c := (*sliceHeader)(unsafe.Pointer(&x.PWaitSemaphores))
	hxfa9955c.Data = unsafe.Pointer(x.ref22884025.pWaitSemaphores)
	hxfa9955c.Cap = 0x7fffffff
	// hxfa9955c.Len = ? x.PWaitSemaphores x.ref22884025.pWaitSemaphores

	hxfa3f05c := (*sliceHeader)(unsafe.Pointer(&x.PWaitDstStageMask))
	hxfa3f05c.Data = unsafe.Pointer(x.ref22884025.pWaitDstStageMask)
	hxfa3f05c.Cap = 0x7fffffff
	// hxfa3f05c.Len = ? x.PWaitDstStageMask x.ref22884025.pWaitDstStageMask

	x.CommandBufferCount = (uint32)(x.ref22884025.commandBufferCount)
	hxf0d18b7 := (*sliceHeader)(unsafe.Pointer(&x.PCommandBuffers))
	hxf0d18b7.Data = unsafe.Pointer(x.ref22884025.pCommandBuffers)
	hxf0d18b7.Cap = 0x7fffffff
	// hxf0d18b7.Len = ? x.PCommandBuffers x.ref22884025.pCommandBuffers

	x.SignalSemaphoreCount = (uint32)(x.ref22884025.signalSemaphoreCount)
	hxf2fab0d := (*sliceHeader)(unsafe.Pointer(&x.PSignalSemaphores))
	hxf2fab0d.Data = unsafe.Pointer(x.ref22884025.pSignalSemaphores)
	hxf2fab0d.Cap = 0x7fffffff
	// hxf2fab0d.Len = ? x.PSignalSemaphores x.ref22884025.pSignalSemaphores

}

// allocMappedMemoryRangeMemory allocates memory for type C.VkMappedMemoryRange in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMappedMemoryRangeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMappedMemoryRangeValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfMappedMemoryRangeValue = unsafe.Sizeof([1]C.VkMappedMemoryRange{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *MappedMemoryRange) Ref() *C.VkMappedMemoryRange {
	if x == nil {
		return nil
	}
	return x.ref42a37320
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *MappedMemoryRange) Free() {
	if x != nil && x.allocs42a37320 != nil {
		x.allocs42a37320.(*cgoAllocMap).Free()
		x.ref42a37320 = nil
	}
}

// NewMappedMemoryRangeRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMappedMemoryRangeRef(ref unsafe.Pointer) *MappedMemoryRange {
	if ref == nil {
		return nil
	}
	obj := new(MappedMemoryRange)
	obj.ref42a37320 = (*C.VkMappedMemoryRange)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *MappedMemoryRange) PassRef() (*C.VkMappedMemoryRange, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref42a37320 != nil {
		return x.ref42a37320, nil
	}
	mem42a37320 := allocMappedMemoryRangeMemory(1)
	ref42a37320 := (*C.VkMappedMemoryRange)(mem42a37320)
	allocs42a37320 := new(cgoAllocMap)
	allocs42a37320.Add(mem42a37320)

	ref42a37320.sType = (C.VkStructureType)(x.SType)

	ref42a37320.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref42a37320.memory = *(*C.VkDeviceMemory)(unsafe.Pointer(&x.Memory))

	ref42a37320.offset = (C.VkDeviceSize)(x.Offset)

	ref42a37320.size = (C.VkDeviceSize)(x.Size)

	x.ref42a37320 = ref42a37320
	x.allocs42a37320 = allocs42a37320
	return ref42a37320, allocs42a37320

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x MappedMemoryRange) PassValue() (C.VkMappedMemoryRange, *cgoAllocMap) {
	if x.ref42a37320 != nil {
		return *x.ref42a37320, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *MappedMemoryRange) Deref() {
	if x.ref42a37320 == nil {
		return
	}
	x.SType = (StructureType)(x.ref42a37320.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref42a37320.pNext))
	x.Memory = *(*DeviceMemory)(unsafe.Pointer(&x.ref42a37320.memory))
	x.Offset = (DeviceSize)(x.ref42a37320.offset)
	x.Size = (DeviceSize)(x.ref42a37320.size)
}

// allocSparseMemoryBindMemory allocates memory for type C.VkSparseMemoryBind in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSparseMemoryBindMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSparseMemoryBindValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSparseMemoryBindValue = unsafe.Sizeof([1]C.VkSparseMemoryBind{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SparseMemoryBind) Ref() *C.VkSparseMemoryBind {
	if x == nil {
		return nil
	}
	return x.ref5bf418e8
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SparseMemoryBind) Free() {
	if x != nil && x.allocs5bf418e8 != nil {
		x.allocs5bf418e8.(*cgoAllocMap).Free()
		x.ref5bf418e8 = nil
	}
}

// NewSparseMemoryBindRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSparseMemoryBindRef(ref unsafe.Pointer) *SparseMemoryBind {
	if ref == nil {
		return nil
	}
	obj := new(SparseMemoryBind)
	obj.ref5bf418e8 = (*C.VkSparseMemoryBind)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SparseMemoryBind) PassRef() (*C.VkSparseMemoryBind, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5bf418e8 != nil {
		return x.ref5bf418e8, nil
	}
	mem5bf418e8 := allocSparseMemoryBindMemory(1)
	ref5bf418e8 := (*C.VkSparseMemoryBind)(mem5bf418e8)
	allocs5bf418e8 := new(cgoAllocMap)
	allocs5bf418e8.Add(mem5bf418e8)

	ref5bf418e8.resourceOffset = (C.VkDeviceSize)(x.ResourceOffset)

	ref5bf418e8.size = (C.VkDeviceSize)(x.Size)

	ref5bf418e8.memory = *(*C.VkDeviceMemory)(unsafe.Pointer(&x.Memory))

	ref5bf418e8.memoryOffset = (C.VkDeviceSize)(x.MemoryOffset)

	ref5bf418e8.flags = (C.VkSparseMemoryBindFlags)(x.Flags)

	x.ref5bf418e8 = ref5bf418e8
	x.allocs5bf418e8 = allocs5bf418e8
	return ref5bf418e8, allocs5bf418e8

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SparseMemoryBind) PassValue() (C.VkSparseMemoryBind, *cgoAllocMap) {
	if x.ref5bf418e8 != nil {
		return *x.ref5bf418e8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SparseMemoryBind) Deref() {
	if x.ref5bf418e8 == nil {
		return
	}
	x.ResourceOffset = (DeviceSize)(x.ref5bf418e8.resourceOffset)
	x.Size = (DeviceSize)(x.ref5bf418e8.size)
	x.Memory = *(*DeviceMemory)(unsafe.Pointer(&x.ref5bf418e8.memory))
	x.MemoryOffset = (DeviceSize)(x.ref5bf418e8.memoryOffset)
	x.Flags = (SparseMemoryBindFlags)(x.ref5bf418e8.flags)
}

// allocSparseBufferMemoryBindInfoMemory allocates memory for type C.VkSparseBufferMemoryBindInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSparseBufferMemoryBindInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSparseBufferMemoryBindInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSparseBufferMemoryBindInfoValue = unsafe.Sizeof([1]C.VkSparseBufferMemoryBindInfo{})

// unpackSSparseMemoryBind transforms a sliced Go data structure into plain C format.
func unpackSSparseMemoryBind(x []SparseMemoryBind) (unpacked *C.VkSparseMemoryBind, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocSparseMemoryBindMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSparseMemoryBind)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSparseMemoryBind)(h.Data)
	return
}

// packSSparseMemoryBind reads sliced Go data structure out from plain C format.
func packSSparseMemoryBind(v []SparseMemoryBind, ptr0 *C.VkSparseMemoryBind) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSparseMemoryBindValue]C.VkSparseMemoryBind)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSparseMemoryBindRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SparseBufferMemoryBindInfo) Ref() *C.VkSparseBufferMemoryBindInfo {
	if x == nil {
		return nil
	}
	return x.refebcaf40c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SparseBufferMemoryBindInfo) Free() {
	if x != nil && x.allocsebcaf40c != nil {
		x.allocsebcaf40c.(*cgoAllocMap).Free()
		x.refebcaf40c = nil
	}
}

// NewSparseBufferMemoryBindInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSparseBufferMemoryBindInfoRef(ref unsafe.Pointer) *SparseBufferMemoryBindInfo {
	if ref == nil {
		return nil
	}
	obj := new(SparseBufferMemoryBindInfo)
	obj.refebcaf40c = (*C.VkSparseBufferMemoryBindInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SparseBufferMemoryBindInfo) PassRef() (*C.VkSparseBufferMemoryBindInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refebcaf40c != nil {
		return x.refebcaf40c, nil
	}
	memebcaf40c := allocSparseBufferMemoryBindInfoMemory(1)
	refebcaf40c := (*C.VkSparseBufferMemoryBindInfo)(memebcaf40c)
	allocsebcaf40c := new(cgoAllocMap)
	allocsebcaf40c.Add(memebcaf40c)

	refebcaf40c.buffer = *(*C.VkBuffer)(unsafe.Pointer(&x.Buffer))

	refebcaf40c.bindCount = (C.uint32_t)(x.BindCount)

	var cpBinds_allocs *cgoAllocMap
	refebcaf40c.pBinds, cpBinds_allocs = unpackSSparseMemoryBind(x.PBinds)
	allocsebcaf40c.Borrow(cpBinds_allocs)

	x.refebcaf40c = refebcaf40c
	x.allocsebcaf40c = allocsebcaf40c
	return refebcaf40c, allocsebcaf40c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SparseBufferMemoryBindInfo) PassValue() (C.VkSparseBufferMemoryBindInfo, *cgoAllocMap) {
	if x.refebcaf40c != nil {
		return *x.refebcaf40c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SparseBufferMemoryBindInfo) Deref() {
	if x.refebcaf40c == nil {
		return
	}
	x.Buffer = *(*Buffer)(unsafe.Pointer(&x.refebcaf40c.buffer))
	x.BindCount = (uint32)(x.refebcaf40c.bindCount)
	packSSparseMemoryBind(x.PBinds, x.refebcaf40c.pBinds)
}

// allocSparseImageOpaqueMemoryBindInfoMemory allocates memory for type C.VkSparseImageOpaqueMemoryBindInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSparseImageOpaqueMemoryBindInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSparseImageOpaqueMemoryBindInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSparseImageOpaqueMemoryBindInfoValue = unsafe.Sizeof([1]C.VkSparseImageOpaqueMemoryBindInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SparseImageOpaqueMemoryBindInfo) Ref() *C.VkSparseImageOpaqueMemoryBindInfo {
	if x == nil {
		return nil
	}
	return x.reffb1b3d56
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SparseImageOpaqueMemoryBindInfo) Free() {
	if x != nil && x.allocsfb1b3d56 != nil {
		x.allocsfb1b3d56.(*cgoAllocMap).Free()
		x.reffb1b3d56 = nil
	}
}

// NewSparseImageOpaqueMemoryBindInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSparseImageOpaqueMemoryBindInfoRef(ref unsafe.Pointer) *SparseImageOpaqueMemoryBindInfo {
	if ref == nil {
		return nil
	}
	obj := new(SparseImageOpaqueMemoryBindInfo)
	obj.reffb1b3d56 = (*C.VkSparseImageOpaqueMemoryBindInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SparseImageOpaqueMemoryBindInfo) PassRef() (*C.VkSparseImageOpaqueMemoryBindInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reffb1b3d56 != nil {
		return x.reffb1b3d56, nil
	}
	memfb1b3d56 := allocSparseImageOpaqueMemoryBindInfoMemory(1)
	reffb1b3d56 := (*C.VkSparseImageOpaqueMemoryBindInfo)(memfb1b3d56)
	allocsfb1b3d56 := new(cgoAllocMap)
	allocsfb1b3d56.Add(memfb1b3d56)

	reffb1b3d56.image = *(*C.VkImage)(unsafe.Pointer(&x.Image))

	reffb1b3d56.bindCount = (C.uint32_t)(x.BindCount)

	var cpBinds_allocs *cgoAllocMap
	reffb1b3d56.pBinds, cpBinds_allocs = unpackSSparseMemoryBind(x.PBinds)
	allocsfb1b3d56.Borrow(cpBinds_allocs)

	x.reffb1b3d56 = reffb1b3d56
	x.allocsfb1b3d56 = allocsfb1b3d56
	return reffb1b3d56, allocsfb1b3d56

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SparseImageOpaqueMemoryBindInfo) PassValue() (C.VkSparseImageOpaqueMemoryBindInfo, *cgoAllocMap) {
	if x.reffb1b3d56 != nil {
		return *x.reffb1b3d56, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SparseImageOpaqueMemoryBindInfo) Deref() {
	if x.reffb1b3d56 == nil {
		return
	}
	x.Image = *(*Image)(unsafe.Pointer(&x.reffb1b3d56.image))
	x.BindCount = (uint32)(x.reffb1b3d56.bindCount)
	packSSparseMemoryBind(x.PBinds, x.reffb1b3d56.pBinds)
}

// allocSparseImageMemoryBindMemory allocates memory for type C.VkSparseImageMemoryBind in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSparseImageMemoryBindMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSparseImageMemoryBindValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSparseImageMemoryBindValue = unsafe.Sizeof([1]C.VkSparseImageMemoryBind{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SparseImageMemoryBind) Ref() *C.VkSparseImageMemoryBind {
	if x == nil {
		return nil
	}
	return x.ref41b516d7
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SparseImageMemoryBind) Free() {
	if x != nil && x.allocs41b516d7 != nil {
		x.allocs41b516d7.(*cgoAllocMap).Free()
		x.ref41b516d7 = nil
	}
}

// NewSparseImageMemoryBindRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSparseImageMemoryBindRef(ref unsafe.Pointer) *SparseImageMemoryBind {
	if ref == nil {
		return nil
	}
	obj := new(SparseImageMemoryBind)
	obj.ref41b516d7 = (*C.VkSparseImageMemoryBind)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SparseImageMemoryBind) PassRef() (*C.VkSparseImageMemoryBind, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref41b516d7 != nil {
		return x.ref41b516d7, nil
	}
	mem41b516d7 := allocSparseImageMemoryBindMemory(1)
	ref41b516d7 := (*C.VkSparseImageMemoryBind)(mem41b516d7)
	allocs41b516d7 := new(cgoAllocMap)
	allocs41b516d7.Add(mem41b516d7)

	ref41b516d7.subresource = *(*C.VkImageSubresource)(unsafe.Pointer(&x.Subresource))

	ref41b516d7.offset = *(*C.VkOffset3D)(unsafe.Pointer(&x.Offset))

	ref41b516d7.extent = *(*C.VkExtent3D)(unsafe.Pointer(&x.Extent))

	ref41b516d7.memory = *(*C.VkDeviceMemory)(unsafe.Pointer(&x.Memory))

	ref41b516d7.memoryOffset = (C.VkDeviceSize)(x.MemoryOffset)

	ref41b516d7.flags = (C.VkSparseMemoryBindFlags)(x.Flags)

	x.ref41b516d7 = ref41b516d7
	x.allocs41b516d7 = allocs41b516d7
	return ref41b516d7, allocs41b516d7

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SparseImageMemoryBind) PassValue() (C.VkSparseImageMemoryBind, *cgoAllocMap) {
	if x.ref41b516d7 != nil {
		return *x.ref41b516d7, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SparseImageMemoryBind) Deref() {
	if x.ref41b516d7 == nil {
		return
	}
	x.Subresource = *(*ImageSubresource)(unsafe.Pointer(&x.ref41b516d7.subresource))
	x.Offset = *(*Offset3D)(unsafe.Pointer(&x.ref41b516d7.offset))
	x.Extent = *(*Extent3D)(unsafe.Pointer(&x.ref41b516d7.extent))
	x.Memory = *(*DeviceMemory)(unsafe.Pointer(&x.ref41b516d7.memory))
	x.MemoryOffset = (DeviceSize)(x.ref41b516d7.memoryOffset)
	x.Flags = (SparseMemoryBindFlags)(x.ref41b516d7.flags)
}

// allocSparseImageMemoryBindInfoMemory allocates memory for type C.VkSparseImageMemoryBindInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSparseImageMemoryBindInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSparseImageMemoryBindInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSparseImageMemoryBindInfoValue = unsafe.Sizeof([1]C.VkSparseImageMemoryBindInfo{})

// unpackSSparseImageMemoryBind transforms a sliced Go data structure into plain C format.
func unpackSSparseImageMemoryBind(x []SparseImageMemoryBind) (unpacked *C.VkSparseImageMemoryBind, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocSparseImageMemoryBindMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSparseImageMemoryBind)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSparseImageMemoryBind)(h.Data)
	return
}

// packSSparseImageMemoryBind reads sliced Go data structure out from plain C format.
func packSSparseImageMemoryBind(v []SparseImageMemoryBind, ptr0 *C.VkSparseImageMemoryBind) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSparseImageMemoryBindValue]C.VkSparseImageMemoryBind)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSparseImageMemoryBindRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SparseImageMemoryBindInfo) Ref() *C.VkSparseImageMemoryBindInfo {
	if x == nil {
		return nil
	}
	return x.ref50faeb70
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SparseImageMemoryBindInfo) Free() {
	if x != nil && x.allocs50faeb70 != nil {
		x.allocs50faeb70.(*cgoAllocMap).Free()
		x.ref50faeb70 = nil
	}
}

// NewSparseImageMemoryBindInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSparseImageMemoryBindInfoRef(ref unsafe.Pointer) *SparseImageMemoryBindInfo {
	if ref == nil {
		return nil
	}
	obj := new(SparseImageMemoryBindInfo)
	obj.ref50faeb70 = (*C.VkSparseImageMemoryBindInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SparseImageMemoryBindInfo) PassRef() (*C.VkSparseImageMemoryBindInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref50faeb70 != nil {
		return x.ref50faeb70, nil
	}
	mem50faeb70 := allocSparseImageMemoryBindInfoMemory(1)
	ref50faeb70 := (*C.VkSparseImageMemoryBindInfo)(mem50faeb70)
	allocs50faeb70 := new(cgoAllocMap)
	allocs50faeb70.Add(mem50faeb70)

	ref50faeb70.image = *(*C.VkImage)(unsafe.Pointer(&x.Image))

	ref50faeb70.bindCount = (C.uint32_t)(x.BindCount)

	var cpBinds_allocs *cgoAllocMap
	ref50faeb70.pBinds, cpBinds_allocs = unpackSSparseImageMemoryBind(x.PBinds)
	allocs50faeb70.Borrow(cpBinds_allocs)

	x.ref50faeb70 = ref50faeb70
	x.allocs50faeb70 = allocs50faeb70
	return ref50faeb70, allocs50faeb70

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SparseImageMemoryBindInfo) PassValue() (C.VkSparseImageMemoryBindInfo, *cgoAllocMap) {
	if x.ref50faeb70 != nil {
		return *x.ref50faeb70, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SparseImageMemoryBindInfo) Deref() {
	if x.ref50faeb70 == nil {
		return
	}
	x.Image = *(*Image)(unsafe.Pointer(&x.ref50faeb70.image))
	x.BindCount = (uint32)(x.ref50faeb70.bindCount)
	packSSparseImageMemoryBind(x.PBinds, x.ref50faeb70.pBinds)
}

// allocBindSparseInfoMemory allocates memory for type C.VkBindSparseInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBindSparseInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBindSparseInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBindSparseInfoValue = unsafe.Sizeof([1]C.VkBindSparseInfo{})

// unpackSSparseBufferMemoryBindInfo transforms a sliced Go data structure into plain C format.
func unpackSSparseBufferMemoryBindInfo(x []SparseBufferMemoryBindInfo) (unpacked *C.VkSparseBufferMemoryBindInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocSparseBufferMemoryBindInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSparseBufferMemoryBindInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSparseBufferMemoryBindInfo)(h.Data)
	return
}

// unpackSSparseImageOpaqueMemoryBindInfo transforms a sliced Go data structure into plain C format.
func unpackSSparseImageOpaqueMemoryBindInfo(x []SparseImageOpaqueMemoryBindInfo) (unpacked *C.VkSparseImageOpaqueMemoryBindInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocSparseImageOpaqueMemoryBindInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSparseImageOpaqueMemoryBindInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSparseImageOpaqueMemoryBindInfo)(h.Data)
	return
}

// unpackSSparseImageMemoryBindInfo transforms a sliced Go data structure into plain C format.
func unpackSSparseImageMemoryBindInfo(x []SparseImageMemoryBindInfo) (unpacked *C.VkSparseImageMemoryBindInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocSparseImageMemoryBindInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSparseImageMemoryBindInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSparseImageMemoryBindInfo)(h.Data)
	return
}

// packSSparseBufferMemoryBindInfo reads sliced Go data structure out from plain C format.
func packSSparseBufferMemoryBindInfo(v []SparseBufferMemoryBindInfo, ptr0 *C.VkSparseBufferMemoryBindInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSparseBufferMemoryBindInfoValue]C.VkSparseBufferMemoryBindInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSparseBufferMemoryBindInfoRef(unsafe.Pointer(&ptr1))
	}
}

// packSSparseImageOpaqueMemoryBindInfo reads sliced Go data structure out from plain C format.
func packSSparseImageOpaqueMemoryBindInfo(v []SparseImageOpaqueMemoryBindInfo, ptr0 *C.VkSparseImageOpaqueMemoryBindInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSparseImageOpaqueMemoryBindInfoValue]C.VkSparseImageOpaqueMemoryBindInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSparseImageOpaqueMemoryBindInfoRef(unsafe.Pointer(&ptr1))
	}
}

// packSSparseImageMemoryBindInfo reads sliced Go data structure out from plain C format.
func packSSparseImageMemoryBindInfo(v []SparseImageMemoryBindInfo, ptr0 *C.VkSparseImageMemoryBindInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSparseImageMemoryBindInfoValue]C.VkSparseImageMemoryBindInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSparseImageMemoryBindInfoRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BindSparseInfo) Ref() *C.VkBindSparseInfo {
	if x == nil {
		return nil
	}
	return x.refb0cbe910
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BindSparseInfo) Free() {
	if x != nil && x.allocsb0cbe910 != nil {
		x.allocsb0cbe910.(*cgoAllocMap).Free()
		x.refb0cbe910 = nil
	}
}

// NewBindSparseInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBindSparseInfoRef(ref unsafe.Pointer) *BindSparseInfo {
	if ref == nil {
		return nil
	}
	obj := new(BindSparseInfo)
	obj.refb0cbe910 = (*C.VkBindSparseInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BindSparseInfo) PassRef() (*C.VkBindSparseInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb0cbe910 != nil {
		return x.refb0cbe910, nil
	}
	memb0cbe910 := allocBindSparseInfoMemory(1)
	refb0cbe910 := (*C.VkBindSparseInfo)(memb0cbe910)
	allocsb0cbe910 := new(cgoAllocMap)
	allocsb0cbe910.Add(memb0cbe910)

	refb0cbe910.sType = (C.VkStructureType)(x.SType)

	refb0cbe910.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	refb0cbe910.waitSemaphoreCount = (C.uint32_t)(x.WaitSemaphoreCount)

	if x.PWaitSemaphores != nil {
		var cpWaitSemaphores_allocs *cgoAllocMap
		refb0cbe910.pWaitSemaphores, cpWaitSemaphores_allocs = copyPSemaphoreBytes((*sliceHeader)(unsafe.Pointer(&x.PWaitSemaphores)))
		allocsb0cbe910.Borrow(cpWaitSemaphores_allocs)
	}

	refb0cbe910.bufferBindCount = (C.uint32_t)(x.BufferBindCount)

	var cpBufferBinds_allocs *cgoAllocMap
	refb0cbe910.pBufferBinds, cpBufferBinds_allocs = unpackSSparseBufferMemoryBindInfo(x.PBufferBinds)
	allocsb0cbe910.Borrow(cpBufferBinds_allocs)

	refb0cbe910.imageOpaqueBindCount = (C.uint32_t)(x.ImageOpaqueBindCount)

	var cpImageOpaqueBinds_allocs *cgoAllocMap
	refb0cbe910.pImageOpaqueBinds, cpImageOpaqueBinds_allocs = unpackSSparseImageOpaqueMemoryBindInfo(x.PImageOpaqueBinds)
	allocsb0cbe910.Borrow(cpImageOpaqueBinds_allocs)

	refb0cbe910.imageBindCount = (C.uint32_t)(x.ImageBindCount)

	var cpImageBinds_allocs *cgoAllocMap
	refb0cbe910.pImageBinds, cpImageBinds_allocs = unpackSSparseImageMemoryBindInfo(x.PImageBinds)
	allocsb0cbe910.Borrow(cpImageBinds_allocs)

	refb0cbe910.signalSemaphoreCount = (C.uint32_t)(x.SignalSemaphoreCount)

	if x.PSignalSemaphores != nil {
		var cpSignalSemaphores_allocs *cgoAllocMap
		refb0cbe910.pSignalSemaphores, cpSignalSemaphores_allocs = copyPSemaphoreBytes((*sliceHeader)(unsafe.Pointer(&x.PSignalSemaphores)))
		allocsb0cbe910.Borrow(cpSignalSemaphores_allocs)
	}

	x.refb0cbe910 = refb0cbe910
	x.allocsb0cbe910 = allocsb0cbe910
	return refb0cbe910, allocsb0cbe910

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BindSparseInfo) PassValue() (C.VkBindSparseInfo, *cgoAllocMap) {
	if x.refb0cbe910 != nil {
		return *x.refb0cbe910, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BindSparseInfo) Deref() {
	if x.refb0cbe910 == nil {
		return
	}
	x.SType = (StructureType)(x.refb0cbe910.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refb0cbe910.pNext))
	x.WaitSemaphoreCount = (uint32)(x.refb0cbe910.waitSemaphoreCount)
	hxf69fe70 := (*sliceHeader)(unsafe.Pointer(&x.PWaitSemaphores))
	hxf69fe70.Data = unsafe.Pointer(x.refb0cbe910.pWaitSemaphores)
	hxf69fe70.Cap = 0x7fffffff
	// hxf69fe70.Len = ? x.PWaitSemaphores x.refb0cbe910.pWaitSemaphores

	x.BufferBindCount = (uint32)(x.refb0cbe910.bufferBindCount)
	packSSparseBufferMemoryBindInfo(x.PBufferBinds, x.refb0cbe910.pBufferBinds)
	x.ImageOpaqueBindCount = (uint32)(x.refb0cbe910.imageOpaqueBindCount)
	packSSparseImageOpaqueMemoryBindInfo(x.PImageOpaqueBinds, x.refb0cbe910.pImageOpaqueBinds)
	x.ImageBindCount = (uint32)(x.refb0cbe910.imageBindCount)
	packSSparseImageMemoryBindInfo(x.PImageBinds, x.refb0cbe910.pImageBinds)
	x.SignalSemaphoreCount = (uint32)(x.refb0cbe910.signalSemaphoreCount)
	hxf65bf54 := (*sliceHeader)(unsafe.Pointer(&x.PSignalSemaphores))
	hxf65bf54.Data = unsafe.Pointer(x.refb0cbe910.pSignalSemaphores)
	hxf65bf54.Cap = 0x7fffffff
	// hxf65bf54.Len = ? x.PSignalSemaphores x.refb0cbe910.pSignalSemaphores

}

// allocBufferCreateInfoMemory allocates memory for type C.VkBufferCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBufferCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBufferCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBufferCreateInfoValue = unsafe.Sizeof([1]C.VkBufferCreateInfo{})

// copyPUint32_tBytes copies the data from Go slice as *C.uint32_t.
func copyPUint32_tBytes(slice *sliceHeader) (*C.uint32_t, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfUint32_tValue) * slice.Len,
		Cap:  int(sizeOfUint32_tValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.uint32_t)(mem0), allocs
}

// allocUint32_tMemory allocates memory for type C.uint32_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocUint32_tMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfUint32_tValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfUint32_tValue = unsafe.Sizeof([1]C.uint32_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BufferCreateInfo) Ref() *C.VkBufferCreateInfo {
	if x == nil {
		return nil
	}
	return x.reffe19d2cd
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BufferCreateInfo) Free() {
	if x != nil && x.allocsfe19d2cd != nil {
		x.allocsfe19d2cd.(*cgoAllocMap).Free()
		x.reffe19d2cd = nil
	}
}

// NewBufferCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBufferCreateInfoRef(ref unsafe.Pointer) *BufferCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(BufferCreateInfo)
	obj.reffe19d2cd = (*C.VkBufferCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BufferCreateInfo) PassRef() (*C.VkBufferCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reffe19d2cd != nil {
		return x.reffe19d2cd, nil
	}
	memfe19d2cd := allocBufferCreateInfoMemory(1)
	reffe19d2cd := (*C.VkBufferCreateInfo)(memfe19d2cd)
	allocsfe19d2cd := new(cgoAllocMap)
	allocsfe19d2cd.Add(memfe19d2cd)

	reffe19d2cd.sType = (C.VkStructureType)(x.SType)

	reffe19d2cd.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	reffe19d2cd.flags = (C.VkBufferCreateFlags)(x.Flags)

	reffe19d2cd.size = (C.VkDeviceSize)(x.Size)

	reffe19d2cd.usage = (C.VkBufferUsageFlags)(x.Usage)

	reffe19d2cd.sharingMode = (C.VkSharingMode)(x.SharingMode)

	reffe19d2cd.queueFamilyIndexCount = (C.uint32_t)(x.QueueFamilyIndexCount)

	if x.PQueueFamilyIndices != nil {
		var cpQueueFamilyIndices_allocs *cgoAllocMap
		reffe19d2cd.pQueueFamilyIndices, cpQueueFamilyIndices_allocs = copyPUint32_tBytes((*sliceHeader)(unsafe.Pointer(&x.PQueueFamilyIndices)))
		allocsfe19d2cd.Borrow(cpQueueFamilyIndices_allocs)
	}

	x.reffe19d2cd = reffe19d2cd
	x.allocsfe19d2cd = allocsfe19d2cd
	return reffe19d2cd, allocsfe19d2cd

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BufferCreateInfo) PassValue() (C.VkBufferCreateInfo, *cgoAllocMap) {
	if x.reffe19d2cd != nil {
		return *x.reffe19d2cd, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BufferCreateInfo) Deref() {
	if x.reffe19d2cd == nil {
		return
	}
	x.SType = (StructureType)(x.reffe19d2cd.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.reffe19d2cd.pNext))
	x.Flags = (BufferCreateFlags)(x.reffe19d2cd.flags)
	x.Size = (DeviceSize)(x.reffe19d2cd.size)
	x.Usage = (BufferUsageFlags)(x.reffe19d2cd.usage)
	x.SharingMode = (SharingMode)(x.reffe19d2cd.sharingMode)
	x.QueueFamilyIndexCount = (uint32)(x.reffe19d2cd.queueFamilyIndexCount)
	hxf3b8dbd := (*sliceHeader)(unsafe.Pointer(&x.PQueueFamilyIndices))
	hxf3b8dbd.Data = unsafe.Pointer(x.reffe19d2cd.pQueueFamilyIndices)
	hxf3b8dbd.Cap = 0x7fffffff
	// hxf3b8dbd.Len = ? x.PQueueFamilyIndices x.reffe19d2cd.pQueueFamilyIndices

}

// allocBufferViewCreateInfoMemory allocates memory for type C.VkBufferViewCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBufferViewCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBufferViewCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBufferViewCreateInfoValue = unsafe.Sizeof([1]C.VkBufferViewCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BufferViewCreateInfo) Ref() *C.VkBufferViewCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref49b97027
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BufferViewCreateInfo) Free() {
	if x != nil && x.allocs49b97027 != nil {
		x.allocs49b97027.(*cgoAllocMap).Free()
		x.ref49b97027 = nil
	}
}

// NewBufferViewCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBufferViewCreateInfoRef(ref unsafe.Pointer) *BufferViewCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(BufferViewCreateInfo)
	obj.ref49b97027 = (*C.VkBufferViewCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BufferViewCreateInfo) PassRef() (*C.VkBufferViewCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref49b97027 != nil {
		return x.ref49b97027, nil
	}
	mem49b97027 := allocBufferViewCreateInfoMemory(1)
	ref49b97027 := (*C.VkBufferViewCreateInfo)(mem49b97027)
	allocs49b97027 := new(cgoAllocMap)
	allocs49b97027.Add(mem49b97027)

	ref49b97027.sType = (C.VkStructureType)(x.SType)

	ref49b97027.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref49b97027.flags = (C.VkBufferViewCreateFlags)(x.Flags)

	ref49b97027.buffer = *(*C.VkBuffer)(unsafe.Pointer(&x.Buffer))

	ref49b97027.format = (C.VkFormat)(x.Format)

	ref49b97027.offset = (C.VkDeviceSize)(x.Offset)

	ref49b97027._range = (C.VkDeviceSize)(x.Range)

	x.ref49b97027 = ref49b97027
	x.allocs49b97027 = allocs49b97027
	return ref49b97027, allocs49b97027

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BufferViewCreateInfo) PassValue() (C.VkBufferViewCreateInfo, *cgoAllocMap) {
	if x.ref49b97027 != nil {
		return *x.ref49b97027, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BufferViewCreateInfo) Deref() {
	if x.ref49b97027 == nil {
		return
	}
	x.SType = (StructureType)(x.ref49b97027.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref49b97027.pNext))
	x.Flags = (BufferViewCreateFlags)(x.ref49b97027.flags)
	x.Buffer = *(*Buffer)(unsafe.Pointer(&x.ref49b97027.buffer))
	x.Format = (Format)(x.ref49b97027.format)
	x.Offset = (DeviceSize)(x.ref49b97027.offset)
	x.Range = (DeviceSize)(x.ref49b97027._range)
}

// allocImageCreateInfoMemory allocates memory for type C.VkImageCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfImageCreateInfoValue = unsafe.Sizeof([1]C.VkImageCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImageCreateInfo) Ref() *C.VkImageCreateInfo {
	if x == nil {
		return nil
	}
	return x.reffb587ba1
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImageCreateInfo) Free() {
	if x != nil && x.allocsfb587ba1 != nil {
		x.allocsfb587ba1.(*cgoAllocMap).Free()
		x.reffb587ba1 = nil
	}
}

// NewImageCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageCreateInfoRef(ref unsafe.Pointer) *ImageCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(ImageCreateInfo)
	obj.reffb587ba1 = (*C.VkImageCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImageCreateInfo) PassRef() (*C.VkImageCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reffb587ba1 != nil {
		return x.reffb587ba1, nil
	}
	memfb587ba1 := allocImageCreateInfoMemory(1)
	reffb587ba1 := (*C.VkImageCreateInfo)(memfb587ba1)
	allocsfb587ba1 := new(cgoAllocMap)
	allocsfb587ba1.Add(memfb587ba1)

	reffb587ba1.sType = (C.VkStructureType)(x.SType)

	reffb587ba1.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	reffb587ba1.flags = (C.VkImageCreateFlags)(x.Flags)

	reffb587ba1.imageType = (C.VkImageType)(x.ImageType)

	reffb587ba1.format = (C.VkFormat)(x.Format)

	reffb587ba1.extent = *(*C.VkExtent3D)(unsafe.Pointer(&x.Extent))

	reffb587ba1.mipLevels = (C.uint32_t)(x.MipLevels)

	reffb587ba1.arrayLayers = (C.uint32_t)(x.ArrayLayers)

	reffb587ba1.samples = (C.VkSampleCountFlagBits)(x.Samples)

	reffb587ba1.tiling = (C.VkImageTiling)(x.Tiling)

	reffb587ba1.usage = (C.VkImageUsageFlags)(x.Usage)

	reffb587ba1.sharingMode = (C.VkSharingMode)(x.SharingMode)

	reffb587ba1.queueFamilyIndexCount = (C.uint32_t)(x.QueueFamilyIndexCount)

	if x.PQueueFamilyIndices != nil {
		var cpQueueFamilyIndices_allocs *cgoAllocMap
		reffb587ba1.pQueueFamilyIndices, cpQueueFamilyIndices_allocs = copyPUint32_tBytes((*sliceHeader)(unsafe.Pointer(&x.PQueueFamilyIndices)))
		allocsfb587ba1.Borrow(cpQueueFamilyIndices_allocs)
	}

	reffb587ba1.initialLayout = (C.VkImageLayout)(x.InitialLayout)

	x.reffb587ba1 = reffb587ba1
	x.allocsfb587ba1 = allocsfb587ba1
	return reffb587ba1, allocsfb587ba1

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImageCreateInfo) PassValue() (C.VkImageCreateInfo, *cgoAllocMap) {
	if x.reffb587ba1 != nil {
		return *x.reffb587ba1, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImageCreateInfo) Deref() {
	if x.reffb587ba1 == nil {
		return
	}
	x.SType = (StructureType)(x.reffb587ba1.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.reffb587ba1.pNext))
	x.Flags = (ImageCreateFlags)(x.reffb587ba1.flags)
	x.ImageType = (ImageType)(x.reffb587ba1.imageType)
	x.Format = (Format)(x.reffb587ba1.format)
	x.Extent = *(*Extent3D)(unsafe.Pointer(&x.reffb587ba1.extent))
	x.MipLevels = (uint32)(x.reffb587ba1.mipLevels)
	x.ArrayLayers = (uint32)(x.reffb587ba1.arrayLayers)
	x.Samples = (SampleCountFlagBits)(x.reffb587ba1.samples)
	x.Tiling = (ImageTiling)(x.reffb587ba1.tiling)
	x.Usage = (ImageUsageFlags)(x.reffb587ba1.usage)
	x.SharingMode = (SharingMode)(x.reffb587ba1.sharingMode)
	x.QueueFamilyIndexCount = (uint32)(x.reffb587ba1.queueFamilyIndexCount)
	hxf7a6dff := (*sliceHeader)(unsafe.Pointer(&x.PQueueFamilyIndices))
	hxf7a6dff.Data = unsafe.Pointer(x.reffb587ba1.pQueueFamilyIndices)
	hxf7a6dff.Cap = 0x7fffffff
	// hxf7a6dff.Len = ? x.PQueueFamilyIndices x.reffb587ba1.pQueueFamilyIndices

	x.InitialLayout = (ImageLayout)(x.reffb587ba1.initialLayout)
}

// allocImageViewCreateInfoMemory allocates memory for type C.VkImageViewCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageViewCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageViewCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfImageViewCreateInfoValue = unsafe.Sizeof([1]C.VkImageViewCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImageViewCreateInfo) Ref() *C.VkImageViewCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref77e8d4b8
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImageViewCreateInfo) Free() {
	if x != nil && x.allocs77e8d4b8 != nil {
		x.allocs77e8d4b8.(*cgoAllocMap).Free()
		x.ref77e8d4b8 = nil
	}
}

// NewImageViewCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageViewCreateInfoRef(ref unsafe.Pointer) *ImageViewCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(ImageViewCreateInfo)
	obj.ref77e8d4b8 = (*C.VkImageViewCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImageViewCreateInfo) PassRef() (*C.VkImageViewCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref77e8d4b8 != nil {
		return x.ref77e8d4b8, nil
	}
	mem77e8d4b8 := allocImageViewCreateInfoMemory(1)
	ref77e8d4b8 := (*C.VkImageViewCreateInfo)(mem77e8d4b8)
	allocs77e8d4b8 := new(cgoAllocMap)
	allocs77e8d4b8.Add(mem77e8d4b8)

	ref77e8d4b8.sType = (C.VkStructureType)(x.SType)

	ref77e8d4b8.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref77e8d4b8.flags = (C.VkImageViewCreateFlags)(x.Flags)

	ref77e8d4b8.image = *(*C.VkImage)(unsafe.Pointer(&x.Image))

	ref77e8d4b8.viewType = (C.VkImageViewType)(x.ViewType)

	ref77e8d4b8.format = (C.VkFormat)(x.Format)

	ref77e8d4b8.components = *(*C.VkComponentMapping)(unsafe.Pointer(&x.Components))

	ref77e8d4b8.subresourceRange = *(*C.VkImageSubresourceRange)(unsafe.Pointer(&x.SubresourceRange))

	x.ref77e8d4b8 = ref77e8d4b8
	x.allocs77e8d4b8 = allocs77e8d4b8
	return ref77e8d4b8, allocs77e8d4b8

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImageViewCreateInfo) PassValue() (C.VkImageViewCreateInfo, *cgoAllocMap) {
	if x.ref77e8d4b8 != nil {
		return *x.ref77e8d4b8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImageViewCreateInfo) Deref() {
	if x.ref77e8d4b8 == nil {
		return
	}
	x.SType = (StructureType)(x.ref77e8d4b8.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref77e8d4b8.pNext))
	x.Flags = (ImageViewCreateFlags)(x.ref77e8d4b8.flags)
	x.Image = *(*Image)(unsafe.Pointer(&x.ref77e8d4b8.image))
	x.ViewType = (ImageViewType)(x.ref77e8d4b8.viewType)
	x.Format = (Format)(x.ref77e8d4b8.format)
	x.Components = *(*ComponentMapping)(unsafe.Pointer(&x.ref77e8d4b8.components))
	x.SubresourceRange = *(*ImageSubresourceRange)(unsafe.Pointer(&x.ref77e8d4b8.subresourceRange))
}

// allocShaderModuleCreateInfoMemory allocates memory for type C.VkShaderModuleCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocShaderModuleCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfShaderModuleCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfShaderModuleCreateInfoValue = unsafe.Sizeof([1]C.VkShaderModuleCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ShaderModuleCreateInfo) Ref() *C.VkShaderModuleCreateInfo {
	if x == nil {
		return nil
	}
	return x.refc663d23e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ShaderModuleCreateInfo) Free() {
	if x != nil && x.allocsc663d23e != nil {
		x.allocsc663d23e.(*cgoAllocMap).Free()
		x.refc663d23e = nil
	}
}

// NewShaderModuleCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewShaderModuleCreateInfoRef(ref unsafe.Pointer) *ShaderModuleCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(ShaderModuleCreateInfo)
	obj.refc663d23e = (*C.VkShaderModuleCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ShaderModuleCreateInfo) PassRef() (*C.VkShaderModuleCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc663d23e != nil {
		return x.refc663d23e, nil
	}
	memc663d23e := allocShaderModuleCreateInfoMemory(1)
	refc663d23e := (*C.VkShaderModuleCreateInfo)(memc663d23e)
	allocsc663d23e := new(cgoAllocMap)
	allocsc663d23e.Add(memc663d23e)

	refc663d23e.sType = (C.VkStructureType)(x.SType)

	refc663d23e.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	refc663d23e.flags = (C.VkShaderModuleCreateFlags)(x.Flags)

	refc663d23e.codeSize = (C.size_t)(x.CodeSize)

	if x.PCode != nil {
		var cpCode_allocs *cgoAllocMap
		refc663d23e.pCode, cpCode_allocs = copyPUint32_tBytes((*sliceHeader)(unsafe.Pointer(&x.PCode)))
		allocsc663d23e.Borrow(cpCode_allocs)
	}

	x.refc663d23e = refc663d23e
	x.allocsc663d23e = allocsc663d23e
	return refc663d23e, allocsc663d23e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ShaderModuleCreateInfo) PassValue() (C.VkShaderModuleCreateInfo, *cgoAllocMap) {
	if x.refc663d23e != nil {
		return *x.refc663d23e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ShaderModuleCreateInfo) Deref() {
	if x.refc663d23e == nil {
		return
	}
	x.SType = (StructureType)(x.refc663d23e.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refc663d23e.pNext))
	x.Flags = (ShaderModuleCreateFlags)(x.refc663d23e.flags)
	x.CodeSize = (uint64)(x.refc663d23e.codeSize)
	hxfe48d67 := (*sliceHeader)(unsafe.Pointer(&x.PCode))
	hxfe48d67.Data = unsafe.Pointer(x.refc663d23e.pCode)
	hxfe48d67.Cap = 0x7fffffff
	// hxfe48d67.Len = ? x.PCode x.refc663d23e.pCode

}

// allocSpecializationInfoMemory allocates memory for type C.VkSpecializationInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSpecializationInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSpecializationInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSpecializationInfoValue = unsafe.Sizeof([1]C.VkSpecializationInfo{})

// copyPSpecializationMapEntryBytes copies the data from Go slice as *C.VkSpecializationMapEntry.
func copyPSpecializationMapEntryBytes(slice *sliceHeader) (*C.VkSpecializationMapEntry, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfSpecializationMapEntryValue) * slice.Len,
		Cap:  int(sizeOfSpecializationMapEntryValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkSpecializationMapEntry)(mem0), allocs
}

// allocSpecializationMapEntryMemory allocates memory for type C.VkSpecializationMapEntry in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSpecializationMapEntryMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSpecializationMapEntryValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSpecializationMapEntryValue = unsafe.Sizeof([1]C.VkSpecializationMapEntry{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SpecializationInfo) Ref() *C.VkSpecializationInfo {
	if x == nil {
		return nil
	}
	return x.ref6bc395a3
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SpecializationInfo) Free() {
	if x != nil && x.allocs6bc395a3 != nil {
		x.allocs6bc395a3.(*cgoAllocMap).Free()
		x.ref6bc395a3 = nil
	}
}

// NewSpecializationInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSpecializationInfoRef(ref unsafe.Pointer) *SpecializationInfo {
	if ref == nil {
		return nil
	}
	obj := new(SpecializationInfo)
	obj.ref6bc395a3 = (*C.VkSpecializationInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SpecializationInfo) PassRef() (*C.VkSpecializationInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6bc395a3 != nil {
		return x.ref6bc395a3, nil
	}
	mem6bc395a3 := allocSpecializationInfoMemory(1)
	ref6bc395a3 := (*C.VkSpecializationInfo)(mem6bc395a3)
	allocs6bc395a3 := new(cgoAllocMap)
	allocs6bc395a3.Add(mem6bc395a3)

	ref6bc395a3.mapEntryCount = (C.uint32_t)(x.MapEntryCount)

	if x.PMapEntries != nil {
		var cpMapEntries_allocs *cgoAllocMap
		ref6bc395a3.pMapEntries, cpMapEntries_allocs = copyPSpecializationMapEntryBytes((*sliceHeader)(unsafe.Pointer(&x.PMapEntries)))
		allocs6bc395a3.Borrow(cpMapEntries_allocs)
	}

	ref6bc395a3.dataSize = (C.size_t)(x.DataSize)

	ref6bc395a3.pData = *(*unsafe.Pointer)(unsafe.Pointer(&x.PData))

	x.ref6bc395a3 = ref6bc395a3
	x.allocs6bc395a3 = allocs6bc395a3
	return ref6bc395a3, allocs6bc395a3

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SpecializationInfo) PassValue() (C.VkSpecializationInfo, *cgoAllocMap) {
	if x.ref6bc395a3 != nil {
		return *x.ref6bc395a3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SpecializationInfo) Deref() {
	if x.ref6bc395a3 == nil {
		return
	}
	x.MapEntryCount = (uint32)(x.ref6bc395a3.mapEntryCount)
	hxf4171bf := (*sliceHeader)(unsafe.Pointer(&x.PMapEntries))
	hxf4171bf.Data = unsafe.Pointer(x.ref6bc395a3.pMapEntries)
	hxf4171bf.Cap = 0x7fffffff
	// hxf4171bf.Len = ? x.PMapEntries x.ref6bc395a3.pMapEntries

	x.DataSize = (uint64)(x.ref6bc395a3.dataSize)
	x.PData = (unsafe.Pointer)(unsafe.Pointer(x.ref6bc395a3.pData))
}

// allocPipelineShaderStageCreateInfoMemory allocates memory for type C.VkPipelineShaderStageCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineShaderStageCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineShaderStageCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPipelineShaderStageCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineShaderStageCreateInfo{})

// unpackSSpecializationInfo transforms a sliced Go data structure into plain C format.
func unpackSSpecializationInfo(x []SpecializationInfo) (unpacked *C.VkSpecializationInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocSpecializationInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSpecializationInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSpecializationInfo)(h.Data)
	return
}

// packSSpecializationInfo reads sliced Go data structure out from plain C format.
func packSSpecializationInfo(v []SpecializationInfo, ptr0 *C.VkSpecializationInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSpecializationInfoValue]C.VkSpecializationInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSpecializationInfoRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineShaderStageCreateInfo) Ref() *C.VkPipelineShaderStageCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref50ba8b60
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineShaderStageCreateInfo) Free() {
	if x != nil && x.allocs50ba8b60 != nil {
		x.allocs50ba8b60.(*cgoAllocMap).Free()
		x.ref50ba8b60 = nil
	}
}

// NewPipelineShaderStageCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineShaderStageCreateInfoRef(ref unsafe.Pointer) *PipelineShaderStageCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineShaderStageCreateInfo)
	obj.ref50ba8b60 = (*C.VkPipelineShaderStageCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineShaderStageCreateInfo) PassRef() (*C.VkPipelineShaderStageCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref50ba8b60 != nil {
		return x.ref50ba8b60, nil
	}
	mem50ba8b60 := allocPipelineShaderStageCreateInfoMemory(1)
	ref50ba8b60 := (*C.VkPipelineShaderStageCreateInfo)(mem50ba8b60)
	allocs50ba8b60 := new(cgoAllocMap)
	allocs50ba8b60.Add(mem50ba8b60)

	ref50ba8b60.sType = (C.VkStructureType)(x.SType)

	ref50ba8b60.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref50ba8b60.flags = (C.VkPipelineShaderStageCreateFlags)(x.Flags)

	ref50ba8b60.stage = (C.VkShaderStageFlagBits)(x.Stage)

	ref50ba8b60.module = *(*C.VkShaderModule)(unsafe.Pointer(&x.Module))

	var cpName_allocs *cgoAllocMap
	ref50ba8b60.pName, cpName_allocs = copyPCharBytes((*sliceHeader)(unsafe.Pointer(&x.PName)))
	allocs50ba8b60.Borrow(cpName_allocs)

	var cpSpecializationInfo_allocs *cgoAllocMap
	ref50ba8b60.pSpecializationInfo, cpSpecializationInfo_allocs = unpackSSpecializationInfo(x.PSpecializationInfo)
	allocs50ba8b60.Borrow(cpSpecializationInfo_allocs)

	x.ref50ba8b60 = ref50ba8b60
	x.allocs50ba8b60 = allocs50ba8b60
	return ref50ba8b60, allocs50ba8b60

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineShaderStageCreateInfo) PassValue() (C.VkPipelineShaderStageCreateInfo, *cgoAllocMap) {
	if x.ref50ba8b60 != nil {
		return *x.ref50ba8b60, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineShaderStageCreateInfo) Deref() {
	if x.ref50ba8b60 == nil {
		return
	}
	x.SType = (StructureType)(x.ref50ba8b60.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref50ba8b60.pNext))
	x.Flags = (PipelineShaderStageCreateFlags)(x.ref50ba8b60.flags)
	x.Stage = (ShaderStageFlagBits)(x.ref50ba8b60.stage)
	x.Module = *(*ShaderModule)(unsafe.Pointer(&x.ref50ba8b60.module))
	hxf058b18 := (*sliceHeader)(unsafe.Pointer(&x.PName))
	hxf058b18.Data = unsafe.Pointer(x.ref50ba8b60.pName)
	hxf058b18.Cap = 0x7fffffff
	// hxf058b18.Len = ? x.PName x.ref50ba8b60.pName

	packSSpecializationInfo(x.PSpecializationInfo, x.ref50ba8b60.pSpecializationInfo)
}

// allocComputePipelineCreateInfoMemory allocates memory for type C.VkComputePipelineCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocComputePipelineCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfComputePipelineCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfComputePipelineCreateInfoValue = unsafe.Sizeof([1]C.VkComputePipelineCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ComputePipelineCreateInfo) Ref() *C.VkComputePipelineCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref77823220
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ComputePipelineCreateInfo) Free() {
	if x != nil && x.allocs77823220 != nil {
		x.allocs77823220.(*cgoAllocMap).Free()
		x.ref77823220 = nil
	}
}

// NewComputePipelineCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewComputePipelineCreateInfoRef(ref unsafe.Pointer) *ComputePipelineCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(ComputePipelineCreateInfo)
	obj.ref77823220 = (*C.VkComputePipelineCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ComputePipelineCreateInfo) PassRef() (*C.VkComputePipelineCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref77823220 != nil {
		return x.ref77823220, nil
	}
	mem77823220 := allocComputePipelineCreateInfoMemory(1)
	ref77823220 := (*C.VkComputePipelineCreateInfo)(mem77823220)
	allocs77823220 := new(cgoAllocMap)
	allocs77823220.Add(mem77823220)

	ref77823220.sType = (C.VkStructureType)(x.SType)

	ref77823220.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref77823220.flags = (C.VkPipelineCreateFlags)(x.Flags)

	var cstage_allocs *cgoAllocMap
	ref77823220.stage, cstage_allocs = x.Stage.PassValue()
	allocs77823220.Borrow(cstage_allocs)

	ref77823220.layout = *(*C.VkPipelineLayout)(unsafe.Pointer(&x.Layout))

	ref77823220.basePipelineHandle = *(*C.VkPipeline)(unsafe.Pointer(&x.BasePipelineHandle))

	ref77823220.basePipelineIndex = (C.int32_t)(x.BasePipelineIndex)

	x.ref77823220 = ref77823220
	x.allocs77823220 = allocs77823220
	return ref77823220, allocs77823220

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ComputePipelineCreateInfo) PassValue() (C.VkComputePipelineCreateInfo, *cgoAllocMap) {
	if x.ref77823220 != nil {
		return *x.ref77823220, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ComputePipelineCreateInfo) Deref() {
	if x.ref77823220 == nil {
		return
	}
	x.SType = (StructureType)(x.ref77823220.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref77823220.pNext))
	x.Flags = (PipelineCreateFlags)(x.ref77823220.flags)
	x.Stage = *NewPipelineShaderStageCreateInfoRef(unsafe.Pointer(&x.ref77823220.stage))
	x.Layout = *(*PipelineLayout)(unsafe.Pointer(&x.ref77823220.layout))
	x.BasePipelineHandle = *(*Pipeline)(unsafe.Pointer(&x.ref77823220.basePipelineHandle))
	x.BasePipelineIndex = (int32)(x.ref77823220.basePipelineIndex)
}

// allocPipelineVertexInputStateCreateInfoMemory allocates memory for type C.VkPipelineVertexInputStateCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineVertexInputStateCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineVertexInputStateCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPipelineVertexInputStateCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineVertexInputStateCreateInfo{})

// copyPVertexInputBindingDescriptionBytes copies the data from Go slice as *C.VkVertexInputBindingDescription.
func copyPVertexInputBindingDescriptionBytes(slice *sliceHeader) (*C.VkVertexInputBindingDescription, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfVertexInputBindingDescriptionValue) * slice.Len,
		Cap:  int(sizeOfVertexInputBindingDescriptionValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkVertexInputBindingDescription)(mem0), allocs
}

// allocVertexInputBindingDescriptionMemory allocates memory for type C.VkVertexInputBindingDescription in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVertexInputBindingDescriptionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVertexInputBindingDescriptionValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfVertexInputBindingDescriptionValue = unsafe.Sizeof([1]C.VkVertexInputBindingDescription{})

// copyPVertexInputAttributeDescriptionBytes copies the data from Go slice as *C.VkVertexInputAttributeDescription.
func copyPVertexInputAttributeDescriptionBytes(slice *sliceHeader) (*C.VkVertexInputAttributeDescription, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfVertexInputAttributeDescriptionValue) * slice.Len,
		Cap:  int(sizeOfVertexInputAttributeDescriptionValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkVertexInputAttributeDescription)(mem0), allocs
}

// allocVertexInputAttributeDescriptionMemory allocates memory for type C.VkVertexInputAttributeDescription in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVertexInputAttributeDescriptionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVertexInputAttributeDescriptionValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfVertexInputAttributeDescriptionValue = unsafe.Sizeof([1]C.VkVertexInputAttributeDescription{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineVertexInputStateCreateInfo) Ref() *C.VkPipelineVertexInputStateCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref5fe4aa50
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineVertexInputStateCreateInfo) Free() {
	if x != nil && x.allocs5fe4aa50 != nil {
		x.allocs5fe4aa50.(*cgoAllocMap).Free()
		x.ref5fe4aa50 = nil
	}
}

// NewPipelineVertexInputStateCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineVertexInputStateCreateInfoRef(ref unsafe.Pointer) *PipelineVertexInputStateCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineVertexInputStateCreateInfo)
	obj.ref5fe4aa50 = (*C.VkPipelineVertexInputStateCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineVertexInputStateCreateInfo) PassRef() (*C.VkPipelineVertexInputStateCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5fe4aa50 != nil {
		return x.ref5fe4aa50, nil
	}
	mem5fe4aa50 := allocPipelineVertexInputStateCreateInfoMemory(1)
	ref5fe4aa50 := (*C.VkPipelineVertexInputStateCreateInfo)(mem5fe4aa50)
	allocs5fe4aa50 := new(cgoAllocMap)
	allocs5fe4aa50.Add(mem5fe4aa50)

	ref5fe4aa50.sType = (C.VkStructureType)(x.SType)

	ref5fe4aa50.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref5fe4aa50.flags = (C.VkPipelineVertexInputStateCreateFlags)(x.Flags)

	ref5fe4aa50.vertexBindingDescriptionCount = (C.uint32_t)(x.VertexBindingDescriptionCount)

	if x.PVertexBindingDescriptions != nil {
		var cpVertexBindingDescriptions_allocs *cgoAllocMap
		ref5fe4aa50.pVertexBindingDescriptions, cpVertexBindingDescriptions_allocs = copyPVertexInputBindingDescriptionBytes((*sliceHeader)(unsafe.Pointer(&x.PVertexBindingDescriptions)))
		allocs5fe4aa50.Borrow(cpVertexBindingDescriptions_allocs)
	}

	ref5fe4aa50.vertexAttributeDescriptionCount = (C.uint32_t)(x.VertexAttributeDescriptionCount)

	if x.PVertexAttributeDescriptions != nil {
		var cpVertexAttributeDescriptions_allocs *cgoAllocMap
		ref5fe4aa50.pVertexAttributeDescriptions, cpVertexAttributeDescriptions_allocs = copyPVertexInputAttributeDescriptionBytes((*sliceHeader)(unsafe.Pointer(&x.PVertexAttributeDescriptions)))
		allocs5fe4aa50.Borrow(cpVertexAttributeDescriptions_allocs)
	}

	x.ref5fe4aa50 = ref5fe4aa50
	x.allocs5fe4aa50 = allocs5fe4aa50
	return ref5fe4aa50, allocs5fe4aa50

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineVertexInputStateCreateInfo) PassValue() (C.VkPipelineVertexInputStateCreateInfo, *cgoAllocMap) {
	if x.ref5fe4aa50 != nil {
		return *x.ref5fe4aa50, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineVertexInputStateCreateInfo) Deref() {
	if x.ref5fe4aa50 == nil {
		return
	}
	x.SType = (StructureType)(x.ref5fe4aa50.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref5fe4aa50.pNext))
	x.Flags = (PipelineVertexInputStateCreateFlags)(x.ref5fe4aa50.flags)
	x.VertexBindingDescriptionCount = (uint32)(x.ref5fe4aa50.vertexBindingDescriptionCount)
	hxff6bc57 := (*sliceHeader)(unsafe.Pointer(&x.PVertexBindingDescriptions))
	hxff6bc57.Data = unsafe.Pointer(x.ref5fe4aa50.pVertexBindingDescriptions)
	hxff6bc57.Cap = 0x7fffffff
	// hxff6bc57.Len = ? x.PVertexBindingDescriptions x.ref5fe4aa50.pVertexBindingDescriptions

	x.VertexAttributeDescriptionCount = (uint32)(x.ref5fe4aa50.vertexAttributeDescriptionCount)
	hxf5fa529 := (*sliceHeader)(unsafe.Pointer(&x.PVertexAttributeDescriptions))
	hxf5fa529.Data = unsafe.Pointer(x.ref5fe4aa50.pVertexAttributeDescriptions)
	hxf5fa529.Cap = 0x7fffffff
	// hxf5fa529.Len = ? x.PVertexAttributeDescriptions x.ref5fe4aa50.pVertexAttributeDescriptions

}

// allocPipelineViewportStateCreateInfoMemory allocates memory for type C.VkPipelineViewportStateCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineViewportStateCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineViewportStateCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPipelineViewportStateCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineViewportStateCreateInfo{})

// copyPViewportBytes copies the data from Go slice as *C.VkViewport.
func copyPViewportBytes(slice *sliceHeader) (*C.VkViewport, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfViewportValue) * slice.Len,
		Cap:  int(sizeOfViewportValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkViewport)(mem0), allocs
}

// allocViewportMemory allocates memory for type C.VkViewport in C.
// The caller is responsible for freeing the this memory via C.free.
func allocViewportMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfViewportValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfViewportValue = unsafe.Sizeof([1]C.VkViewport{})

// copyPRect2DBytes copies the data from Go slice as *C.VkRect2D.
func copyPRect2DBytes(slice *sliceHeader) (*C.VkRect2D, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfRect2DValue) * slice.Len,
		Cap:  int(sizeOfRect2DValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkRect2D)(mem0), allocs
}

// allocRect2DMemory allocates memory for type C.VkRect2D in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRect2DMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRect2DValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfRect2DValue = unsafe.Sizeof([1]C.VkRect2D{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineViewportStateCreateInfo) Ref() *C.VkPipelineViewportStateCreateInfo {
	if x == nil {
		return nil
	}
	return x.refc4705791
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineViewportStateCreateInfo) Free() {
	if x != nil && x.allocsc4705791 != nil {
		x.allocsc4705791.(*cgoAllocMap).Free()
		x.refc4705791 = nil
	}
}

// NewPipelineViewportStateCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineViewportStateCreateInfoRef(ref unsafe.Pointer) *PipelineViewportStateCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineViewportStateCreateInfo)
	obj.refc4705791 = (*C.VkPipelineViewportStateCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineViewportStateCreateInfo) PassRef() (*C.VkPipelineViewportStateCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc4705791 != nil {
		return x.refc4705791, nil
	}
	memc4705791 := allocPipelineViewportStateCreateInfoMemory(1)
	refc4705791 := (*C.VkPipelineViewportStateCreateInfo)(memc4705791)
	allocsc4705791 := new(cgoAllocMap)
	allocsc4705791.Add(memc4705791)

	refc4705791.sType = (C.VkStructureType)(x.SType)

	refc4705791.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	refc4705791.flags = (C.VkPipelineViewportStateCreateFlags)(x.Flags)

	refc4705791.viewportCount = (C.uint32_t)(x.ViewportCount)

	if x.PViewports != nil {
		var cpViewports_allocs *cgoAllocMap
		refc4705791.pViewports, cpViewports_allocs = copyPViewportBytes((*sliceHeader)(unsafe.Pointer(&x.PViewports)))
		allocsc4705791.Borrow(cpViewports_allocs)
	}

	refc4705791.scissorCount = (C.uint32_t)(x.ScissorCount)

	if x.PScissors != nil {
		var cpScissors_allocs *cgoAllocMap
		refc4705791.pScissors, cpScissors_allocs = copyPRect2DBytes((*sliceHeader)(unsafe.Pointer(&x.PScissors)))
		allocsc4705791.Borrow(cpScissors_allocs)
	}

	x.refc4705791 = refc4705791
	x.allocsc4705791 = allocsc4705791
	return refc4705791, allocsc4705791

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineViewportStateCreateInfo) PassValue() (C.VkPipelineViewportStateCreateInfo, *cgoAllocMap) {
	if x.refc4705791 != nil {
		return *x.refc4705791, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineViewportStateCreateInfo) Deref() {
	if x.refc4705791 == nil {
		return
	}
	x.SType = (StructureType)(x.refc4705791.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refc4705791.pNext))
	x.Flags = (PipelineViewportStateCreateFlags)(x.refc4705791.flags)
	x.ViewportCount = (uint32)(x.refc4705791.viewportCount)
	hxf21690b := (*sliceHeader)(unsafe.Pointer(&x.PViewports))
	hxf21690b.Data = unsafe.Pointer(x.refc4705791.pViewports)
	hxf21690b.Cap = 0x7fffffff
	// hxf21690b.Len = ? x.PViewports x.refc4705791.pViewports

	x.ScissorCount = (uint32)(x.refc4705791.scissorCount)
	hxf1231c9 := (*sliceHeader)(unsafe.Pointer(&x.PScissors))
	hxf1231c9.Data = unsafe.Pointer(x.refc4705791.pScissors)
	hxf1231c9.Cap = 0x7fffffff
	// hxf1231c9.Len = ? x.PScissors x.refc4705791.pScissors

}

// allocPipelineMultisampleStateCreateInfoMemory allocates memory for type C.VkPipelineMultisampleStateCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineMultisampleStateCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineMultisampleStateCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPipelineMultisampleStateCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineMultisampleStateCreateInfo{})

// copyPSampleMaskBytes copies the data from Go slice as *C.VkSampleMask.
func copyPSampleMaskBytes(slice *sliceHeader) (*C.VkSampleMask, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfSampleMaskValue) * slice.Len,
		Cap:  int(sizeOfSampleMaskValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkSampleMask)(mem0), allocs
}

// allocSampleMaskMemory allocates memory for type C.VkSampleMask in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSampleMaskMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSampleMaskValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSampleMaskValue = unsafe.Sizeof([1]C.VkSampleMask{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineMultisampleStateCreateInfo) Ref() *C.VkPipelineMultisampleStateCreateInfo {
	if x == nil {
		return nil
	}
	return x.refb6538bfb
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineMultisampleStateCreateInfo) Free() {
	if x != nil && x.allocsb6538bfb != nil {
		x.allocsb6538bfb.(*cgoAllocMap).Free()
		x.refb6538bfb = nil
	}
}

// NewPipelineMultisampleStateCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineMultisampleStateCreateInfoRef(ref unsafe.Pointer) *PipelineMultisampleStateCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineMultisampleStateCreateInfo)
	obj.refb6538bfb = (*C.VkPipelineMultisampleStateCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineMultisampleStateCreateInfo) PassRef() (*C.VkPipelineMultisampleStateCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb6538bfb != nil {
		return x.refb6538bfb, nil
	}
	memb6538bfb := allocPipelineMultisampleStateCreateInfoMemory(1)
	refb6538bfb := (*C.VkPipelineMultisampleStateCreateInfo)(memb6538bfb)
	allocsb6538bfb := new(cgoAllocMap)
	allocsb6538bfb.Add(memb6538bfb)

	refb6538bfb.sType = (C.VkStructureType)(x.SType)

	refb6538bfb.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	refb6538bfb.flags = (C.VkPipelineMultisampleStateCreateFlags)(x.Flags)

	refb6538bfb.rasterizationSamples = (C.VkSampleCountFlagBits)(x.RasterizationSamples)

	refb6538bfb.sampleShadingEnable = (C.VkBool32)(x.SampleShadingEnable)

	refb6538bfb.minSampleShading = (C.float)(x.MinSampleShading)

	if x.PSampleMask != nil {
		var cpSampleMask_allocs *cgoAllocMap
		refb6538bfb.pSampleMask, cpSampleMask_allocs = copyPSampleMaskBytes((*sliceHeader)(unsafe.Pointer(&x.PSampleMask)))
		allocsb6538bfb.Borrow(cpSampleMask_allocs)
	}

	refb6538bfb.alphaToCoverageEnable = (C.VkBool32)(x.AlphaToCoverageEnable)

	refb6538bfb.alphaToOneEnable = (C.VkBool32)(x.AlphaToOneEnable)

	x.refb6538bfb = refb6538bfb
	x.allocsb6538bfb = allocsb6538bfb
	return refb6538bfb, allocsb6538bfb

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineMultisampleStateCreateInfo) PassValue() (C.VkPipelineMultisampleStateCreateInfo, *cgoAllocMap) {
	if x.refb6538bfb != nil {
		return *x.refb6538bfb, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineMultisampleStateCreateInfo) Deref() {
	if x.refb6538bfb == nil {
		return
	}
	x.SType = (StructureType)(x.refb6538bfb.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refb6538bfb.pNext))
	x.Flags = (PipelineMultisampleStateCreateFlags)(x.refb6538bfb.flags)
	x.RasterizationSamples = (SampleCountFlagBits)(x.refb6538bfb.rasterizationSamples)
	x.SampleShadingEnable = (Bool32)(x.refb6538bfb.sampleShadingEnable)
	x.MinSampleShading = (float32)(x.refb6538bfb.minSampleShading)
	hxf04b15b := (*sliceHeader)(unsafe.Pointer(&x.PSampleMask))
	hxf04b15b.Data = unsafe.Pointer(x.refb6538bfb.pSampleMask)
	hxf04b15b.Cap = 0x7fffffff
	// hxf04b15b.Len = ? x.PSampleMask x.refb6538bfb.pSampleMask

	x.AlphaToCoverageEnable = (Bool32)(x.refb6538bfb.alphaToCoverageEnable)
	x.AlphaToOneEnable = (Bool32)(x.refb6538bfb.alphaToOneEnable)
}

// allocPipelineColorBlendStateCreateInfoMemory allocates memory for type C.VkPipelineColorBlendStateCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineColorBlendStateCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineColorBlendStateCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPipelineColorBlendStateCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineColorBlendStateCreateInfo{})

// copyPPipelineColorBlendAttachmentStateBytes copies the data from Go slice as *C.VkPipelineColorBlendAttachmentState.
func copyPPipelineColorBlendAttachmentStateBytes(slice *sliceHeader) (*C.VkPipelineColorBlendAttachmentState, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfPipelineColorBlendAttachmentStateValue) * slice.Len,
		Cap:  int(sizeOfPipelineColorBlendAttachmentStateValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkPipelineColorBlendAttachmentState)(mem0), allocs
}

// allocPipelineColorBlendAttachmentStateMemory allocates memory for type C.VkPipelineColorBlendAttachmentState in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineColorBlendAttachmentStateMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineColorBlendAttachmentStateValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPipelineColorBlendAttachmentStateValue = unsafe.Sizeof([1]C.VkPipelineColorBlendAttachmentState{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineColorBlendStateCreateInfo) Ref() *C.VkPipelineColorBlendStateCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref2a9b490b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineColorBlendStateCreateInfo) Free() {
	if x != nil && x.allocs2a9b490b != nil {
		x.allocs2a9b490b.(*cgoAllocMap).Free()
		x.ref2a9b490b = nil
	}
}

// NewPipelineColorBlendStateCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineColorBlendStateCreateInfoRef(ref unsafe.Pointer) *PipelineColorBlendStateCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineColorBlendStateCreateInfo)
	obj.ref2a9b490b = (*C.VkPipelineColorBlendStateCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineColorBlendStateCreateInfo) PassRef() (*C.VkPipelineColorBlendStateCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2a9b490b != nil {
		return x.ref2a9b490b, nil
	}
	mem2a9b490b := allocPipelineColorBlendStateCreateInfoMemory(1)
	ref2a9b490b := (*C.VkPipelineColorBlendStateCreateInfo)(mem2a9b490b)
	allocs2a9b490b := new(cgoAllocMap)
	allocs2a9b490b.Add(mem2a9b490b)

	ref2a9b490b.sType = (C.VkStructureType)(x.SType)

	ref2a9b490b.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref2a9b490b.flags = (C.VkPipelineColorBlendStateCreateFlags)(x.Flags)

	ref2a9b490b.logicOpEnable = (C.VkBool32)(x.LogicOpEnable)

	ref2a9b490b.logicOp = (C.VkLogicOp)(x.LogicOp)

	ref2a9b490b.attachmentCount = (C.uint32_t)(x.AttachmentCount)

	if x.PAttachments != nil {
		var cpAttachments_allocs *cgoAllocMap
		ref2a9b490b.pAttachments, cpAttachments_allocs = copyPPipelineColorBlendAttachmentStateBytes((*sliceHeader)(unsafe.Pointer(&x.PAttachments)))
		allocs2a9b490b.Borrow(cpAttachments_allocs)
	}

	ref2a9b490b.blendConstants = *(*[4]C.float)(unsafe.Pointer(&x.BlendConstants))

	x.ref2a9b490b = ref2a9b490b
	x.allocs2a9b490b = allocs2a9b490b
	return ref2a9b490b, allocs2a9b490b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineColorBlendStateCreateInfo) PassValue() (C.VkPipelineColorBlendStateCreateInfo, *cgoAllocMap) {
	if x.ref2a9b490b != nil {
		return *x.ref2a9b490b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineColorBlendStateCreateInfo) Deref() {
	if x.ref2a9b490b == nil {
		return
	}
	x.SType = (StructureType)(x.ref2a9b490b.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref2a9b490b.pNext))
	x.Flags = (PipelineColorBlendStateCreateFlags)(x.ref2a9b490b.flags)
	x.LogicOpEnable = (Bool32)(x.ref2a9b490b.logicOpEnable)
	x.LogicOp = (LogicOp)(x.ref2a9b490b.logicOp)
	x.AttachmentCount = (uint32)(x.ref2a9b490b.attachmentCount)
	hxf2f888b := (*sliceHeader)(unsafe.Pointer(&x.PAttachments))
	hxf2f888b.Data = unsafe.Pointer(x.ref2a9b490b.pAttachments)
	hxf2f888b.Cap = 0x7fffffff
	// hxf2f888b.Len = ? x.PAttachments x.ref2a9b490b.pAttachments

	x.BlendConstants = *(*[4]float32)(unsafe.Pointer(&x.ref2a9b490b.blendConstants))
}

// allocPipelineDynamicStateCreateInfoMemory allocates memory for type C.VkPipelineDynamicStateCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineDynamicStateCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineDynamicStateCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPipelineDynamicStateCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineDynamicStateCreateInfo{})

// copyPDynamicStateBytes copies the data from Go slice as *C.VkDynamicState.
func copyPDynamicStateBytes(slice *sliceHeader) (*C.VkDynamicState, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfDynamicStateValue) * slice.Len,
		Cap:  int(sizeOfDynamicStateValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkDynamicState)(mem0), allocs
}

// allocDynamicStateMemory allocates memory for type C.VkDynamicState in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDynamicStateMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDynamicStateValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDynamicStateValue = unsafe.Sizeof([1]C.VkDynamicState{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineDynamicStateCreateInfo) Ref() *C.VkPipelineDynamicStateCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref246d7bc8
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineDynamicStateCreateInfo) Free() {
	if x != nil && x.allocs246d7bc8 != nil {
		x.allocs246d7bc8.(*cgoAllocMap).Free()
		x.ref246d7bc8 = nil
	}
}

// NewPipelineDynamicStateCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineDynamicStateCreateInfoRef(ref unsafe.Pointer) *PipelineDynamicStateCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineDynamicStateCreateInfo)
	obj.ref246d7bc8 = (*C.VkPipelineDynamicStateCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineDynamicStateCreateInfo) PassRef() (*C.VkPipelineDynamicStateCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref246d7bc8 != nil {
		return x.ref246d7bc8, nil
	}
	mem246d7bc8 := allocPipelineDynamicStateCreateInfoMemory(1)
	ref246d7bc8 := (*C.VkPipelineDynamicStateCreateInfo)(mem246d7bc8)
	allocs246d7bc8 := new(cgoAllocMap)
	allocs246d7bc8.Add(mem246d7bc8)

	ref246d7bc8.sType = (C.VkStructureType)(x.SType)

	ref246d7bc8.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref246d7bc8.flags = (C.VkPipelineDynamicStateCreateFlags)(x.Flags)

	ref246d7bc8.dynamicStateCount = (C.uint32_t)(x.DynamicStateCount)

	if x.PDynamicStates != nil {
		var cpDynamicStates_allocs *cgoAllocMap
		ref246d7bc8.pDynamicStates, cpDynamicStates_allocs = copyPDynamicStateBytes((*sliceHeader)(unsafe.Pointer(&x.PDynamicStates)))
		allocs246d7bc8.Borrow(cpDynamicStates_allocs)
	}

	x.ref246d7bc8 = ref246d7bc8
	x.allocs246d7bc8 = allocs246d7bc8
	return ref246d7bc8, allocs246d7bc8

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineDynamicStateCreateInfo) PassValue() (C.VkPipelineDynamicStateCreateInfo, *cgoAllocMap) {
	if x.ref246d7bc8 != nil {
		return *x.ref246d7bc8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineDynamicStateCreateInfo) Deref() {
	if x.ref246d7bc8 == nil {
		return
	}
	x.SType = (StructureType)(x.ref246d7bc8.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref246d7bc8.pNext))
	x.Flags = (PipelineDynamicStateCreateFlags)(x.ref246d7bc8.flags)
	x.DynamicStateCount = (uint32)(x.ref246d7bc8.dynamicStateCount)
	hxf5d1de2 := (*sliceHeader)(unsafe.Pointer(&x.PDynamicStates))
	hxf5d1de2.Data = unsafe.Pointer(x.ref246d7bc8.pDynamicStates)
	hxf5d1de2.Cap = 0x7fffffff
	// hxf5d1de2.Len = ? x.PDynamicStates x.ref246d7bc8.pDynamicStates

}

// allocGraphicsPipelineCreateInfoMemory allocates memory for type C.VkGraphicsPipelineCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocGraphicsPipelineCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfGraphicsPipelineCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfGraphicsPipelineCreateInfoValue = unsafe.Sizeof([1]C.VkGraphicsPipelineCreateInfo{})

// unpackSPipelineShaderStageCreateInfo transforms a sliced Go data structure into plain C format.
func unpackSPipelineShaderStageCreateInfo(x []PipelineShaderStageCreateInfo) (unpacked *C.VkPipelineShaderStageCreateInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPipelineShaderStageCreateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkPipelineShaderStageCreateInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkPipelineShaderStageCreateInfo)(h.Data)
	return
}

// packSPipelineShaderStageCreateInfo reads sliced Go data structure out from plain C format.
func packSPipelineShaderStageCreateInfo(v []PipelineShaderStageCreateInfo, ptr0 *C.VkPipelineShaderStageCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPipelineShaderStageCreateInfoValue]C.VkPipelineShaderStageCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPipelineShaderStageCreateInfoRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *GraphicsPipelineCreateInfo) Ref() *C.VkGraphicsPipelineCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref178f88b6
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *GraphicsPipelineCreateInfo) Free() {
	if x != nil && x.allocs178f88b6 != nil {
		x.allocs178f88b6.(*cgoAllocMap).Free()
		x.ref178f88b6 = nil
	}
}

// NewGraphicsPipelineCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewGraphicsPipelineCreateInfoRef(ref unsafe.Pointer) *GraphicsPipelineCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(GraphicsPipelineCreateInfo)
	obj.ref178f88b6 = (*C.VkGraphicsPipelineCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *GraphicsPipelineCreateInfo) PassRef() (*C.VkGraphicsPipelineCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref178f88b6 != nil {
		return x.ref178f88b6, nil
	}
	mem178f88b6 := allocGraphicsPipelineCreateInfoMemory(1)
	ref178f88b6 := (*C.VkGraphicsPipelineCreateInfo)(mem178f88b6)
	allocs178f88b6 := new(cgoAllocMap)
	allocs178f88b6.Add(mem178f88b6)

	ref178f88b6.sType = (C.VkStructureType)(x.SType)

	ref178f88b6.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref178f88b6.flags = (C.VkPipelineCreateFlags)(x.Flags)

	ref178f88b6.stageCount = (C.uint32_t)(x.StageCount)

	var cpStages_allocs *cgoAllocMap
	ref178f88b6.pStages, cpStages_allocs = unpackSPipelineShaderStageCreateInfo(x.PStages)
	allocs178f88b6.Borrow(cpStages_allocs)

	var cpVertexInputState_allocs *cgoAllocMap
	ref178f88b6.pVertexInputState, cpVertexInputState_allocs = x.PVertexInputState.PassRef()
	allocs178f88b6.Borrow(cpVertexInputState_allocs)

	ref178f88b6.pInputAssemblyState = *(**C.VkPipelineInputAssemblyStateCreateInfo)(unsafe.Pointer(&x.PInputAssemblyState))

	ref178f88b6.pTessellationState = *(**C.VkPipelineTessellationStateCreateInfo)(unsafe.Pointer(&x.PTessellationState))

	var cpViewportState_allocs *cgoAllocMap
	ref178f88b6.pViewportState, cpViewportState_allocs = x.PViewportState.PassRef()
	allocs178f88b6.Borrow(cpViewportState_allocs)

	ref178f88b6.pRasterizationState = *(**C.VkPipelineRasterizationStateCreateInfo)(unsafe.Pointer(&x.PRasterizationState))

	var cpMultisampleState_allocs *cgoAllocMap
	ref178f88b6.pMultisampleState, cpMultisampleState_allocs = x.PMultisampleState.PassRef()
	allocs178f88b6.Borrow(cpMultisampleState_allocs)

	ref178f88b6.pDepthStencilState = *(**C.VkPipelineDepthStencilStateCreateInfo)(unsafe.Pointer(&x.PDepthStencilState))

	var cpColorBlendState_allocs *cgoAllocMap
	ref178f88b6.pColorBlendState, cpColorBlendState_allocs = x.PColorBlendState.PassRef()
	allocs178f88b6.Borrow(cpColorBlendState_allocs)

	var cpDynamicState_allocs *cgoAllocMap
	ref178f88b6.pDynamicState, cpDynamicState_allocs = x.PDynamicState.PassRef()
	allocs178f88b6.Borrow(cpDynamicState_allocs)

	ref178f88b6.layout = *(*C.VkPipelineLayout)(unsafe.Pointer(&x.Layout))

	ref178f88b6.renderPass = *(*C.VkRenderPass)(unsafe.Pointer(&x.RenderPass))

	ref178f88b6.subpass = (C.uint32_t)(x.Subpass)

	ref178f88b6.basePipelineHandle = *(*C.VkPipeline)(unsafe.Pointer(&x.BasePipelineHandle))

	ref178f88b6.basePipelineIndex = (C.int32_t)(x.BasePipelineIndex)

	x.ref178f88b6 = ref178f88b6
	x.allocs178f88b6 = allocs178f88b6
	return ref178f88b6, allocs178f88b6

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x GraphicsPipelineCreateInfo) PassValue() (C.VkGraphicsPipelineCreateInfo, *cgoAllocMap) {
	if x.ref178f88b6 != nil {
		return *x.ref178f88b6, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *GraphicsPipelineCreateInfo) Deref() {
	if x.ref178f88b6 == nil {
		return
	}
	x.SType = (StructureType)(x.ref178f88b6.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref178f88b6.pNext))
	x.Flags = (PipelineCreateFlags)(x.ref178f88b6.flags)
	x.StageCount = (uint32)(x.ref178f88b6.stageCount)
	packSPipelineShaderStageCreateInfo(x.PStages, x.ref178f88b6.pStages)
	x.PVertexInputState = NewPipelineVertexInputStateCreateInfoRef(unsafe.Pointer(x.ref178f88b6.pVertexInputState))
	x.PInputAssemblyState = (*PipelineInputAssemblyStateCreateInfo)(unsafe.Pointer(x.ref178f88b6.pInputAssemblyState))
	x.PTessellationState = (*PipelineTessellationStateCreateInfo)(unsafe.Pointer(x.ref178f88b6.pTessellationState))
	x.PViewportState = NewPipelineViewportStateCreateInfoRef(unsafe.Pointer(x.ref178f88b6.pViewportState))
	x.PRasterizationState = (*PipelineRasterizationStateCreateInfo)(unsafe.Pointer(x.ref178f88b6.pRasterizationState))
	x.PMultisampleState = NewPipelineMultisampleStateCreateInfoRef(unsafe.Pointer(x.ref178f88b6.pMultisampleState))
	x.PDepthStencilState = (*PipelineDepthStencilStateCreateInfo)(unsafe.Pointer(x.ref178f88b6.pDepthStencilState))
	x.PColorBlendState = NewPipelineColorBlendStateCreateInfoRef(unsafe.Pointer(x.ref178f88b6.pColorBlendState))
	x.PDynamicState = NewPipelineDynamicStateCreateInfoRef(unsafe.Pointer(x.ref178f88b6.pDynamicState))
	x.Layout = *(*PipelineLayout)(unsafe.Pointer(&x.ref178f88b6.layout))
	x.RenderPass = *(*RenderPass)(unsafe.Pointer(&x.ref178f88b6.renderPass))
	x.Subpass = (uint32)(x.ref178f88b6.subpass)
	x.BasePipelineHandle = *(*Pipeline)(unsafe.Pointer(&x.ref178f88b6.basePipelineHandle))
	x.BasePipelineIndex = (int32)(x.ref178f88b6.basePipelineIndex)
}

// allocPipelineLayoutCreateInfoMemory allocates memory for type C.VkPipelineLayoutCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineLayoutCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineLayoutCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPipelineLayoutCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineLayoutCreateInfo{})

// copyPDescriptorSetLayoutBytes copies the data from Go slice as *C.VkDescriptorSetLayout.
func copyPDescriptorSetLayoutBytes(slice *sliceHeader) (*C.VkDescriptorSetLayout, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfDescriptorSetLayoutValue) * slice.Len,
		Cap:  int(sizeOfDescriptorSetLayoutValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkDescriptorSetLayout)(mem0), allocs
}

// allocDescriptorSetLayoutMemory allocates memory for type C.VkDescriptorSetLayout in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDescriptorSetLayoutMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDescriptorSetLayoutValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDescriptorSetLayoutValue = unsafe.Sizeof([1]C.VkDescriptorSetLayout{})

// copyPPushConstantRangeBytes copies the data from Go slice as *C.VkPushConstantRange.
func copyPPushConstantRangeBytes(slice *sliceHeader) (*C.VkPushConstantRange, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfPushConstantRangeValue) * slice.Len,
		Cap:  int(sizeOfPushConstantRangeValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkPushConstantRange)(mem0), allocs
}

// allocPushConstantRangeMemory allocates memory for type C.VkPushConstantRange in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPushConstantRangeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPushConstantRangeValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPushConstantRangeValue = unsafe.Sizeof([1]C.VkPushConstantRange{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineLayoutCreateInfo) Ref() *C.VkPipelineLayoutCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref64cc4eed
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineLayoutCreateInfo) Free() {
	if x != nil && x.allocs64cc4eed != nil {
		x.allocs64cc4eed.(*cgoAllocMap).Free()
		x.ref64cc4eed = nil
	}
}

// NewPipelineLayoutCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineLayoutCreateInfoRef(ref unsafe.Pointer) *PipelineLayoutCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineLayoutCreateInfo)
	obj.ref64cc4eed = (*C.VkPipelineLayoutCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineLayoutCreateInfo) PassRef() (*C.VkPipelineLayoutCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref64cc4eed != nil {
		return x.ref64cc4eed, nil
	}
	mem64cc4eed := allocPipelineLayoutCreateInfoMemory(1)
	ref64cc4eed := (*C.VkPipelineLayoutCreateInfo)(mem64cc4eed)
	allocs64cc4eed := new(cgoAllocMap)
	allocs64cc4eed.Add(mem64cc4eed)

	ref64cc4eed.sType = (C.VkStructureType)(x.SType)

	ref64cc4eed.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref64cc4eed.flags = (C.VkPipelineLayoutCreateFlags)(x.Flags)

	ref64cc4eed.setLayoutCount = (C.uint32_t)(x.SetLayoutCount)

	if x.PSetLayouts != nil {
		var cpSetLayouts_allocs *cgoAllocMap
		ref64cc4eed.pSetLayouts, cpSetLayouts_allocs = copyPDescriptorSetLayoutBytes((*sliceHeader)(unsafe.Pointer(&x.PSetLayouts)))
		allocs64cc4eed.Borrow(cpSetLayouts_allocs)
	}

	ref64cc4eed.pushConstantRangeCount = (C.uint32_t)(x.PushConstantRangeCount)

	if x.PPushConstantRanges != nil {
		var cpPushConstantRanges_allocs *cgoAllocMap
		ref64cc4eed.pPushConstantRanges, cpPushConstantRanges_allocs = copyPPushConstantRangeBytes((*sliceHeader)(unsafe.Pointer(&x.PPushConstantRanges)))
		allocs64cc4eed.Borrow(cpPushConstantRanges_allocs)
	}

	x.ref64cc4eed = ref64cc4eed
	x.allocs64cc4eed = allocs64cc4eed
	return ref64cc4eed, allocs64cc4eed

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineLayoutCreateInfo) PassValue() (C.VkPipelineLayoutCreateInfo, *cgoAllocMap) {
	if x.ref64cc4eed != nil {
		return *x.ref64cc4eed, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineLayoutCreateInfo) Deref() {
	if x.ref64cc4eed == nil {
		return
	}
	x.SType = (StructureType)(x.ref64cc4eed.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref64cc4eed.pNext))
	x.Flags = (PipelineLayoutCreateFlags)(x.ref64cc4eed.flags)
	x.SetLayoutCount = (uint32)(x.ref64cc4eed.setLayoutCount)
	hxfe53d34 := (*sliceHeader)(unsafe.Pointer(&x.PSetLayouts))
	hxfe53d34.Data = unsafe.Pointer(x.ref64cc4eed.pSetLayouts)
	hxfe53d34.Cap = 0x7fffffff
	// hxfe53d34.Len = ? x.PSetLayouts x.ref64cc4eed.pSetLayouts

	x.PushConstantRangeCount = (uint32)(x.ref64cc4eed.pushConstantRangeCount)
	hxf547023 := (*sliceHeader)(unsafe.Pointer(&x.PPushConstantRanges))
	hxf547023.Data = unsafe.Pointer(x.ref64cc4eed.pPushConstantRanges)
	hxf547023.Cap = 0x7fffffff
	// hxf547023.Len = ? x.PPushConstantRanges x.ref64cc4eed.pPushConstantRanges

}

// allocCopyDescriptorSetMemory allocates memory for type C.VkCopyDescriptorSet in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCopyDescriptorSetMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCopyDescriptorSetValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCopyDescriptorSetValue = unsafe.Sizeof([1]C.VkCopyDescriptorSet{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CopyDescriptorSet) Ref() *C.VkCopyDescriptorSet {
	if x == nil {
		return nil
	}
	return x.reffe237a3a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CopyDescriptorSet) Free() {
	if x != nil && x.allocsfe237a3a != nil {
		x.allocsfe237a3a.(*cgoAllocMap).Free()
		x.reffe237a3a = nil
	}
}

// NewCopyDescriptorSetRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCopyDescriptorSetRef(ref unsafe.Pointer) *CopyDescriptorSet {
	if ref == nil {
		return nil
	}
	obj := new(CopyDescriptorSet)
	obj.reffe237a3a = (*C.VkCopyDescriptorSet)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CopyDescriptorSet) PassRef() (*C.VkCopyDescriptorSet, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reffe237a3a != nil {
		return x.reffe237a3a, nil
	}
	memfe237a3a := allocCopyDescriptorSetMemory(1)
	reffe237a3a := (*C.VkCopyDescriptorSet)(memfe237a3a)
	allocsfe237a3a := new(cgoAllocMap)
	allocsfe237a3a.Add(memfe237a3a)

	reffe237a3a.sType = (C.VkStructureType)(x.SType)

	reffe237a3a.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	reffe237a3a.srcSet = *(*C.VkDescriptorSet)(unsafe.Pointer(&x.SrcSet))

	reffe237a3a.srcBinding = (C.uint32_t)(x.SrcBinding)

	reffe237a3a.srcArrayElement = (C.uint32_t)(x.SrcArrayElement)

	reffe237a3a.dstSet = *(*C.VkDescriptorSet)(unsafe.Pointer(&x.DstSet))

	reffe237a3a.dstBinding = (C.uint32_t)(x.DstBinding)

	reffe237a3a.dstArrayElement = (C.uint32_t)(x.DstArrayElement)

	reffe237a3a.descriptorCount = (C.uint32_t)(x.DescriptorCount)

	x.reffe237a3a = reffe237a3a
	x.allocsfe237a3a = allocsfe237a3a
	return reffe237a3a, allocsfe237a3a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CopyDescriptorSet) PassValue() (C.VkCopyDescriptorSet, *cgoAllocMap) {
	if x.reffe237a3a != nil {
		return *x.reffe237a3a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CopyDescriptorSet) Deref() {
	if x.reffe237a3a == nil {
		return
	}
	x.SType = (StructureType)(x.reffe237a3a.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.reffe237a3a.pNext))
	x.SrcSet = *(*DescriptorSet)(unsafe.Pointer(&x.reffe237a3a.srcSet))
	x.SrcBinding = (uint32)(x.reffe237a3a.srcBinding)
	x.SrcArrayElement = (uint32)(x.reffe237a3a.srcArrayElement)
	x.DstSet = *(*DescriptorSet)(unsafe.Pointer(&x.reffe237a3a.dstSet))
	x.DstBinding = (uint32)(x.reffe237a3a.dstBinding)
	x.DstArrayElement = (uint32)(x.reffe237a3a.dstArrayElement)
	x.DescriptorCount = (uint32)(x.reffe237a3a.descriptorCount)
}

// allocDescriptorBufferInfoMemory allocates memory for type C.VkDescriptorBufferInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDescriptorBufferInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDescriptorBufferInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDescriptorBufferInfoValue = unsafe.Sizeof([1]C.VkDescriptorBufferInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DescriptorBufferInfo) Ref() *C.VkDescriptorBufferInfo {
	if x == nil {
		return nil
	}
	return x.refe64bec0e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DescriptorBufferInfo) Free() {
	if x != nil && x.allocse64bec0e != nil {
		x.allocse64bec0e.(*cgoAllocMap).Free()
		x.refe64bec0e = nil
	}
}

// NewDescriptorBufferInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDescriptorBufferInfoRef(ref unsafe.Pointer) *DescriptorBufferInfo {
	if ref == nil {
		return nil
	}
	obj := new(DescriptorBufferInfo)
	obj.refe64bec0e = (*C.VkDescriptorBufferInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DescriptorBufferInfo) PassRef() (*C.VkDescriptorBufferInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe64bec0e != nil {
		return x.refe64bec0e, nil
	}
	meme64bec0e := allocDescriptorBufferInfoMemory(1)
	refe64bec0e := (*C.VkDescriptorBufferInfo)(meme64bec0e)
	allocse64bec0e := new(cgoAllocMap)
	allocse64bec0e.Add(meme64bec0e)

	refe64bec0e.buffer = *(*C.VkBuffer)(unsafe.Pointer(&x.Buffer))

	refe64bec0e.offset = (C.VkDeviceSize)(x.Offset)

	refe64bec0e._range = (C.VkDeviceSize)(x.Range)

	x.refe64bec0e = refe64bec0e
	x.allocse64bec0e = allocse64bec0e
	return refe64bec0e, allocse64bec0e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DescriptorBufferInfo) PassValue() (C.VkDescriptorBufferInfo, *cgoAllocMap) {
	if x.refe64bec0e != nil {
		return *x.refe64bec0e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DescriptorBufferInfo) Deref() {
	if x.refe64bec0e == nil {
		return
	}
	x.Buffer = *(*Buffer)(unsafe.Pointer(&x.refe64bec0e.buffer))
	x.Offset = (DeviceSize)(x.refe64bec0e.offset)
	x.Range = (DeviceSize)(x.refe64bec0e._range)
}

// allocDescriptorImageInfoMemory allocates memory for type C.VkDescriptorImageInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDescriptorImageInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDescriptorImageInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDescriptorImageInfoValue = unsafe.Sizeof([1]C.VkDescriptorImageInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DescriptorImageInfo) Ref() *C.VkDescriptorImageInfo {
	if x == nil {
		return nil
	}
	return x.refaf073b07
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DescriptorImageInfo) Free() {
	if x != nil && x.allocsaf073b07 != nil {
		x.allocsaf073b07.(*cgoAllocMap).Free()
		x.refaf073b07 = nil
	}
}

// NewDescriptorImageInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDescriptorImageInfoRef(ref unsafe.Pointer) *DescriptorImageInfo {
	if ref == nil {
		return nil
	}
	obj := new(DescriptorImageInfo)
	obj.refaf073b07 = (*C.VkDescriptorImageInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DescriptorImageInfo) PassRef() (*C.VkDescriptorImageInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refaf073b07 != nil {
		return x.refaf073b07, nil
	}
	memaf073b07 := allocDescriptorImageInfoMemory(1)
	refaf073b07 := (*C.VkDescriptorImageInfo)(memaf073b07)
	allocsaf073b07 := new(cgoAllocMap)
	allocsaf073b07.Add(memaf073b07)

	refaf073b07.sampler = *(*C.VkSampler)(unsafe.Pointer(&x.Sampler))

	refaf073b07.imageView = *(*C.VkImageView)(unsafe.Pointer(&x.ImageView))

	refaf073b07.imageLayout = (C.VkImageLayout)(x.ImageLayout)

	x.refaf073b07 = refaf073b07
	x.allocsaf073b07 = allocsaf073b07
	return refaf073b07, allocsaf073b07

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DescriptorImageInfo) PassValue() (C.VkDescriptorImageInfo, *cgoAllocMap) {
	if x.refaf073b07 != nil {
		return *x.refaf073b07, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DescriptorImageInfo) Deref() {
	if x.refaf073b07 == nil {
		return
	}
	x.Sampler = *(*Sampler)(unsafe.Pointer(&x.refaf073b07.sampler))
	x.ImageView = *(*ImageView)(unsafe.Pointer(&x.refaf073b07.imageView))
	x.ImageLayout = (ImageLayout)(x.refaf073b07.imageLayout)
}

// allocDescriptorPoolCreateInfoMemory allocates memory for type C.VkDescriptorPoolCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDescriptorPoolCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDescriptorPoolCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDescriptorPoolCreateInfoValue = unsafe.Sizeof([1]C.VkDescriptorPoolCreateInfo{})

// copyPDescriptorPoolSizeBytes copies the data from Go slice as *C.VkDescriptorPoolSize.
func copyPDescriptorPoolSizeBytes(slice *sliceHeader) (*C.VkDescriptorPoolSize, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfDescriptorPoolSizeValue) * slice.Len,
		Cap:  int(sizeOfDescriptorPoolSizeValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkDescriptorPoolSize)(mem0), allocs
}

// allocDescriptorPoolSizeMemory allocates memory for type C.VkDescriptorPoolSize in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDescriptorPoolSizeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDescriptorPoolSizeValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDescriptorPoolSizeValue = unsafe.Sizeof([1]C.VkDescriptorPoolSize{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DescriptorPoolCreateInfo) Ref() *C.VkDescriptorPoolCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref19868463
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DescriptorPoolCreateInfo) Free() {
	if x != nil && x.allocs19868463 != nil {
		x.allocs19868463.(*cgoAllocMap).Free()
		x.ref19868463 = nil
	}
}

// NewDescriptorPoolCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDescriptorPoolCreateInfoRef(ref unsafe.Pointer) *DescriptorPoolCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(DescriptorPoolCreateInfo)
	obj.ref19868463 = (*C.VkDescriptorPoolCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DescriptorPoolCreateInfo) PassRef() (*C.VkDescriptorPoolCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref19868463 != nil {
		return x.ref19868463, nil
	}
	mem19868463 := allocDescriptorPoolCreateInfoMemory(1)
	ref19868463 := (*C.VkDescriptorPoolCreateInfo)(mem19868463)
	allocs19868463 := new(cgoAllocMap)
	allocs19868463.Add(mem19868463)

	ref19868463.sType = (C.VkStructureType)(x.SType)

	ref19868463.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref19868463.flags = (C.VkDescriptorPoolCreateFlags)(x.Flags)

	ref19868463.maxSets = (C.uint32_t)(x.MaxSets)

	ref19868463.poolSizeCount = (C.uint32_t)(x.PoolSizeCount)

	if x.PPoolSizes != nil {
		var cpPoolSizes_allocs *cgoAllocMap
		ref19868463.pPoolSizes, cpPoolSizes_allocs = copyPDescriptorPoolSizeBytes((*sliceHeader)(unsafe.Pointer(&x.PPoolSizes)))
		allocs19868463.Borrow(cpPoolSizes_allocs)
	}

	x.ref19868463 = ref19868463
	x.allocs19868463 = allocs19868463
	return ref19868463, allocs19868463

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DescriptorPoolCreateInfo) PassValue() (C.VkDescriptorPoolCreateInfo, *cgoAllocMap) {
	if x.ref19868463 != nil {
		return *x.ref19868463, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DescriptorPoolCreateInfo) Deref() {
	if x.ref19868463 == nil {
		return
	}
	x.SType = (StructureType)(x.ref19868463.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref19868463.pNext))
	x.Flags = (DescriptorPoolCreateFlags)(x.ref19868463.flags)
	x.MaxSets = (uint32)(x.ref19868463.maxSets)
	x.PoolSizeCount = (uint32)(x.ref19868463.poolSizeCount)
	hxf5ebb88 := (*sliceHeader)(unsafe.Pointer(&x.PPoolSizes))
	hxf5ebb88.Data = unsafe.Pointer(x.ref19868463.pPoolSizes)
	hxf5ebb88.Cap = 0x7fffffff
	// hxf5ebb88.Len = ? x.PPoolSizes x.ref19868463.pPoolSizes

}

// allocDescriptorSetAllocateInfoMemory allocates memory for type C.VkDescriptorSetAllocateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDescriptorSetAllocateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDescriptorSetAllocateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDescriptorSetAllocateInfoValue = unsafe.Sizeof([1]C.VkDescriptorSetAllocateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DescriptorSetAllocateInfo) Ref() *C.VkDescriptorSetAllocateInfo {
	if x == nil {
		return nil
	}
	return x.ref2dd6cc22
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DescriptorSetAllocateInfo) Free() {
	if x != nil && x.allocs2dd6cc22 != nil {
		x.allocs2dd6cc22.(*cgoAllocMap).Free()
		x.ref2dd6cc22 = nil
	}
}

// NewDescriptorSetAllocateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDescriptorSetAllocateInfoRef(ref unsafe.Pointer) *DescriptorSetAllocateInfo {
	if ref == nil {
		return nil
	}
	obj := new(DescriptorSetAllocateInfo)
	obj.ref2dd6cc22 = (*C.VkDescriptorSetAllocateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DescriptorSetAllocateInfo) PassRef() (*C.VkDescriptorSetAllocateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2dd6cc22 != nil {
		return x.ref2dd6cc22, nil
	}
	mem2dd6cc22 := allocDescriptorSetAllocateInfoMemory(1)
	ref2dd6cc22 := (*C.VkDescriptorSetAllocateInfo)(mem2dd6cc22)
	allocs2dd6cc22 := new(cgoAllocMap)
	allocs2dd6cc22.Add(mem2dd6cc22)

	ref2dd6cc22.sType = (C.VkStructureType)(x.SType)

	ref2dd6cc22.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref2dd6cc22.descriptorPool = *(*C.VkDescriptorPool)(unsafe.Pointer(&x.DescriptorPool))

	ref2dd6cc22.descriptorSetCount = (C.uint32_t)(x.DescriptorSetCount)

	if x.PSetLayouts != nil {
		var cpSetLayouts_allocs *cgoAllocMap
		ref2dd6cc22.pSetLayouts, cpSetLayouts_allocs = copyPDescriptorSetLayoutBytes((*sliceHeader)(unsafe.Pointer(&x.PSetLayouts)))
		allocs2dd6cc22.Borrow(cpSetLayouts_allocs)
	}

	x.ref2dd6cc22 = ref2dd6cc22
	x.allocs2dd6cc22 = allocs2dd6cc22
	return ref2dd6cc22, allocs2dd6cc22

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DescriptorSetAllocateInfo) PassValue() (C.VkDescriptorSetAllocateInfo, *cgoAllocMap) {
	if x.ref2dd6cc22 != nil {
		return *x.ref2dd6cc22, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DescriptorSetAllocateInfo) Deref() {
	if x.ref2dd6cc22 == nil {
		return
	}
	x.SType = (StructureType)(x.ref2dd6cc22.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref2dd6cc22.pNext))
	x.DescriptorPool = *(*DescriptorPool)(unsafe.Pointer(&x.ref2dd6cc22.descriptorPool))
	x.DescriptorSetCount = (uint32)(x.ref2dd6cc22.descriptorSetCount)
	hxff20e84 := (*sliceHeader)(unsafe.Pointer(&x.PSetLayouts))
	hxff20e84.Data = unsafe.Pointer(x.ref2dd6cc22.pSetLayouts)
	hxff20e84.Cap = 0x7fffffff
	// hxff20e84.Len = ? x.PSetLayouts x.ref2dd6cc22.pSetLayouts

}

// allocDescriptorSetLayoutBindingMemory allocates memory for type C.VkDescriptorSetLayoutBinding in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDescriptorSetLayoutBindingMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDescriptorSetLayoutBindingValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDescriptorSetLayoutBindingValue = unsafe.Sizeof([1]C.VkDescriptorSetLayoutBinding{})

// copyPSamplerBytes copies the data from Go slice as *C.VkSampler.
func copyPSamplerBytes(slice *sliceHeader) (*C.VkSampler, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfSamplerValue) * slice.Len,
		Cap:  int(sizeOfSamplerValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkSampler)(mem0), allocs
}

// allocSamplerMemory allocates memory for type C.VkSampler in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSamplerMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSamplerValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSamplerValue = unsafe.Sizeof([1]C.VkSampler{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DescriptorSetLayoutBinding) Ref() *C.VkDescriptorSetLayoutBinding {
	if x == nil {
		return nil
	}
	return x.ref8b50b4ec
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DescriptorSetLayoutBinding) Free() {
	if x != nil && x.allocs8b50b4ec != nil {
		x.allocs8b50b4ec.(*cgoAllocMap).Free()
		x.ref8b50b4ec = nil
	}
}

// NewDescriptorSetLayoutBindingRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDescriptorSetLayoutBindingRef(ref unsafe.Pointer) *DescriptorSetLayoutBinding {
	if ref == nil {
		return nil
	}
	obj := new(DescriptorSetLayoutBinding)
	obj.ref8b50b4ec = (*C.VkDescriptorSetLayoutBinding)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DescriptorSetLayoutBinding) PassRef() (*C.VkDescriptorSetLayoutBinding, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref8b50b4ec != nil {
		return x.ref8b50b4ec, nil
	}
	mem8b50b4ec := allocDescriptorSetLayoutBindingMemory(1)
	ref8b50b4ec := (*C.VkDescriptorSetLayoutBinding)(mem8b50b4ec)
	allocs8b50b4ec := new(cgoAllocMap)
	allocs8b50b4ec.Add(mem8b50b4ec)

	ref8b50b4ec.binding = (C.uint32_t)(x.Binding)

	ref8b50b4ec.descriptorType = (C.VkDescriptorType)(x.DescriptorType)

	ref8b50b4ec.descriptorCount = (C.uint32_t)(x.DescriptorCount)

	ref8b50b4ec.stageFlags = (C.VkShaderStageFlags)(x.StageFlags)

	if x.PImmutableSamplers != nil {
		var cpImmutableSamplers_allocs *cgoAllocMap
		ref8b50b4ec.pImmutableSamplers, cpImmutableSamplers_allocs = copyPSamplerBytes((*sliceHeader)(unsafe.Pointer(&x.PImmutableSamplers)))
		allocs8b50b4ec.Borrow(cpImmutableSamplers_allocs)
	}

	x.ref8b50b4ec = ref8b50b4ec
	x.allocs8b50b4ec = allocs8b50b4ec
	return ref8b50b4ec, allocs8b50b4ec

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DescriptorSetLayoutBinding) PassValue() (C.VkDescriptorSetLayoutBinding, *cgoAllocMap) {
	if x.ref8b50b4ec != nil {
		return *x.ref8b50b4ec, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DescriptorSetLayoutBinding) Deref() {
	if x.ref8b50b4ec == nil {
		return
	}
	x.Binding = (uint32)(x.ref8b50b4ec.binding)
	x.DescriptorType = (DescriptorType)(x.ref8b50b4ec.descriptorType)
	x.DescriptorCount = (uint32)(x.ref8b50b4ec.descriptorCount)
	x.StageFlags = (ShaderStageFlags)(x.ref8b50b4ec.stageFlags)
	hxfa26a4d := (*sliceHeader)(unsafe.Pointer(&x.PImmutableSamplers))
	hxfa26a4d.Data = unsafe.Pointer(x.ref8b50b4ec.pImmutableSamplers)
	hxfa26a4d.Cap = 0x7fffffff
	// hxfa26a4d.Len = ? x.PImmutableSamplers x.ref8b50b4ec.pImmutableSamplers

}

// allocDescriptorSetLayoutCreateInfoMemory allocates memory for type C.VkDescriptorSetLayoutCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDescriptorSetLayoutCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDescriptorSetLayoutCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDescriptorSetLayoutCreateInfoValue = unsafe.Sizeof([1]C.VkDescriptorSetLayoutCreateInfo{})

// unpackSDescriptorSetLayoutBinding transforms a sliced Go data structure into plain C format.
func unpackSDescriptorSetLayoutBinding(x []DescriptorSetLayoutBinding) (unpacked *C.VkDescriptorSetLayoutBinding, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocDescriptorSetLayoutBindingMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkDescriptorSetLayoutBinding)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkDescriptorSetLayoutBinding)(h.Data)
	return
}

// packSDescriptorSetLayoutBinding reads sliced Go data structure out from plain C format.
func packSDescriptorSetLayoutBinding(v []DescriptorSetLayoutBinding, ptr0 *C.VkDescriptorSetLayoutBinding) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDescriptorSetLayoutBindingValue]C.VkDescriptorSetLayoutBinding)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDescriptorSetLayoutBindingRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DescriptorSetLayoutCreateInfo) Ref() *C.VkDescriptorSetLayoutCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref5ee8e0ed
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DescriptorSetLayoutCreateInfo) Free() {
	if x != nil && x.allocs5ee8e0ed != nil {
		x.allocs5ee8e0ed.(*cgoAllocMap).Free()
		x.ref5ee8e0ed = nil
	}
}

// NewDescriptorSetLayoutCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDescriptorSetLayoutCreateInfoRef(ref unsafe.Pointer) *DescriptorSetLayoutCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(DescriptorSetLayoutCreateInfo)
	obj.ref5ee8e0ed = (*C.VkDescriptorSetLayoutCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DescriptorSetLayoutCreateInfo) PassRef() (*C.VkDescriptorSetLayoutCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5ee8e0ed != nil {
		return x.ref5ee8e0ed, nil
	}
	mem5ee8e0ed := allocDescriptorSetLayoutCreateInfoMemory(1)
	ref5ee8e0ed := (*C.VkDescriptorSetLayoutCreateInfo)(mem5ee8e0ed)
	allocs5ee8e0ed := new(cgoAllocMap)
	allocs5ee8e0ed.Add(mem5ee8e0ed)

	ref5ee8e0ed.sType = (C.VkStructureType)(x.SType)

	ref5ee8e0ed.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref5ee8e0ed.flags = (C.VkDescriptorSetLayoutCreateFlags)(x.Flags)

	ref5ee8e0ed.bindingCount = (C.uint32_t)(x.BindingCount)

	var cpBindings_allocs *cgoAllocMap
	ref5ee8e0ed.pBindings, cpBindings_allocs = unpackSDescriptorSetLayoutBinding(x.PBindings)
	allocs5ee8e0ed.Borrow(cpBindings_allocs)

	x.ref5ee8e0ed = ref5ee8e0ed
	x.allocs5ee8e0ed = allocs5ee8e0ed
	return ref5ee8e0ed, allocs5ee8e0ed

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DescriptorSetLayoutCreateInfo) PassValue() (C.VkDescriptorSetLayoutCreateInfo, *cgoAllocMap) {
	if x.ref5ee8e0ed != nil {
		return *x.ref5ee8e0ed, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DescriptorSetLayoutCreateInfo) Deref() {
	if x.ref5ee8e0ed == nil {
		return
	}
	x.SType = (StructureType)(x.ref5ee8e0ed.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref5ee8e0ed.pNext))
	x.Flags = (DescriptorSetLayoutCreateFlags)(x.ref5ee8e0ed.flags)
	x.BindingCount = (uint32)(x.ref5ee8e0ed.bindingCount)
	packSDescriptorSetLayoutBinding(x.PBindings, x.ref5ee8e0ed.pBindings)
}

// allocWriteDescriptorSetMemory allocates memory for type C.VkWriteDescriptorSet in C.
// The caller is responsible for freeing the this memory via C.free.
func allocWriteDescriptorSetMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfWriteDescriptorSetValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfWriteDescriptorSetValue = unsafe.Sizeof([1]C.VkWriteDescriptorSet{})

// unpackSDescriptorImageInfo transforms a sliced Go data structure into plain C format.
func unpackSDescriptorImageInfo(x []DescriptorImageInfo) (unpacked *C.VkDescriptorImageInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocDescriptorImageInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkDescriptorImageInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkDescriptorImageInfo)(h.Data)
	return
}

// unpackSDescriptorBufferInfo transforms a sliced Go data structure into plain C format.
func unpackSDescriptorBufferInfo(x []DescriptorBufferInfo) (unpacked *C.VkDescriptorBufferInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocDescriptorBufferInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkDescriptorBufferInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkDescriptorBufferInfo)(h.Data)
	return
}

// copyPBufferViewBytes copies the data from Go slice as *C.VkBufferView.
func copyPBufferViewBytes(slice *sliceHeader) (*C.VkBufferView, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfBufferViewValue) * slice.Len,
		Cap:  int(sizeOfBufferViewValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkBufferView)(mem0), allocs
}

// allocBufferViewMemory allocates memory for type C.VkBufferView in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBufferViewMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBufferViewValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBufferViewValue = unsafe.Sizeof([1]C.VkBufferView{})

// packSDescriptorImageInfo reads sliced Go data structure out from plain C format.
func packSDescriptorImageInfo(v []DescriptorImageInfo, ptr0 *C.VkDescriptorImageInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDescriptorImageInfoValue]C.VkDescriptorImageInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDescriptorImageInfoRef(unsafe.Pointer(&ptr1))
	}
}

// packSDescriptorBufferInfo reads sliced Go data structure out from plain C format.
func packSDescriptorBufferInfo(v []DescriptorBufferInfo, ptr0 *C.VkDescriptorBufferInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDescriptorBufferInfoValue]C.VkDescriptorBufferInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDescriptorBufferInfoRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *WriteDescriptorSet) Ref() *C.VkWriteDescriptorSet {
	if x == nil {
		return nil
	}
	return x.ref3cec3f3f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *WriteDescriptorSet) Free() {
	if x != nil && x.allocs3cec3f3f != nil {
		x.allocs3cec3f3f.(*cgoAllocMap).Free()
		x.ref3cec3f3f = nil
	}
}

// NewWriteDescriptorSetRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewWriteDescriptorSetRef(ref unsafe.Pointer) *WriteDescriptorSet {
	if ref == nil {
		return nil
	}
	obj := new(WriteDescriptorSet)
	obj.ref3cec3f3f = (*C.VkWriteDescriptorSet)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *WriteDescriptorSet) PassRef() (*C.VkWriteDescriptorSet, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3cec3f3f != nil {
		return x.ref3cec3f3f, nil
	}
	mem3cec3f3f := allocWriteDescriptorSetMemory(1)
	ref3cec3f3f := (*C.VkWriteDescriptorSet)(mem3cec3f3f)
	allocs3cec3f3f := new(cgoAllocMap)
	allocs3cec3f3f.Add(mem3cec3f3f)

	ref3cec3f3f.sType = (C.VkStructureType)(x.SType)

	ref3cec3f3f.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref3cec3f3f.dstSet = *(*C.VkDescriptorSet)(unsafe.Pointer(&x.DstSet))

	ref3cec3f3f.dstBinding = (C.uint32_t)(x.DstBinding)

	ref3cec3f3f.dstArrayElement = (C.uint32_t)(x.DstArrayElement)

	ref3cec3f3f.descriptorCount = (C.uint32_t)(x.DescriptorCount)

	ref3cec3f3f.descriptorType = (C.VkDescriptorType)(x.DescriptorType)

	var cpImageInfo_allocs *cgoAllocMap
	ref3cec3f3f.pImageInfo, cpImageInfo_allocs = unpackSDescriptorImageInfo(x.PImageInfo)
	allocs3cec3f3f.Borrow(cpImageInfo_allocs)

	var cpBufferInfo_allocs *cgoAllocMap
	ref3cec3f3f.pBufferInfo, cpBufferInfo_allocs = unpackSDescriptorBufferInfo(x.PBufferInfo)
	allocs3cec3f3f.Borrow(cpBufferInfo_allocs)

	if x.PTexelBufferView != nil {
		var cpTexelBufferView_allocs *cgoAllocMap
		ref3cec3f3f.pTexelBufferView, cpTexelBufferView_allocs = copyPBufferViewBytes((*sliceHeader)(unsafe.Pointer(&x.PTexelBufferView)))
		allocs3cec3f3f.Borrow(cpTexelBufferView_allocs)
	}

	x.ref3cec3f3f = ref3cec3f3f
	x.allocs3cec3f3f = allocs3cec3f3f
	return ref3cec3f3f, allocs3cec3f3f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x WriteDescriptorSet) PassValue() (C.VkWriteDescriptorSet, *cgoAllocMap) {
	if x.ref3cec3f3f != nil {
		return *x.ref3cec3f3f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *WriteDescriptorSet) Deref() {
	if x.ref3cec3f3f == nil {
		return
	}
	x.SType = (StructureType)(x.ref3cec3f3f.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref3cec3f3f.pNext))
	x.DstSet = *(*DescriptorSet)(unsafe.Pointer(&x.ref3cec3f3f.dstSet))
	x.DstBinding = (uint32)(x.ref3cec3f3f.dstBinding)
	x.DstArrayElement = (uint32)(x.ref3cec3f3f.dstArrayElement)
	x.DescriptorCount = (uint32)(x.ref3cec3f3f.descriptorCount)
	x.DescriptorType = (DescriptorType)(x.ref3cec3f3f.descriptorType)
	packSDescriptorImageInfo(x.PImageInfo, x.ref3cec3f3f.pImageInfo)
	packSDescriptorBufferInfo(x.PBufferInfo, x.ref3cec3f3f.pBufferInfo)
	hxfe48098 := (*sliceHeader)(unsafe.Pointer(&x.PTexelBufferView))
	hxfe48098.Data = unsafe.Pointer(x.ref3cec3f3f.pTexelBufferView)
	hxfe48098.Cap = 0x7fffffff
	// hxfe48098.Len = ? x.PTexelBufferView x.ref3cec3f3f.pTexelBufferView

}

// allocFramebufferCreateInfoMemory allocates memory for type C.VkFramebufferCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFramebufferCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFramebufferCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFramebufferCreateInfoValue = unsafe.Sizeof([1]C.VkFramebufferCreateInfo{})

// copyPImageViewBytes copies the data from Go slice as *C.VkImageView.
func copyPImageViewBytes(slice *sliceHeader) (*C.VkImageView, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfImageViewValue) * slice.Len,
		Cap:  int(sizeOfImageViewValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkImageView)(mem0), allocs
}

// allocImageViewMemory allocates memory for type C.VkImageView in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageViewMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageViewValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfImageViewValue = unsafe.Sizeof([1]C.VkImageView{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FramebufferCreateInfo) Ref() *C.VkFramebufferCreateInfo {
	if x == nil {
		return nil
	}
	return x.refa3ad85cc
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FramebufferCreateInfo) Free() {
	if x != nil && x.allocsa3ad85cc != nil {
		x.allocsa3ad85cc.(*cgoAllocMap).Free()
		x.refa3ad85cc = nil
	}
}

// NewFramebufferCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFramebufferCreateInfoRef(ref unsafe.Pointer) *FramebufferCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(FramebufferCreateInfo)
	obj.refa3ad85cc = (*C.VkFramebufferCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FramebufferCreateInfo) PassRef() (*C.VkFramebufferCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa3ad85cc != nil {
		return x.refa3ad85cc, nil
	}
	mema3ad85cc := allocFramebufferCreateInfoMemory(1)
	refa3ad85cc := (*C.VkFramebufferCreateInfo)(mema3ad85cc)
	allocsa3ad85cc := new(cgoAllocMap)
	allocsa3ad85cc.Add(mema3ad85cc)

	refa3ad85cc.sType = (C.VkStructureType)(x.SType)

	refa3ad85cc.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	refa3ad85cc.flags = (C.VkFramebufferCreateFlags)(x.Flags)

	refa3ad85cc.renderPass = *(*C.VkRenderPass)(unsafe.Pointer(&x.RenderPass))

	refa3ad85cc.attachmentCount = (C.uint32_t)(x.AttachmentCount)

	if x.PAttachments != nil {
		var cpAttachments_allocs *cgoAllocMap
		refa3ad85cc.pAttachments, cpAttachments_allocs = copyPImageViewBytes((*sliceHeader)(unsafe.Pointer(&x.PAttachments)))
		allocsa3ad85cc.Borrow(cpAttachments_allocs)
	}

	refa3ad85cc.width = (C.uint32_t)(x.Width)

	refa3ad85cc.height = (C.uint32_t)(x.Height)

	refa3ad85cc.layers = (C.uint32_t)(x.Layers)

	x.refa3ad85cc = refa3ad85cc
	x.allocsa3ad85cc = allocsa3ad85cc
	return refa3ad85cc, allocsa3ad85cc

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FramebufferCreateInfo) PassValue() (C.VkFramebufferCreateInfo, *cgoAllocMap) {
	if x.refa3ad85cc != nil {
		return *x.refa3ad85cc, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FramebufferCreateInfo) Deref() {
	if x.refa3ad85cc == nil {
		return
	}
	x.SType = (StructureType)(x.refa3ad85cc.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refa3ad85cc.pNext))
	x.Flags = (FramebufferCreateFlags)(x.refa3ad85cc.flags)
	x.RenderPass = *(*RenderPass)(unsafe.Pointer(&x.refa3ad85cc.renderPass))
	x.AttachmentCount = (uint32)(x.refa3ad85cc.attachmentCount)
	hxffe3496 := (*sliceHeader)(unsafe.Pointer(&x.PAttachments))
	hxffe3496.Data = unsafe.Pointer(x.refa3ad85cc.pAttachments)
	hxffe3496.Cap = 0x7fffffff
	// hxffe3496.Len = ? x.PAttachments x.refa3ad85cc.pAttachments

	x.Width = (uint32)(x.refa3ad85cc.width)
	x.Height = (uint32)(x.refa3ad85cc.height)
	x.Layers = (uint32)(x.refa3ad85cc.layers)
}

// allocSubpassDescriptionMemory allocates memory for type C.VkSubpassDescription in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSubpassDescriptionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSubpassDescriptionValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSubpassDescriptionValue = unsafe.Sizeof([1]C.VkSubpassDescription{})

// copyPAttachmentReferenceBytes copies the data from Go slice as *C.VkAttachmentReference.
func copyPAttachmentReferenceBytes(slice *sliceHeader) (*C.VkAttachmentReference, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfAttachmentReferenceValue) * slice.Len,
		Cap:  int(sizeOfAttachmentReferenceValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkAttachmentReference)(mem0), allocs
}

// allocAttachmentReferenceMemory allocates memory for type C.VkAttachmentReference in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAttachmentReferenceMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAttachmentReferenceValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfAttachmentReferenceValue = unsafe.Sizeof([1]C.VkAttachmentReference{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SubpassDescription) Ref() *C.VkSubpassDescription {
	if x == nil {
		return nil
	}
	return x.refc7bfeda
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SubpassDescription) Free() {
	if x != nil && x.allocsc7bfeda != nil {
		x.allocsc7bfeda.(*cgoAllocMap).Free()
		x.refc7bfeda = nil
	}
}

// NewSubpassDescriptionRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSubpassDescriptionRef(ref unsafe.Pointer) *SubpassDescription {
	if ref == nil {
		return nil
	}
	obj := new(SubpassDescription)
	obj.refc7bfeda = (*C.VkSubpassDescription)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SubpassDescription) PassRef() (*C.VkSubpassDescription, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc7bfeda != nil {
		return x.refc7bfeda, nil
	}
	memc7bfeda := allocSubpassDescriptionMemory(1)
	refc7bfeda := (*C.VkSubpassDescription)(memc7bfeda)
	allocsc7bfeda := new(cgoAllocMap)
	allocsc7bfeda.Add(memc7bfeda)

	refc7bfeda.flags = (C.VkSubpassDescriptionFlags)(x.Flags)

	refc7bfeda.pipelineBindPoint = (C.VkPipelineBindPoint)(x.PipelineBindPoint)

	refc7bfeda.inputAttachmentCount = (C.uint32_t)(x.InputAttachmentCount)

	if x.PInputAttachments != nil {
		var cpInputAttachments_allocs *cgoAllocMap
		refc7bfeda.pInputAttachments, cpInputAttachments_allocs = copyPAttachmentReferenceBytes((*sliceHeader)(unsafe.Pointer(&x.PInputAttachments)))
		allocsc7bfeda.Borrow(cpInputAttachments_allocs)
	}

	refc7bfeda.colorAttachmentCount = (C.uint32_t)(x.ColorAttachmentCount)

	if x.PColorAttachments != nil {
		var cpColorAttachments_allocs *cgoAllocMap
		refc7bfeda.pColorAttachments, cpColorAttachments_allocs = copyPAttachmentReferenceBytes((*sliceHeader)(unsafe.Pointer(&x.PColorAttachments)))
		allocsc7bfeda.Borrow(cpColorAttachments_allocs)
	}

	if x.PResolveAttachments != nil {
		var cpResolveAttachments_allocs *cgoAllocMap
		refc7bfeda.pResolveAttachments, cpResolveAttachments_allocs = copyPAttachmentReferenceBytes((*sliceHeader)(unsafe.Pointer(&x.PResolveAttachments)))
		allocsc7bfeda.Borrow(cpResolveAttachments_allocs)
	}

	refc7bfeda.pDepthStencilAttachment = *(**C.VkAttachmentReference)(unsafe.Pointer(&x.PDepthStencilAttachment))

	refc7bfeda.preserveAttachmentCount = (C.uint32_t)(x.PreserveAttachmentCount)

	if x.PPreserveAttachments != nil {
		var cpPreserveAttachments_allocs *cgoAllocMap
		refc7bfeda.pPreserveAttachments, cpPreserveAttachments_allocs = copyPUint32_tBytes((*sliceHeader)(unsafe.Pointer(&x.PPreserveAttachments)))
		allocsc7bfeda.Borrow(cpPreserveAttachments_allocs)
	}

	x.refc7bfeda = refc7bfeda
	x.allocsc7bfeda = allocsc7bfeda
	return refc7bfeda, allocsc7bfeda

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SubpassDescription) PassValue() (C.VkSubpassDescription, *cgoAllocMap) {
	if x.refc7bfeda != nil {
		return *x.refc7bfeda, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SubpassDescription) Deref() {
	if x.refc7bfeda == nil {
		return
	}
	x.Flags = (SubpassDescriptionFlags)(x.refc7bfeda.flags)
	x.PipelineBindPoint = (PipelineBindPoint)(x.refc7bfeda.pipelineBindPoint)
	x.InputAttachmentCount = (uint32)(x.refc7bfeda.inputAttachmentCount)
	hxf5d48a6 := (*sliceHeader)(unsafe.Pointer(&x.PInputAttachments))
	hxf5d48a6.Data = unsafe.Pointer(x.refc7bfeda.pInputAttachments)
	hxf5d48a6.Cap = 0x7fffffff
	// hxf5d48a6.Len = ? x.PInputAttachments x.refc7bfeda.pInputAttachments

	x.ColorAttachmentCount = (uint32)(x.refc7bfeda.colorAttachmentCount)
	hxf685469 := (*sliceHeader)(unsafe.Pointer(&x.PColorAttachments))
	hxf685469.Data = unsafe.Pointer(x.refc7bfeda.pColorAttachments)
	hxf685469.Cap = 0x7fffffff
	// hxf685469.Len = ? x.PColorAttachments x.refc7bfeda.pColorAttachments

	hxf03a9a7 := (*sliceHeader)(unsafe.Pointer(&x.PResolveAttachments))
	hxf03a9a7.Data = unsafe.Pointer(x.refc7bfeda.pResolveAttachments)
	hxf03a9a7.Cap = 0x7fffffff
	// hxf03a9a7.Len = ? x.PResolveAttachments x.refc7bfeda.pResolveAttachments

	x.PDepthStencilAttachment = (*AttachmentReference)(unsafe.Pointer(x.refc7bfeda.pDepthStencilAttachment))
	x.PreserveAttachmentCount = (uint32)(x.refc7bfeda.preserveAttachmentCount)
	hxff24242 := (*sliceHeader)(unsafe.Pointer(&x.PPreserveAttachments))
	hxff24242.Data = unsafe.Pointer(x.refc7bfeda.pPreserveAttachments)
	hxff24242.Cap = 0x7fffffff
	// hxff24242.Len = ? x.PPreserveAttachments x.refc7bfeda.pPreserveAttachments

}

// allocRenderPassCreateInfoMemory allocates memory for type C.VkRenderPassCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRenderPassCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRenderPassCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfRenderPassCreateInfoValue = unsafe.Sizeof([1]C.VkRenderPassCreateInfo{})

// copyPAttachmentDescriptionBytes copies the data from Go slice as *C.VkAttachmentDescription.
func copyPAttachmentDescriptionBytes(slice *sliceHeader) (*C.VkAttachmentDescription, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfAttachmentDescriptionValue) * slice.Len,
		Cap:  int(sizeOfAttachmentDescriptionValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkAttachmentDescription)(mem0), allocs
}

// allocAttachmentDescriptionMemory allocates memory for type C.VkAttachmentDescription in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAttachmentDescriptionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAttachmentDescriptionValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfAttachmentDescriptionValue = unsafe.Sizeof([1]C.VkAttachmentDescription{})

// unpackSSubpassDescription transforms a sliced Go data structure into plain C format.
func unpackSSubpassDescription(x []SubpassDescription) (unpacked *C.VkSubpassDescription, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocSubpassDescriptionMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSubpassDescription)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSubpassDescription)(h.Data)
	return
}

// copyPSubpassDependencyBytes copies the data from Go slice as *C.VkSubpassDependency.
func copyPSubpassDependencyBytes(slice *sliceHeader) (*C.VkSubpassDependency, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfSubpassDependencyValue) * slice.Len,
		Cap:  int(sizeOfSubpassDependencyValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkSubpassDependency)(mem0), allocs
}

// allocSubpassDependencyMemory allocates memory for type C.VkSubpassDependency in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSubpassDependencyMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSubpassDependencyValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSubpassDependencyValue = unsafe.Sizeof([1]C.VkSubpassDependency{})

// packSSubpassDescription reads sliced Go data structure out from plain C format.
func packSSubpassDescription(v []SubpassDescription, ptr0 *C.VkSubpassDescription) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSubpassDescriptionValue]C.VkSubpassDescription)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSubpassDescriptionRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RenderPassCreateInfo) Ref() *C.VkRenderPassCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref886d7d86
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RenderPassCreateInfo) Free() {
	if x != nil && x.allocs886d7d86 != nil {
		x.allocs886d7d86.(*cgoAllocMap).Free()
		x.ref886d7d86 = nil
	}
}

// NewRenderPassCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRenderPassCreateInfoRef(ref unsafe.Pointer) *RenderPassCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(RenderPassCreateInfo)
	obj.ref886d7d86 = (*C.VkRenderPassCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RenderPassCreateInfo) PassRef() (*C.VkRenderPassCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref886d7d86 != nil {
		return x.ref886d7d86, nil
	}
	mem886d7d86 := allocRenderPassCreateInfoMemory(1)
	ref886d7d86 := (*C.VkRenderPassCreateInfo)(mem886d7d86)
	allocs886d7d86 := new(cgoAllocMap)
	allocs886d7d86.Add(mem886d7d86)

	ref886d7d86.sType = (C.VkStructureType)(x.SType)

	ref886d7d86.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref886d7d86.flags = (C.VkRenderPassCreateFlags)(x.Flags)

	ref886d7d86.attachmentCount = (C.uint32_t)(x.AttachmentCount)

	if x.PAttachments != nil {
		var cpAttachments_allocs *cgoAllocMap
		ref886d7d86.pAttachments, cpAttachments_allocs = copyPAttachmentDescriptionBytes((*sliceHeader)(unsafe.Pointer(&x.PAttachments)))
		allocs886d7d86.Borrow(cpAttachments_allocs)
	}

	ref886d7d86.subpassCount = (C.uint32_t)(x.SubpassCount)

	var cpSubpasses_allocs *cgoAllocMap
	ref886d7d86.pSubpasses, cpSubpasses_allocs = unpackSSubpassDescription(x.PSubpasses)
	allocs886d7d86.Borrow(cpSubpasses_allocs)

	ref886d7d86.dependencyCount = (C.uint32_t)(x.DependencyCount)

	if x.PDependencies != nil {
		var cpDependencies_allocs *cgoAllocMap
		ref886d7d86.pDependencies, cpDependencies_allocs = copyPSubpassDependencyBytes((*sliceHeader)(unsafe.Pointer(&x.PDependencies)))
		allocs886d7d86.Borrow(cpDependencies_allocs)
	}

	x.ref886d7d86 = ref886d7d86
	x.allocs886d7d86 = allocs886d7d86
	return ref886d7d86, allocs886d7d86

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RenderPassCreateInfo) PassValue() (C.VkRenderPassCreateInfo, *cgoAllocMap) {
	if x.ref886d7d86 != nil {
		return *x.ref886d7d86, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *RenderPassCreateInfo) Deref() {
	if x.ref886d7d86 == nil {
		return
	}
	x.SType = (StructureType)(x.ref886d7d86.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref886d7d86.pNext))
	x.Flags = (RenderPassCreateFlags)(x.ref886d7d86.flags)
	x.AttachmentCount = (uint32)(x.ref886d7d86.attachmentCount)
	hxfe93325 := (*sliceHeader)(unsafe.Pointer(&x.PAttachments))
	hxfe93325.Data = unsafe.Pointer(x.ref886d7d86.pAttachments)
	hxfe93325.Cap = 0x7fffffff
	// hxfe93325.Len = ? x.PAttachments x.ref886d7d86.pAttachments

	x.SubpassCount = (uint32)(x.ref886d7d86.subpassCount)
	packSSubpassDescription(x.PSubpasses, x.ref886d7d86.pSubpasses)
	x.DependencyCount = (uint32)(x.ref886d7d86.dependencyCount)
	hxf09ea94 := (*sliceHeader)(unsafe.Pointer(&x.PDependencies))
	hxf09ea94.Data = unsafe.Pointer(x.ref886d7d86.pDependencies)
	hxf09ea94.Cap = 0x7fffffff
	// hxf09ea94.Len = ? x.PDependencies x.ref886d7d86.pDependencies

}

// allocCommandBufferAllocateInfoMemory allocates memory for type C.VkCommandBufferAllocateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCommandBufferAllocateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCommandBufferAllocateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCommandBufferAllocateInfoValue = unsafe.Sizeof([1]C.VkCommandBufferAllocateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CommandBufferAllocateInfo) Ref() *C.VkCommandBufferAllocateInfo {
	if x == nil {
		return nil
	}
	return x.refd1a0a7c8
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CommandBufferAllocateInfo) Free() {
	if x != nil && x.allocsd1a0a7c8 != nil {
		x.allocsd1a0a7c8.(*cgoAllocMap).Free()
		x.refd1a0a7c8 = nil
	}
}

// NewCommandBufferAllocateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCommandBufferAllocateInfoRef(ref unsafe.Pointer) *CommandBufferAllocateInfo {
	if ref == nil {
		return nil
	}
	obj := new(CommandBufferAllocateInfo)
	obj.refd1a0a7c8 = (*C.VkCommandBufferAllocateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CommandBufferAllocateInfo) PassRef() (*C.VkCommandBufferAllocateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd1a0a7c8 != nil {
		return x.refd1a0a7c8, nil
	}
	memd1a0a7c8 := allocCommandBufferAllocateInfoMemory(1)
	refd1a0a7c8 := (*C.VkCommandBufferAllocateInfo)(memd1a0a7c8)
	allocsd1a0a7c8 := new(cgoAllocMap)
	allocsd1a0a7c8.Add(memd1a0a7c8)

	refd1a0a7c8.sType = (C.VkStructureType)(x.SType)

	refd1a0a7c8.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	refd1a0a7c8.commandPool = *(*C.VkCommandPool)(unsafe.Pointer(&x.CommandPool))

	refd1a0a7c8.level = (C.VkCommandBufferLevel)(x.Level)

	refd1a0a7c8.commandBufferCount = (C.uint32_t)(x.CommandBufferCount)

	x.refd1a0a7c8 = refd1a0a7c8
	x.allocsd1a0a7c8 = allocsd1a0a7c8
	return refd1a0a7c8, allocsd1a0a7c8

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CommandBufferAllocateInfo) PassValue() (C.VkCommandBufferAllocateInfo, *cgoAllocMap) {
	if x.refd1a0a7c8 != nil {
		return *x.refd1a0a7c8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CommandBufferAllocateInfo) Deref() {
	if x.refd1a0a7c8 == nil {
		return
	}
	x.SType = (StructureType)(x.refd1a0a7c8.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refd1a0a7c8.pNext))
	x.CommandPool = *(*CommandPool)(unsafe.Pointer(&x.refd1a0a7c8.commandPool))
	x.Level = (CommandBufferLevel)(x.refd1a0a7c8.level)
	x.CommandBufferCount = (uint32)(x.refd1a0a7c8.commandBufferCount)
}

// allocCommandBufferInheritanceInfoMemory allocates memory for type C.VkCommandBufferInheritanceInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCommandBufferInheritanceInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCommandBufferInheritanceInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCommandBufferInheritanceInfoValue = unsafe.Sizeof([1]C.VkCommandBufferInheritanceInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CommandBufferInheritanceInfo) Ref() *C.VkCommandBufferInheritanceInfo {
	if x == nil {
		return nil
	}
	return x.ref737f8019
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CommandBufferInheritanceInfo) Free() {
	if x != nil && x.allocs737f8019 != nil {
		x.allocs737f8019.(*cgoAllocMap).Free()
		x.ref737f8019 = nil
	}
}

// NewCommandBufferInheritanceInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCommandBufferInheritanceInfoRef(ref unsafe.Pointer) *CommandBufferInheritanceInfo {
	if ref == nil {
		return nil
	}
	obj := new(CommandBufferInheritanceInfo)
	obj.ref737f8019 = (*C.VkCommandBufferInheritanceInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CommandBufferInheritanceInfo) PassRef() (*C.VkCommandBufferInheritanceInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref737f8019 != nil {
		return x.ref737f8019, nil
	}
	mem737f8019 := allocCommandBufferInheritanceInfoMemory(1)
	ref737f8019 := (*C.VkCommandBufferInheritanceInfo)(mem737f8019)
	allocs737f8019 := new(cgoAllocMap)
	allocs737f8019.Add(mem737f8019)

	ref737f8019.sType = (C.VkStructureType)(x.SType)

	ref737f8019.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref737f8019.renderPass = *(*C.VkRenderPass)(unsafe.Pointer(&x.RenderPass))

	ref737f8019.subpass = (C.uint32_t)(x.Subpass)

	ref737f8019.framebuffer = *(*C.VkFramebuffer)(unsafe.Pointer(&x.Framebuffer))

	ref737f8019.occlusionQueryEnable = (C.VkBool32)(x.OcclusionQueryEnable)

	ref737f8019.queryFlags = (C.VkQueryControlFlags)(x.QueryFlags)

	ref737f8019.pipelineStatistics = (C.VkQueryPipelineStatisticFlags)(x.PipelineStatistics)

	x.ref737f8019 = ref737f8019
	x.allocs737f8019 = allocs737f8019
	return ref737f8019, allocs737f8019

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CommandBufferInheritanceInfo) PassValue() (C.VkCommandBufferInheritanceInfo, *cgoAllocMap) {
	if x.ref737f8019 != nil {
		return *x.ref737f8019, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CommandBufferInheritanceInfo) Deref() {
	if x.ref737f8019 == nil {
		return
	}
	x.SType = (StructureType)(x.ref737f8019.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref737f8019.pNext))
	x.RenderPass = *(*RenderPass)(unsafe.Pointer(&x.ref737f8019.renderPass))
	x.Subpass = (uint32)(x.ref737f8019.subpass)
	x.Framebuffer = *(*Framebuffer)(unsafe.Pointer(&x.ref737f8019.framebuffer))
	x.OcclusionQueryEnable = (Bool32)(x.ref737f8019.occlusionQueryEnable)
	x.QueryFlags = (QueryControlFlags)(x.ref737f8019.queryFlags)
	x.PipelineStatistics = (QueryPipelineStatisticFlags)(x.ref737f8019.pipelineStatistics)
}

// allocCommandBufferBeginInfoMemory allocates memory for type C.VkCommandBufferBeginInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCommandBufferBeginInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCommandBufferBeginInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCommandBufferBeginInfoValue = unsafe.Sizeof([1]C.VkCommandBufferBeginInfo{})

// unpackSCommandBufferInheritanceInfo transforms a sliced Go data structure into plain C format.
func unpackSCommandBufferInheritanceInfo(x []CommandBufferInheritanceInfo) (unpacked *C.VkCommandBufferInheritanceInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocCommandBufferInheritanceInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkCommandBufferInheritanceInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkCommandBufferInheritanceInfo)(h.Data)
	return
}

// packSCommandBufferInheritanceInfo reads sliced Go data structure out from plain C format.
func packSCommandBufferInheritanceInfo(v []CommandBufferInheritanceInfo, ptr0 *C.VkCommandBufferInheritanceInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfCommandBufferInheritanceInfoValue]C.VkCommandBufferInheritanceInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewCommandBufferInheritanceInfoRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CommandBufferBeginInfo) Ref() *C.VkCommandBufferBeginInfo {
	if x == nil {
		return nil
	}
	return x.ref266762df
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CommandBufferBeginInfo) Free() {
	if x != nil && x.allocs266762df != nil {
		x.allocs266762df.(*cgoAllocMap).Free()
		x.ref266762df = nil
	}
}

// NewCommandBufferBeginInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCommandBufferBeginInfoRef(ref unsafe.Pointer) *CommandBufferBeginInfo {
	if ref == nil {
		return nil
	}
	obj := new(CommandBufferBeginInfo)
	obj.ref266762df = (*C.VkCommandBufferBeginInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CommandBufferBeginInfo) PassRef() (*C.VkCommandBufferBeginInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref266762df != nil {
		return x.ref266762df, nil
	}
	mem266762df := allocCommandBufferBeginInfoMemory(1)
	ref266762df := (*C.VkCommandBufferBeginInfo)(mem266762df)
	allocs266762df := new(cgoAllocMap)
	allocs266762df.Add(mem266762df)

	ref266762df.sType = (C.VkStructureType)(x.SType)

	ref266762df.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref266762df.flags = (C.VkCommandBufferUsageFlags)(x.Flags)

	var cpInheritanceInfo_allocs *cgoAllocMap
	ref266762df.pInheritanceInfo, cpInheritanceInfo_allocs = unpackSCommandBufferInheritanceInfo(x.PInheritanceInfo)
	allocs266762df.Borrow(cpInheritanceInfo_allocs)

	x.ref266762df = ref266762df
	x.allocs266762df = allocs266762df
	return ref266762df, allocs266762df

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CommandBufferBeginInfo) PassValue() (C.VkCommandBufferBeginInfo, *cgoAllocMap) {
	if x.ref266762df != nil {
		return *x.ref266762df, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CommandBufferBeginInfo) Deref() {
	if x.ref266762df == nil {
		return
	}
	x.SType = (StructureType)(x.ref266762df.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref266762df.pNext))
	x.Flags = (CommandBufferUsageFlags)(x.ref266762df.flags)
	packSCommandBufferInheritanceInfo(x.PInheritanceInfo, x.ref266762df.pInheritanceInfo)
}

// allocClearAttachmentMemory allocates memory for type C.VkClearAttachment in C.
// The caller is responsible for freeing the this memory via C.free.
func allocClearAttachmentMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfClearAttachmentValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfClearAttachmentValue = unsafe.Sizeof([1]C.VkClearAttachment{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ClearAttachment) Ref() *C.VkClearAttachment {
	if x == nil {
		return nil
	}
	return x.refe9150303
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ClearAttachment) Free() {
	if x != nil && x.allocse9150303 != nil {
		x.allocse9150303.(*cgoAllocMap).Free()
		x.refe9150303 = nil
	}
}

// NewClearAttachmentRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewClearAttachmentRef(ref unsafe.Pointer) *ClearAttachment {
	if ref == nil {
		return nil
	}
	obj := new(ClearAttachment)
	obj.refe9150303 = (*C.VkClearAttachment)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ClearAttachment) PassRef() (*C.VkClearAttachment, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe9150303 != nil {
		return x.refe9150303, nil
	}
	meme9150303 := allocClearAttachmentMemory(1)
	refe9150303 := (*C.VkClearAttachment)(meme9150303)
	allocse9150303 := new(cgoAllocMap)
	allocse9150303.Add(meme9150303)

	refe9150303.aspectMask = (C.VkImageAspectFlags)(x.AspectMask)

	refe9150303.colorAttachment = (C.uint32_t)(x.ColorAttachment)

	refe9150303.clearValue = *(*C.VkClearValue)(unsafe.Pointer(&x.ClearValue))

	x.refe9150303 = refe9150303
	x.allocse9150303 = allocse9150303
	return refe9150303, allocse9150303

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ClearAttachment) PassValue() (C.VkClearAttachment, *cgoAllocMap) {
	if x.refe9150303 != nil {
		return *x.refe9150303, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ClearAttachment) Deref() {
	if x.refe9150303 == nil {
		return
	}
	x.AspectMask = (ImageAspectFlags)(x.refe9150303.aspectMask)
	x.ColorAttachment = (uint32)(x.refe9150303.colorAttachment)
	x.ClearValue = *(*ClearValue)(unsafe.Pointer(&x.refe9150303.clearValue))
}

// allocRenderPassBeginInfoMemory allocates memory for type C.VkRenderPassBeginInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRenderPassBeginInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRenderPassBeginInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfRenderPassBeginInfoValue = unsafe.Sizeof([1]C.VkRenderPassBeginInfo{})

// copyPClearValueBytes copies the data from Go slice as *C.VkClearValue.
func copyPClearValueBytes(slice *sliceHeader) (*C.VkClearValue, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfClearValueValue) * slice.Len,
		Cap:  int(sizeOfClearValueValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkClearValue)(mem0), allocs
}

// allocClearValueMemory allocates memory for type C.VkClearValue in C.
// The caller is responsible for freeing the this memory via C.free.
func allocClearValueMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfClearValueValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfClearValueValue = unsafe.Sizeof([1]C.VkClearValue{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RenderPassBeginInfo) Ref() *C.VkRenderPassBeginInfo {
	if x == nil {
		return nil
	}
	return x.ref3c3752c8
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RenderPassBeginInfo) Free() {
	if x != nil && x.allocs3c3752c8 != nil {
		x.allocs3c3752c8.(*cgoAllocMap).Free()
		x.ref3c3752c8 = nil
	}
}

// NewRenderPassBeginInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRenderPassBeginInfoRef(ref unsafe.Pointer) *RenderPassBeginInfo {
	if ref == nil {
		return nil
	}
	obj := new(RenderPassBeginInfo)
	obj.ref3c3752c8 = (*C.VkRenderPassBeginInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RenderPassBeginInfo) PassRef() (*C.VkRenderPassBeginInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3c3752c8 != nil {
		return x.ref3c3752c8, nil
	}
	mem3c3752c8 := allocRenderPassBeginInfoMemory(1)
	ref3c3752c8 := (*C.VkRenderPassBeginInfo)(mem3c3752c8)
	allocs3c3752c8 := new(cgoAllocMap)
	allocs3c3752c8.Add(mem3c3752c8)

	ref3c3752c8.sType = (C.VkStructureType)(x.SType)

	ref3c3752c8.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref3c3752c8.renderPass = *(*C.VkRenderPass)(unsafe.Pointer(&x.RenderPass))

	ref3c3752c8.framebuffer = *(*C.VkFramebuffer)(unsafe.Pointer(&x.Framebuffer))

	ref3c3752c8.renderArea = *(*C.VkRect2D)(unsafe.Pointer(&x.RenderArea))

	ref3c3752c8.clearValueCount = (C.uint32_t)(x.ClearValueCount)

	if x.PClearValues != nil {
		var cpClearValues_allocs *cgoAllocMap
		ref3c3752c8.pClearValues, cpClearValues_allocs = copyPClearValueBytes((*sliceHeader)(unsafe.Pointer(&x.PClearValues)))
		allocs3c3752c8.Borrow(cpClearValues_allocs)
	}

	x.ref3c3752c8 = ref3c3752c8
	x.allocs3c3752c8 = allocs3c3752c8
	return ref3c3752c8, allocs3c3752c8

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RenderPassBeginInfo) PassValue() (C.VkRenderPassBeginInfo, *cgoAllocMap) {
	if x.ref3c3752c8 != nil {
		return *x.ref3c3752c8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *RenderPassBeginInfo) Deref() {
	if x.ref3c3752c8 == nil {
		return
	}
	x.SType = (StructureType)(x.ref3c3752c8.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref3c3752c8.pNext))
	x.RenderPass = *(*RenderPass)(unsafe.Pointer(&x.ref3c3752c8.renderPass))
	x.Framebuffer = *(*Framebuffer)(unsafe.Pointer(&x.ref3c3752c8.framebuffer))
	x.RenderArea = *(*Rect2D)(unsafe.Pointer(&x.ref3c3752c8.renderArea))
	x.ClearValueCount = (uint32)(x.ref3c3752c8.clearValueCount)
	hxfd687ee := (*sliceHeader)(unsafe.Pointer(&x.PClearValues))
	hxfd687ee.Data = unsafe.Pointer(x.ref3c3752c8.pClearValues)
	hxfd687ee.Cap = 0x7fffffff
	// hxfd687ee.Len = ? x.PClearValues x.ref3c3752c8.pClearValues

}

// allocBindBufferMemoryInfoMemory allocates memory for type C.VkBindBufferMemoryInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBindBufferMemoryInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBindBufferMemoryInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBindBufferMemoryInfoValue = unsafe.Sizeof([1]C.VkBindBufferMemoryInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BindBufferMemoryInfo) Ref() *C.VkBindBufferMemoryInfo {
	if x == nil {
		return nil
	}
	return x.refd392322d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BindBufferMemoryInfo) Free() {
	if x != nil && x.allocsd392322d != nil {
		x.allocsd392322d.(*cgoAllocMap).Free()
		x.refd392322d = nil
	}
}

// NewBindBufferMemoryInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBindBufferMemoryInfoRef(ref unsafe.Pointer) *BindBufferMemoryInfo {
	if ref == nil {
		return nil
	}
	obj := new(BindBufferMemoryInfo)
	obj.refd392322d = (*C.VkBindBufferMemoryInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BindBufferMemoryInfo) PassRef() (*C.VkBindBufferMemoryInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd392322d != nil {
		return x.refd392322d, nil
	}
	memd392322d := allocBindBufferMemoryInfoMemory(1)
	refd392322d := (*C.VkBindBufferMemoryInfo)(memd392322d)
	allocsd392322d := new(cgoAllocMap)
	allocsd392322d.Add(memd392322d)

	refd392322d.sType = (C.VkStructureType)(x.SType)

	refd392322d.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	refd392322d.buffer = *(*C.VkBuffer)(unsafe.Pointer(&x.Buffer))

	refd392322d.memory = *(*C.VkDeviceMemory)(unsafe.Pointer(&x.Memory))

	refd392322d.memoryOffset = (C.VkDeviceSize)(x.MemoryOffset)

	x.refd392322d = refd392322d
	x.allocsd392322d = allocsd392322d
	return refd392322d, allocsd392322d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BindBufferMemoryInfo) PassValue() (C.VkBindBufferMemoryInfo, *cgoAllocMap) {
	if x.refd392322d != nil {
		return *x.refd392322d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BindBufferMemoryInfo) Deref() {
	if x.refd392322d == nil {
		return
	}
	x.SType = (StructureType)(x.refd392322d.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refd392322d.pNext))
	x.Buffer = *(*Buffer)(unsafe.Pointer(&x.refd392322d.buffer))
	x.Memory = *(*DeviceMemory)(unsafe.Pointer(&x.refd392322d.memory))
	x.MemoryOffset = (DeviceSize)(x.refd392322d.memoryOffset)
}

// allocBindImageMemoryInfoMemory allocates memory for type C.VkBindImageMemoryInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBindImageMemoryInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBindImageMemoryInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBindImageMemoryInfoValue = unsafe.Sizeof([1]C.VkBindImageMemoryInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BindImageMemoryInfo) Ref() *C.VkBindImageMemoryInfo {
	if x == nil {
		return nil
	}
	return x.ref767a2113
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BindImageMemoryInfo) Free() {
	if x != nil && x.allocs767a2113 != nil {
		x.allocs767a2113.(*cgoAllocMap).Free()
		x.ref767a2113 = nil
	}
}

// NewBindImageMemoryInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBindImageMemoryInfoRef(ref unsafe.Pointer) *BindImageMemoryInfo {
	if ref == nil {
		return nil
	}
	obj := new(BindImageMemoryInfo)
	obj.ref767a2113 = (*C.VkBindImageMemoryInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BindImageMemoryInfo) PassRef() (*C.VkBindImageMemoryInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref767a2113 != nil {
		return x.ref767a2113, nil
	}
	mem767a2113 := allocBindImageMemoryInfoMemory(1)
	ref767a2113 := (*C.VkBindImageMemoryInfo)(mem767a2113)
	allocs767a2113 := new(cgoAllocMap)
	allocs767a2113.Add(mem767a2113)

	ref767a2113.sType = (C.VkStructureType)(x.SType)

	ref767a2113.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref767a2113.image = *(*C.VkImage)(unsafe.Pointer(&x.Image))

	ref767a2113.memory = *(*C.VkDeviceMemory)(unsafe.Pointer(&x.Memory))

	ref767a2113.memoryOffset = (C.VkDeviceSize)(x.MemoryOffset)

	x.ref767a2113 = ref767a2113
	x.allocs767a2113 = allocs767a2113
	return ref767a2113, allocs767a2113

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BindImageMemoryInfo) PassValue() (C.VkBindImageMemoryInfo, *cgoAllocMap) {
	if x.ref767a2113 != nil {
		return *x.ref767a2113, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BindImageMemoryInfo) Deref() {
	if x.ref767a2113 == nil {
		return
	}
	x.SType = (StructureType)(x.ref767a2113.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref767a2113.pNext))
	x.Image = *(*Image)(unsafe.Pointer(&x.ref767a2113.image))
	x.Memory = *(*DeviceMemory)(unsafe.Pointer(&x.ref767a2113.memory))
	x.MemoryOffset = (DeviceSize)(x.ref767a2113.memoryOffset)
}

// allocMemoryDedicatedAllocateInfoMemory allocates memory for type C.VkMemoryDedicatedAllocateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMemoryDedicatedAllocateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMemoryDedicatedAllocateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfMemoryDedicatedAllocateInfoValue = unsafe.Sizeof([1]C.VkMemoryDedicatedAllocateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *MemoryDedicatedAllocateInfo) Ref() *C.VkMemoryDedicatedAllocateInfo {
	if x == nil {
		return nil
	}
	return x.reff8fabe62
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *MemoryDedicatedAllocateInfo) Free() {
	if x != nil && x.allocsf8fabe62 != nil {
		x.allocsf8fabe62.(*cgoAllocMap).Free()
		x.reff8fabe62 = nil
	}
}

// NewMemoryDedicatedAllocateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMemoryDedicatedAllocateInfoRef(ref unsafe.Pointer) *MemoryDedicatedAllocateInfo {
	if ref == nil {
		return nil
	}
	obj := new(MemoryDedicatedAllocateInfo)
	obj.reff8fabe62 = (*C.VkMemoryDedicatedAllocateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *MemoryDedicatedAllocateInfo) PassRef() (*C.VkMemoryDedicatedAllocateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff8fabe62 != nil {
		return x.reff8fabe62, nil
	}
	memf8fabe62 := allocMemoryDedicatedAllocateInfoMemory(1)
	reff8fabe62 := (*C.VkMemoryDedicatedAllocateInfo)(memf8fabe62)
	allocsf8fabe62 := new(cgoAllocMap)
	allocsf8fabe62.Add(memf8fabe62)

	reff8fabe62.sType = (C.VkStructureType)(x.SType)

	reff8fabe62.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	reff8fabe62.image = *(*C.VkImage)(unsafe.Pointer(&x.Image))

	reff8fabe62.buffer = *(*C.VkBuffer)(unsafe.Pointer(&x.Buffer))

	x.reff8fabe62 = reff8fabe62
	x.allocsf8fabe62 = allocsf8fabe62
	return reff8fabe62, allocsf8fabe62

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x MemoryDedicatedAllocateInfo) PassValue() (C.VkMemoryDedicatedAllocateInfo, *cgoAllocMap) {
	if x.reff8fabe62 != nil {
		return *x.reff8fabe62, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *MemoryDedicatedAllocateInfo) Deref() {
	if x.reff8fabe62 == nil {
		return
	}
	x.SType = (StructureType)(x.reff8fabe62.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.reff8fabe62.pNext))
	x.Image = *(*Image)(unsafe.Pointer(&x.reff8fabe62.image))
	x.Buffer = *(*Buffer)(unsafe.Pointer(&x.reff8fabe62.buffer))
}

// allocDeviceGroupRenderPassBeginInfoMemory allocates memory for type C.VkDeviceGroupRenderPassBeginInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceGroupRenderPassBeginInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceGroupRenderPassBeginInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDeviceGroupRenderPassBeginInfoValue = unsafe.Sizeof([1]C.VkDeviceGroupRenderPassBeginInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DeviceGroupRenderPassBeginInfo) Ref() *C.VkDeviceGroupRenderPassBeginInfo {
	if x == nil {
		return nil
	}
	return x.ref139f3599
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DeviceGroupRenderPassBeginInfo) Free() {
	if x != nil && x.allocs139f3599 != nil {
		x.allocs139f3599.(*cgoAllocMap).Free()
		x.ref139f3599 = nil
	}
}

// NewDeviceGroupRenderPassBeginInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDeviceGroupRenderPassBeginInfoRef(ref unsafe.Pointer) *DeviceGroupRenderPassBeginInfo {
	if ref == nil {
		return nil
	}
	obj := new(DeviceGroupRenderPassBeginInfo)
	obj.ref139f3599 = (*C.VkDeviceGroupRenderPassBeginInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DeviceGroupRenderPassBeginInfo) PassRef() (*C.VkDeviceGroupRenderPassBeginInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref139f3599 != nil {
		return x.ref139f3599, nil
	}
	mem139f3599 := allocDeviceGroupRenderPassBeginInfoMemory(1)
	ref139f3599 := (*C.VkDeviceGroupRenderPassBeginInfo)(mem139f3599)
	allocs139f3599 := new(cgoAllocMap)
	allocs139f3599.Add(mem139f3599)

	ref139f3599.sType = (C.VkStructureType)(x.SType)

	ref139f3599.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref139f3599.deviceMask = (C.uint32_t)(x.DeviceMask)

	ref139f3599.deviceRenderAreaCount = (C.uint32_t)(x.DeviceRenderAreaCount)

	if x.PDeviceRenderAreas != nil {
		var cpDeviceRenderAreas_allocs *cgoAllocMap
		ref139f3599.pDeviceRenderAreas, cpDeviceRenderAreas_allocs = copyPRect2DBytes((*sliceHeader)(unsafe.Pointer(&x.PDeviceRenderAreas)))
		allocs139f3599.Borrow(cpDeviceRenderAreas_allocs)
	}

	x.ref139f3599 = ref139f3599
	x.allocs139f3599 = allocs139f3599
	return ref139f3599, allocs139f3599

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DeviceGroupRenderPassBeginInfo) PassValue() (C.VkDeviceGroupRenderPassBeginInfo, *cgoAllocMap) {
	if x.ref139f3599 != nil {
		return *x.ref139f3599, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DeviceGroupRenderPassBeginInfo) Deref() {
	if x.ref139f3599 == nil {
		return
	}
	x.SType = (StructureType)(x.ref139f3599.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref139f3599.pNext))
	x.DeviceMask = (uint32)(x.ref139f3599.deviceMask)
	x.DeviceRenderAreaCount = (uint32)(x.ref139f3599.deviceRenderAreaCount)
	hxf15a567 := (*sliceHeader)(unsafe.Pointer(&x.PDeviceRenderAreas))
	hxf15a567.Data = unsafe.Pointer(x.ref139f3599.pDeviceRenderAreas)
	hxf15a567.Cap = 0x7fffffff
	// hxf15a567.Len = ? x.PDeviceRenderAreas x.ref139f3599.pDeviceRenderAreas

}

// allocDeviceGroupSubmitInfoMemory allocates memory for type C.VkDeviceGroupSubmitInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceGroupSubmitInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceGroupSubmitInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDeviceGroupSubmitInfoValue = unsafe.Sizeof([1]C.VkDeviceGroupSubmitInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DeviceGroupSubmitInfo) Ref() *C.VkDeviceGroupSubmitInfo {
	if x == nil {
		return nil
	}
	return x.refea4e7ce4
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DeviceGroupSubmitInfo) Free() {
	if x != nil && x.allocsea4e7ce4 != nil {
		x.allocsea4e7ce4.(*cgoAllocMap).Free()
		x.refea4e7ce4 = nil
	}
}

// NewDeviceGroupSubmitInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDeviceGroupSubmitInfoRef(ref unsafe.Pointer) *DeviceGroupSubmitInfo {
	if ref == nil {
		return nil
	}
	obj := new(DeviceGroupSubmitInfo)
	obj.refea4e7ce4 = (*C.VkDeviceGroupSubmitInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DeviceGroupSubmitInfo) PassRef() (*C.VkDeviceGroupSubmitInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refea4e7ce4 != nil {
		return x.refea4e7ce4, nil
	}
	memea4e7ce4 := allocDeviceGroupSubmitInfoMemory(1)
	refea4e7ce4 := (*C.VkDeviceGroupSubmitInfo)(memea4e7ce4)
	allocsea4e7ce4 := new(cgoAllocMap)
	allocsea4e7ce4.Add(memea4e7ce4)

	refea4e7ce4.sType = (C.VkStructureType)(x.SType)

	refea4e7ce4.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	refea4e7ce4.waitSemaphoreCount = (C.uint32_t)(x.WaitSemaphoreCount)

	if x.PWaitSemaphoreDeviceIndices != nil {
		var cpWaitSemaphoreDeviceIndices_allocs *cgoAllocMap
		refea4e7ce4.pWaitSemaphoreDeviceIndices, cpWaitSemaphoreDeviceIndices_allocs = copyPUint32_tBytes((*sliceHeader)(unsafe.Pointer(&x.PWaitSemaphoreDeviceIndices)))
		allocsea4e7ce4.Borrow(cpWaitSemaphoreDeviceIndices_allocs)
	}

	refea4e7ce4.commandBufferCount = (C.uint32_t)(x.CommandBufferCount)

	if x.PCommandBufferDeviceMasks != nil {
		var cpCommandBufferDeviceMasks_allocs *cgoAllocMap
		refea4e7ce4.pCommandBufferDeviceMasks, cpCommandBufferDeviceMasks_allocs = copyPUint32_tBytes((*sliceHeader)(unsafe.Pointer(&x.PCommandBufferDeviceMasks)))
		allocsea4e7ce4.Borrow(cpCommandBufferDeviceMasks_allocs)
	}

	refea4e7ce4.signalSemaphoreCount = (C.uint32_t)(x.SignalSemaphoreCount)

	if x.PSignalSemaphoreDeviceIndices != nil {
		var cpSignalSemaphoreDeviceIndices_allocs *cgoAllocMap
		refea4e7ce4.pSignalSemaphoreDeviceIndices, cpSignalSemaphoreDeviceIndices_allocs = copyPUint32_tBytes((*sliceHeader)(unsafe.Pointer(&x.PSignalSemaphoreDeviceIndices)))
		allocsea4e7ce4.Borrow(cpSignalSemaphoreDeviceIndices_allocs)
	}

	x.refea4e7ce4 = refea4e7ce4
	x.allocsea4e7ce4 = allocsea4e7ce4
	return refea4e7ce4, allocsea4e7ce4

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DeviceGroupSubmitInfo) PassValue() (C.VkDeviceGroupSubmitInfo, *cgoAllocMap) {
	if x.refea4e7ce4 != nil {
		return *x.refea4e7ce4, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DeviceGroupSubmitInfo) Deref() {
	if x.refea4e7ce4 == nil {
		return
	}
	x.SType = (StructureType)(x.refea4e7ce4.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refea4e7ce4.pNext))
	x.WaitSemaphoreCount = (uint32)(x.refea4e7ce4.waitSemaphoreCount)
	hxf8aebb5 := (*sliceHeader)(unsafe.Pointer(&x.PWaitSemaphoreDeviceIndices))
	hxf8aebb5.Data = unsafe.Pointer(x.refea4e7ce4.pWaitSemaphoreDeviceIndices)
	hxf8aebb5.Cap = 0x7fffffff
	// hxf8aebb5.Len = ? x.PWaitSemaphoreDeviceIndices x.refea4e7ce4.pWaitSemaphoreDeviceIndices

	x.CommandBufferCount = (uint32)(x.refea4e7ce4.commandBufferCount)
	hxf5d30cf := (*sliceHeader)(unsafe.Pointer(&x.PCommandBufferDeviceMasks))
	hxf5d30cf.Data = unsafe.Pointer(x.refea4e7ce4.pCommandBufferDeviceMasks)
	hxf5d30cf.Cap = 0x7fffffff
	// hxf5d30cf.Len = ? x.PCommandBufferDeviceMasks x.refea4e7ce4.pCommandBufferDeviceMasks

	x.SignalSemaphoreCount = (uint32)(x.refea4e7ce4.signalSemaphoreCount)
	hxf882e98 := (*sliceHeader)(unsafe.Pointer(&x.PSignalSemaphoreDeviceIndices))
	hxf882e98.Data = unsafe.Pointer(x.refea4e7ce4.pSignalSemaphoreDeviceIndices)
	hxf882e98.Cap = 0x7fffffff
	// hxf882e98.Len = ? x.PSignalSemaphoreDeviceIndices x.refea4e7ce4.pSignalSemaphoreDeviceIndices

}

// allocBindBufferMemoryDeviceGroupInfoMemory allocates memory for type C.VkBindBufferMemoryDeviceGroupInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBindBufferMemoryDeviceGroupInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBindBufferMemoryDeviceGroupInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBindBufferMemoryDeviceGroupInfoValue = unsafe.Sizeof([1]C.VkBindBufferMemoryDeviceGroupInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BindBufferMemoryDeviceGroupInfo) Ref() *C.VkBindBufferMemoryDeviceGroupInfo {
	if x == nil {
		return nil
	}
	return x.reff136b64f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BindBufferMemoryDeviceGroupInfo) Free() {
	if x != nil && x.allocsf136b64f != nil {
		x.allocsf136b64f.(*cgoAllocMap).Free()
		x.reff136b64f = nil
	}
}

// NewBindBufferMemoryDeviceGroupInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBindBufferMemoryDeviceGroupInfoRef(ref unsafe.Pointer) *BindBufferMemoryDeviceGroupInfo {
	if ref == nil {
		return nil
	}
	obj := new(BindBufferMemoryDeviceGroupInfo)
	obj.reff136b64f = (*C.VkBindBufferMemoryDeviceGroupInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BindBufferMemoryDeviceGroupInfo) PassRef() (*C.VkBindBufferMemoryDeviceGroupInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff136b64f != nil {
		return x.reff136b64f, nil
	}
	memf136b64f := allocBindBufferMemoryDeviceGroupInfoMemory(1)
	reff136b64f := (*C.VkBindBufferMemoryDeviceGroupInfo)(memf136b64f)
	allocsf136b64f := new(cgoAllocMap)
	allocsf136b64f.Add(memf136b64f)

	reff136b64f.sType = (C.VkStructureType)(x.SType)

	reff136b64f.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	reff136b64f.deviceIndexCount = (C.uint32_t)(x.DeviceIndexCount)

	if x.PDeviceIndices != nil {
		var cpDeviceIndices_allocs *cgoAllocMap
		reff136b64f.pDeviceIndices, cpDeviceIndices_allocs = copyPUint32_tBytes((*sliceHeader)(unsafe.Pointer(&x.PDeviceIndices)))
		allocsf136b64f.Borrow(cpDeviceIndices_allocs)
	}

	x.reff136b64f = reff136b64f
	x.allocsf136b64f = allocsf136b64f
	return reff136b64f, allocsf136b64f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BindBufferMemoryDeviceGroupInfo) PassValue() (C.VkBindBufferMemoryDeviceGroupInfo, *cgoAllocMap) {
	if x.reff136b64f != nil {
		return *x.reff136b64f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BindBufferMemoryDeviceGroupInfo) Deref() {
	if x.reff136b64f == nil {
		return
	}
	x.SType = (StructureType)(x.reff136b64f.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.reff136b64f.pNext))
	x.DeviceIndexCount = (uint32)(x.reff136b64f.deviceIndexCount)
	hxf992404 := (*sliceHeader)(unsafe.Pointer(&x.PDeviceIndices))
	hxf992404.Data = unsafe.Pointer(x.reff136b64f.pDeviceIndices)
	hxf992404.Cap = 0x7fffffff
	// hxf992404.Len = ? x.PDeviceIndices x.reff136b64f.pDeviceIndices

}

// allocBindImageMemoryDeviceGroupInfoMemory allocates memory for type C.VkBindImageMemoryDeviceGroupInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBindImageMemoryDeviceGroupInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBindImageMemoryDeviceGroupInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBindImageMemoryDeviceGroupInfoValue = unsafe.Sizeof([1]C.VkBindImageMemoryDeviceGroupInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BindImageMemoryDeviceGroupInfo) Ref() *C.VkBindImageMemoryDeviceGroupInfo {
	if x == nil {
		return nil
	}
	return x.ref24f026a5
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BindImageMemoryDeviceGroupInfo) Free() {
	if x != nil && x.allocs24f026a5 != nil {
		x.allocs24f026a5.(*cgoAllocMap).Free()
		x.ref24f026a5 = nil
	}
}

// NewBindImageMemoryDeviceGroupInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBindImageMemoryDeviceGroupInfoRef(ref unsafe.Pointer) *BindImageMemoryDeviceGroupInfo {
	if ref == nil {
		return nil
	}
	obj := new(BindImageMemoryDeviceGroupInfo)
	obj.ref24f026a5 = (*C.VkBindImageMemoryDeviceGroupInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BindImageMemoryDeviceGroupInfo) PassRef() (*C.VkBindImageMemoryDeviceGroupInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref24f026a5 != nil {
		return x.ref24f026a5, nil
	}
	mem24f026a5 := allocBindImageMemoryDeviceGroupInfoMemory(1)
	ref24f026a5 := (*C.VkBindImageMemoryDeviceGroupInfo)(mem24f026a5)
	allocs24f026a5 := new(cgoAllocMap)
	allocs24f026a5.Add(mem24f026a5)

	ref24f026a5.sType = (C.VkStructureType)(x.SType)

	ref24f026a5.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref24f026a5.deviceIndexCount = (C.uint32_t)(x.DeviceIndexCount)

	if x.PDeviceIndices != nil {
		var cpDeviceIndices_allocs *cgoAllocMap
		ref24f026a5.pDeviceIndices, cpDeviceIndices_allocs = copyPUint32_tBytes((*sliceHeader)(unsafe.Pointer(&x.PDeviceIndices)))
		allocs24f026a5.Borrow(cpDeviceIndices_allocs)
	}

	ref24f026a5.splitInstanceBindRegionCount = (C.uint32_t)(x.SplitInstanceBindRegionCount)

	if x.PSplitInstanceBindRegions != nil {
		var cpSplitInstanceBindRegions_allocs *cgoAllocMap
		ref24f026a5.pSplitInstanceBindRegions, cpSplitInstanceBindRegions_allocs = copyPRect2DBytes((*sliceHeader)(unsafe.Pointer(&x.PSplitInstanceBindRegions)))
		allocs24f026a5.Borrow(cpSplitInstanceBindRegions_allocs)
	}

	x.ref24f026a5 = ref24f026a5
	x.allocs24f026a5 = allocs24f026a5
	return ref24f026a5, allocs24f026a5

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BindImageMemoryDeviceGroupInfo) PassValue() (C.VkBindImageMemoryDeviceGroupInfo, *cgoAllocMap) {
	if x.ref24f026a5 != nil {
		return *x.ref24f026a5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BindImageMemoryDeviceGroupInfo) Deref() {
	if x.ref24f026a5 == nil {
		return
	}
	x.SType = (StructureType)(x.ref24f026a5.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref24f026a5.pNext))
	x.DeviceIndexCount = (uint32)(x.ref24f026a5.deviceIndexCount)
	hxf8e0dd2 := (*sliceHeader)(unsafe.Pointer(&x.PDeviceIndices))
	hxf8e0dd2.Data = unsafe.Pointer(x.ref24f026a5.pDeviceIndices)
	hxf8e0dd2.Cap = 0x7fffffff
	// hxf8e0dd2.Len = ? x.PDeviceIndices x.ref24f026a5.pDeviceIndices

	x.SplitInstanceBindRegionCount = (uint32)(x.ref24f026a5.splitInstanceBindRegionCount)
	hxf44d909 := (*sliceHeader)(unsafe.Pointer(&x.PSplitInstanceBindRegions))
	hxf44d909.Data = unsafe.Pointer(x.ref24f026a5.pSplitInstanceBindRegions)
	hxf44d909.Cap = 0x7fffffff
	// hxf44d909.Len = ? x.PSplitInstanceBindRegions x.ref24f026a5.pSplitInstanceBindRegions

}

// allocPhysicalDeviceGroupPropertiesMemory allocates memory for type C.VkPhysicalDeviceGroupProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceGroupPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceGroupPropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceGroupPropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceGroupProperties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceGroupProperties) Ref() *C.VkPhysicalDeviceGroupProperties {
	if x == nil {
		return nil
	}
	return x.ref2aa9a663
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceGroupProperties) Free() {
	if x != nil && x.allocs2aa9a663 != nil {
		x.allocs2aa9a663.(*cgoAllocMap).Free()
		x.ref2aa9a663 = nil
	}
}

// NewPhysicalDeviceGroupPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceGroupPropertiesRef(ref unsafe.Pointer) *PhysicalDeviceGroupProperties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceGroupProperties)
	obj.ref2aa9a663 = (*C.VkPhysicalDeviceGroupProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceGroupProperties) PassRef() (*C.VkPhysicalDeviceGroupProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2aa9a663 != nil {
		return x.ref2aa9a663, nil
	}
	mem2aa9a663 := allocPhysicalDeviceGroupPropertiesMemory(1)
	ref2aa9a663 := (*C.VkPhysicalDeviceGroupProperties)(mem2aa9a663)
	allocs2aa9a663 := new(cgoAllocMap)
	allocs2aa9a663.Add(mem2aa9a663)

	ref2aa9a663.sType = (C.VkStructureType)(x.SType)

	ref2aa9a663.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref2aa9a663.physicalDeviceCount = (C.uint32_t)(x.PhysicalDeviceCount)

	ref2aa9a663.physicalDevices = *(*[32]C.VkPhysicalDevice)(unsafe.Pointer(&x.PhysicalDevices))

	ref2aa9a663.subsetAllocation = (C.VkBool32)(x.SubsetAllocation)

	x.ref2aa9a663 = ref2aa9a663
	x.allocs2aa9a663 = allocs2aa9a663
	return ref2aa9a663, allocs2aa9a663

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceGroupProperties) PassValue() (C.VkPhysicalDeviceGroupProperties, *cgoAllocMap) {
	if x.ref2aa9a663 != nil {
		return *x.ref2aa9a663, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceGroupProperties) Deref() {
	if x.ref2aa9a663 == nil {
		return
	}
	x.SType = (StructureType)(x.ref2aa9a663.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref2aa9a663.pNext))
	x.PhysicalDeviceCount = (uint32)(x.ref2aa9a663.physicalDeviceCount)
	x.PhysicalDevices = *(*[32]PhysicalDevice)(unsafe.Pointer(&x.ref2aa9a663.physicalDevices))
	x.SubsetAllocation = (Bool32)(x.ref2aa9a663.subsetAllocation)
}

// allocDeviceGroupDeviceCreateInfoMemory allocates memory for type C.VkDeviceGroupDeviceCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceGroupDeviceCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceGroupDeviceCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDeviceGroupDeviceCreateInfoValue = unsafe.Sizeof([1]C.VkDeviceGroupDeviceCreateInfo{})

// copyPPhysicalDeviceBytes copies the data from Go slice as *C.VkPhysicalDevice.
func copyPPhysicalDeviceBytes(slice *sliceHeader) (*C.VkPhysicalDevice, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfPhysicalDeviceValue) * slice.Len,
		Cap:  int(sizeOfPhysicalDeviceValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkPhysicalDevice)(mem0), allocs
}

// allocPhysicalDeviceMemory allocates memory for type C.VkPhysicalDevice in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceValue = unsafe.Sizeof([1]C.VkPhysicalDevice{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DeviceGroupDeviceCreateInfo) Ref() *C.VkDeviceGroupDeviceCreateInfo {
	if x == nil {
		return nil
	}
	return x.refb2275723
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DeviceGroupDeviceCreateInfo) Free() {
	if x != nil && x.allocsb2275723 != nil {
		x.allocsb2275723.(*cgoAllocMap).Free()
		x.refb2275723 = nil
	}
}

// NewDeviceGroupDeviceCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDeviceGroupDeviceCreateInfoRef(ref unsafe.Pointer) *DeviceGroupDeviceCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(DeviceGroupDeviceCreateInfo)
	obj.refb2275723 = (*C.VkDeviceGroupDeviceCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DeviceGroupDeviceCreateInfo) PassRef() (*C.VkDeviceGroupDeviceCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb2275723 != nil {
		return x.refb2275723, nil
	}
	memb2275723 := allocDeviceGroupDeviceCreateInfoMemory(1)
	refb2275723 := (*C.VkDeviceGroupDeviceCreateInfo)(memb2275723)
	allocsb2275723 := new(cgoAllocMap)
	allocsb2275723.Add(memb2275723)

	refb2275723.sType = (C.VkStructureType)(x.SType)

	refb2275723.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	refb2275723.physicalDeviceCount = (C.uint32_t)(x.PhysicalDeviceCount)

	if x.PPhysicalDevices != nil {
		var cpPhysicalDevices_allocs *cgoAllocMap
		refb2275723.pPhysicalDevices, cpPhysicalDevices_allocs = copyPPhysicalDeviceBytes((*sliceHeader)(unsafe.Pointer(&x.PPhysicalDevices)))
		allocsb2275723.Borrow(cpPhysicalDevices_allocs)
	}

	x.refb2275723 = refb2275723
	x.allocsb2275723 = allocsb2275723
	return refb2275723, allocsb2275723

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DeviceGroupDeviceCreateInfo) PassValue() (C.VkDeviceGroupDeviceCreateInfo, *cgoAllocMap) {
	if x.refb2275723 != nil {
		return *x.refb2275723, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DeviceGroupDeviceCreateInfo) Deref() {
	if x.refb2275723 == nil {
		return
	}
	x.SType = (StructureType)(x.refb2275723.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refb2275723.pNext))
	x.PhysicalDeviceCount = (uint32)(x.refb2275723.physicalDeviceCount)
	hxfa835e7 := (*sliceHeader)(unsafe.Pointer(&x.PPhysicalDevices))
	hxfa835e7.Data = unsafe.Pointer(x.refb2275723.pPhysicalDevices)
	hxfa835e7.Cap = 0x7fffffff
	// hxfa835e7.Len = ? x.PPhysicalDevices x.refb2275723.pPhysicalDevices

}

// allocBufferMemoryRequirementsInfo2Memory allocates memory for type C.VkBufferMemoryRequirementsInfo2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBufferMemoryRequirementsInfo2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBufferMemoryRequirementsInfo2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBufferMemoryRequirementsInfo2Value = unsafe.Sizeof([1]C.VkBufferMemoryRequirementsInfo2{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BufferMemoryRequirementsInfo2) Ref() *C.VkBufferMemoryRequirementsInfo2 {
	if x == nil {
		return nil
	}
	return x.reff54a2a42
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BufferMemoryRequirementsInfo2) Free() {
	if x != nil && x.allocsf54a2a42 != nil {
		x.allocsf54a2a42.(*cgoAllocMap).Free()
		x.reff54a2a42 = nil
	}
}

// NewBufferMemoryRequirementsInfo2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBufferMemoryRequirementsInfo2Ref(ref unsafe.Pointer) *BufferMemoryRequirementsInfo2 {
	if ref == nil {
		return nil
	}
	obj := new(BufferMemoryRequirementsInfo2)
	obj.reff54a2a42 = (*C.VkBufferMemoryRequirementsInfo2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BufferMemoryRequirementsInfo2) PassRef() (*C.VkBufferMemoryRequirementsInfo2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff54a2a42 != nil {
		return x.reff54a2a42, nil
	}
	memf54a2a42 := allocBufferMemoryRequirementsInfo2Memory(1)
	reff54a2a42 := (*C.VkBufferMemoryRequirementsInfo2)(memf54a2a42)
	allocsf54a2a42 := new(cgoAllocMap)
	allocsf54a2a42.Add(memf54a2a42)

	reff54a2a42.sType = (C.VkStructureType)(x.SType)

	reff54a2a42.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	reff54a2a42.buffer = *(*C.VkBuffer)(unsafe.Pointer(&x.Buffer))

	x.reff54a2a42 = reff54a2a42
	x.allocsf54a2a42 = allocsf54a2a42
	return reff54a2a42, allocsf54a2a42

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BufferMemoryRequirementsInfo2) PassValue() (C.VkBufferMemoryRequirementsInfo2, *cgoAllocMap) {
	if x.reff54a2a42 != nil {
		return *x.reff54a2a42, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BufferMemoryRequirementsInfo2) Deref() {
	if x.reff54a2a42 == nil {
		return
	}
	x.SType = (StructureType)(x.reff54a2a42.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.reff54a2a42.pNext))
	x.Buffer = *(*Buffer)(unsafe.Pointer(&x.reff54a2a42.buffer))
}

// allocImageMemoryRequirementsInfo2Memory allocates memory for type C.VkImageMemoryRequirementsInfo2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageMemoryRequirementsInfo2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageMemoryRequirementsInfo2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfImageMemoryRequirementsInfo2Value = unsafe.Sizeof([1]C.VkImageMemoryRequirementsInfo2{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImageMemoryRequirementsInfo2) Ref() *C.VkImageMemoryRequirementsInfo2 {
	if x == nil {
		return nil
	}
	return x.ref75b3ca05
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImageMemoryRequirementsInfo2) Free() {
	if x != nil && x.allocs75b3ca05 != nil {
		x.allocs75b3ca05.(*cgoAllocMap).Free()
		x.ref75b3ca05 = nil
	}
}

// NewImageMemoryRequirementsInfo2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageMemoryRequirementsInfo2Ref(ref unsafe.Pointer) *ImageMemoryRequirementsInfo2 {
	if ref == nil {
		return nil
	}
	obj := new(ImageMemoryRequirementsInfo2)
	obj.ref75b3ca05 = (*C.VkImageMemoryRequirementsInfo2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImageMemoryRequirementsInfo2) PassRef() (*C.VkImageMemoryRequirementsInfo2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref75b3ca05 != nil {
		return x.ref75b3ca05, nil
	}
	mem75b3ca05 := allocImageMemoryRequirementsInfo2Memory(1)
	ref75b3ca05 := (*C.VkImageMemoryRequirementsInfo2)(mem75b3ca05)
	allocs75b3ca05 := new(cgoAllocMap)
	allocs75b3ca05.Add(mem75b3ca05)

	ref75b3ca05.sType = (C.VkStructureType)(x.SType)

	ref75b3ca05.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref75b3ca05.image = *(*C.VkImage)(unsafe.Pointer(&x.Image))

	x.ref75b3ca05 = ref75b3ca05
	x.allocs75b3ca05 = allocs75b3ca05
	return ref75b3ca05, allocs75b3ca05

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImageMemoryRequirementsInfo2) PassValue() (C.VkImageMemoryRequirementsInfo2, *cgoAllocMap) {
	if x.ref75b3ca05 != nil {
		return *x.ref75b3ca05, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImageMemoryRequirementsInfo2) Deref() {
	if x.ref75b3ca05 == nil {
		return
	}
	x.SType = (StructureType)(x.ref75b3ca05.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref75b3ca05.pNext))
	x.Image = *(*Image)(unsafe.Pointer(&x.ref75b3ca05.image))
}

// allocImageSparseMemoryRequirementsInfo2Memory allocates memory for type C.VkImageSparseMemoryRequirementsInfo2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageSparseMemoryRequirementsInfo2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageSparseMemoryRequirementsInfo2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfImageSparseMemoryRequirementsInfo2Value = unsafe.Sizeof([1]C.VkImageSparseMemoryRequirementsInfo2{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImageSparseMemoryRequirementsInfo2) Ref() *C.VkImageSparseMemoryRequirementsInfo2 {
	if x == nil {
		return nil
	}
	return x.ref878956f7
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImageSparseMemoryRequirementsInfo2) Free() {
	if x != nil && x.allocs878956f7 != nil {
		x.allocs878956f7.(*cgoAllocMap).Free()
		x.ref878956f7 = nil
	}
}

// NewImageSparseMemoryRequirementsInfo2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageSparseMemoryRequirementsInfo2Ref(ref unsafe.Pointer) *ImageSparseMemoryRequirementsInfo2 {
	if ref == nil {
		return nil
	}
	obj := new(ImageSparseMemoryRequirementsInfo2)
	obj.ref878956f7 = (*C.VkImageSparseMemoryRequirementsInfo2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImageSparseMemoryRequirementsInfo2) PassRef() (*C.VkImageSparseMemoryRequirementsInfo2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref878956f7 != nil {
		return x.ref878956f7, nil
	}
	mem878956f7 := allocImageSparseMemoryRequirementsInfo2Memory(1)
	ref878956f7 := (*C.VkImageSparseMemoryRequirementsInfo2)(mem878956f7)
	allocs878956f7 := new(cgoAllocMap)
	allocs878956f7.Add(mem878956f7)

	ref878956f7.sType = (C.VkStructureType)(x.SType)

	ref878956f7.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref878956f7.image = *(*C.VkImage)(unsafe.Pointer(&x.Image))

	x.ref878956f7 = ref878956f7
	x.allocs878956f7 = allocs878956f7
	return ref878956f7, allocs878956f7

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImageSparseMemoryRequirementsInfo2) PassValue() (C.VkImageSparseMemoryRequirementsInfo2, *cgoAllocMap) {
	if x.ref878956f7 != nil {
		return *x.ref878956f7, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImageSparseMemoryRequirementsInfo2) Deref() {
	if x.ref878956f7 == nil {
		return
	}
	x.SType = (StructureType)(x.ref878956f7.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref878956f7.pNext))
	x.Image = *(*Image)(unsafe.Pointer(&x.ref878956f7.image))
}

// allocPhysicalDeviceProperties2Memory allocates memory for type C.VkPhysicalDeviceProperties2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceProperties2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceProperties2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceProperties2Value = unsafe.Sizeof([1]C.VkPhysicalDeviceProperties2{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceProperties2) Ref() *C.VkPhysicalDeviceProperties2 {
	if x == nil {
		return nil
	}
	return x.ref947bd13e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceProperties2) Free() {
	if x != nil && x.allocs947bd13e != nil {
		x.allocs947bd13e.(*cgoAllocMap).Free()
		x.ref947bd13e = nil
	}
}

// NewPhysicalDeviceProperties2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceProperties2Ref(ref unsafe.Pointer) *PhysicalDeviceProperties2 {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceProperties2)
	obj.ref947bd13e = (*C.VkPhysicalDeviceProperties2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceProperties2) PassRef() (*C.VkPhysicalDeviceProperties2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref947bd13e != nil {
		return x.ref947bd13e, nil
	}
	mem947bd13e := allocPhysicalDeviceProperties2Memory(1)
	ref947bd13e := (*C.VkPhysicalDeviceProperties2)(mem947bd13e)
	allocs947bd13e := new(cgoAllocMap)
	allocs947bd13e.Add(mem947bd13e)

	ref947bd13e.sType = (C.VkStructureType)(x.SType)

	ref947bd13e.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	var cproperties_allocs *cgoAllocMap
	ref947bd13e.properties, cproperties_allocs = x.Properties.PassValue()
	allocs947bd13e.Borrow(cproperties_allocs)

	x.ref947bd13e = ref947bd13e
	x.allocs947bd13e = allocs947bd13e
	return ref947bd13e, allocs947bd13e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceProperties2) PassValue() (C.VkPhysicalDeviceProperties2, *cgoAllocMap) {
	if x.ref947bd13e != nil {
		return *x.ref947bd13e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceProperties2) Deref() {
	if x.ref947bd13e == nil {
		return
	}
	x.SType = (StructureType)(x.ref947bd13e.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref947bd13e.pNext))
	x.Properties = *NewPhysicalDevicePropertiesRef(unsafe.Pointer(&x.ref947bd13e.properties))
}

// allocRenderPassInputAttachmentAspectCreateInfoMemory allocates memory for type C.VkRenderPassInputAttachmentAspectCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRenderPassInputAttachmentAspectCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRenderPassInputAttachmentAspectCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfRenderPassInputAttachmentAspectCreateInfoValue = unsafe.Sizeof([1]C.VkRenderPassInputAttachmentAspectCreateInfo{})

// copyPInputAttachmentAspectReferenceBytes copies the data from Go slice as *C.VkInputAttachmentAspectReference.
func copyPInputAttachmentAspectReferenceBytes(slice *sliceHeader) (*C.VkInputAttachmentAspectReference, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfInputAttachmentAspectReferenceValue) * slice.Len,
		Cap:  int(sizeOfInputAttachmentAspectReferenceValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkInputAttachmentAspectReference)(mem0), allocs
}

// allocInputAttachmentAspectReferenceMemory allocates memory for type C.VkInputAttachmentAspectReference in C.
// The caller is responsible for freeing the this memory via C.free.
func allocInputAttachmentAspectReferenceMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfInputAttachmentAspectReferenceValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfInputAttachmentAspectReferenceValue = unsafe.Sizeof([1]C.VkInputAttachmentAspectReference{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RenderPassInputAttachmentAspectCreateInfo) Ref() *C.VkRenderPassInputAttachmentAspectCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref34eaa5c7
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RenderPassInputAttachmentAspectCreateInfo) Free() {
	if x != nil && x.allocs34eaa5c7 != nil {
		x.allocs34eaa5c7.(*cgoAllocMap).Free()
		x.ref34eaa5c7 = nil
	}
}

// NewRenderPassInputAttachmentAspectCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRenderPassInputAttachmentAspectCreateInfoRef(ref unsafe.Pointer) *RenderPassInputAttachmentAspectCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(RenderPassInputAttachmentAspectCreateInfo)
	obj.ref34eaa5c7 = (*C.VkRenderPassInputAttachmentAspectCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RenderPassInputAttachmentAspectCreateInfo) PassRef() (*C.VkRenderPassInputAttachmentAspectCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref34eaa5c7 != nil {
		return x.ref34eaa5c7, nil
	}
	mem34eaa5c7 := allocRenderPassInputAttachmentAspectCreateInfoMemory(1)
	ref34eaa5c7 := (*C.VkRenderPassInputAttachmentAspectCreateInfo)(mem34eaa5c7)
	allocs34eaa5c7 := new(cgoAllocMap)
	allocs34eaa5c7.Add(mem34eaa5c7)

	ref34eaa5c7.sType = (C.VkStructureType)(x.SType)

	ref34eaa5c7.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref34eaa5c7.aspectReferenceCount = (C.uint32_t)(x.AspectReferenceCount)

	if x.PAspectReferences != nil {
		var cpAspectReferences_allocs *cgoAllocMap
		ref34eaa5c7.pAspectReferences, cpAspectReferences_allocs = copyPInputAttachmentAspectReferenceBytes((*sliceHeader)(unsafe.Pointer(&x.PAspectReferences)))
		allocs34eaa5c7.Borrow(cpAspectReferences_allocs)
	}

	x.ref34eaa5c7 = ref34eaa5c7
	x.allocs34eaa5c7 = allocs34eaa5c7
	return ref34eaa5c7, allocs34eaa5c7

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RenderPassInputAttachmentAspectCreateInfo) PassValue() (C.VkRenderPassInputAttachmentAspectCreateInfo, *cgoAllocMap) {
	if x.ref34eaa5c7 != nil {
		return *x.ref34eaa5c7, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *RenderPassInputAttachmentAspectCreateInfo) Deref() {
	if x.ref34eaa5c7 == nil {
		return
	}
	x.SType = (StructureType)(x.ref34eaa5c7.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref34eaa5c7.pNext))
	x.AspectReferenceCount = (uint32)(x.ref34eaa5c7.aspectReferenceCount)
	hxf8eae10 := (*sliceHeader)(unsafe.Pointer(&x.PAspectReferences))
	hxf8eae10.Data = unsafe.Pointer(x.ref34eaa5c7.pAspectReferences)
	hxf8eae10.Cap = 0x7fffffff
	// hxf8eae10.Len = ? x.PAspectReferences x.ref34eaa5c7.pAspectReferences

}

// allocRenderPassMultiviewCreateInfoMemory allocates memory for type C.VkRenderPassMultiviewCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRenderPassMultiviewCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRenderPassMultiviewCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfRenderPassMultiviewCreateInfoValue = unsafe.Sizeof([1]C.VkRenderPassMultiviewCreateInfo{})

// copyPInt32_tBytes copies the data from Go slice as *C.int32_t.
func copyPInt32_tBytes(slice *sliceHeader) (*C.int32_t, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfInt32_tValue) * slice.Len,
		Cap:  int(sizeOfInt32_tValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.int32_t)(mem0), allocs
}

// allocInt32_tMemory allocates memory for type C.int32_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocInt32_tMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfInt32_tValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfInt32_tValue = unsafe.Sizeof([1]C.int32_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RenderPassMultiviewCreateInfo) Ref() *C.VkRenderPassMultiviewCreateInfo {
	if x == nil {
		return nil
	}
	return x.refee413e05
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RenderPassMultiviewCreateInfo) Free() {
	if x != nil && x.allocsee413e05 != nil {
		x.allocsee413e05.(*cgoAllocMap).Free()
		x.refee413e05 = nil
	}
}

// NewRenderPassMultiviewCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRenderPassMultiviewCreateInfoRef(ref unsafe.Pointer) *RenderPassMultiviewCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(RenderPassMultiviewCreateInfo)
	obj.refee413e05 = (*C.VkRenderPassMultiviewCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RenderPassMultiviewCreateInfo) PassRef() (*C.VkRenderPassMultiviewCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refee413e05 != nil {
		return x.refee413e05, nil
	}
	memee413e05 := allocRenderPassMultiviewCreateInfoMemory(1)
	refee413e05 := (*C.VkRenderPassMultiviewCreateInfo)(memee413e05)
	allocsee413e05 := new(cgoAllocMap)
	allocsee413e05.Add(memee413e05)

	refee413e05.sType = (C.VkStructureType)(x.SType)

	refee413e05.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	refee413e05.subpassCount = (C.uint32_t)(x.SubpassCount)

	if x.PViewMasks != nil {
		var cpViewMasks_allocs *cgoAllocMap
		refee413e05.pViewMasks, cpViewMasks_allocs = copyPUint32_tBytes((*sliceHeader)(unsafe.Pointer(&x.PViewMasks)))
		allocsee413e05.Borrow(cpViewMasks_allocs)
	}

	refee413e05.dependencyCount = (C.uint32_t)(x.DependencyCount)

	if x.PViewOffsets != nil {
		var cpViewOffsets_allocs *cgoAllocMap
		refee413e05.pViewOffsets, cpViewOffsets_allocs = copyPInt32_tBytes((*sliceHeader)(unsafe.Pointer(&x.PViewOffsets)))
		allocsee413e05.Borrow(cpViewOffsets_allocs)
	}

	refee413e05.correlationMaskCount = (C.uint32_t)(x.CorrelationMaskCount)

	if x.PCorrelationMasks != nil {
		var cpCorrelationMasks_allocs *cgoAllocMap
		refee413e05.pCorrelationMasks, cpCorrelationMasks_allocs = copyPUint32_tBytes((*sliceHeader)(unsafe.Pointer(&x.PCorrelationMasks)))
		allocsee413e05.Borrow(cpCorrelationMasks_allocs)
	}

	x.refee413e05 = refee413e05
	x.allocsee413e05 = allocsee413e05
	return refee413e05, allocsee413e05

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RenderPassMultiviewCreateInfo) PassValue() (C.VkRenderPassMultiviewCreateInfo, *cgoAllocMap) {
	if x.refee413e05 != nil {
		return *x.refee413e05, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *RenderPassMultiviewCreateInfo) Deref() {
	if x.refee413e05 == nil {
		return
	}
	x.SType = (StructureType)(x.refee413e05.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refee413e05.pNext))
	x.SubpassCount = (uint32)(x.refee413e05.subpassCount)
	hxfeb55cf := (*sliceHeader)(unsafe.Pointer(&x.PViewMasks))
	hxfeb55cf.Data = unsafe.Pointer(x.refee413e05.pViewMasks)
	hxfeb55cf.Cap = 0x7fffffff
	// hxfeb55cf.Len = ? x.PViewMasks x.refee413e05.pViewMasks

	x.DependencyCount = (uint32)(x.refee413e05.dependencyCount)
	hxf458096 := (*sliceHeader)(unsafe.Pointer(&x.PViewOffsets))
	hxf458096.Data = unsafe.Pointer(x.refee413e05.pViewOffsets)
	hxf458096.Cap = 0x7fffffff
	// hxf458096.Len = ? x.PViewOffsets x.refee413e05.pViewOffsets

	x.CorrelationMaskCount = (uint32)(x.refee413e05.correlationMaskCount)
	hxf9aab83 := (*sliceHeader)(unsafe.Pointer(&x.PCorrelationMasks))
	hxf9aab83.Data = unsafe.Pointer(x.refee413e05.pCorrelationMasks)
	hxf9aab83.Cap = 0x7fffffff
	// hxf9aab83.Len = ? x.PCorrelationMasks x.refee413e05.pCorrelationMasks

}

// allocSamplerYcbcrConversionInfoMemory allocates memory for type C.VkSamplerYcbcrConversionInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSamplerYcbcrConversionInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSamplerYcbcrConversionInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSamplerYcbcrConversionInfoValue = unsafe.Sizeof([1]C.VkSamplerYcbcrConversionInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SamplerYcbcrConversionInfo) Ref() *C.VkSamplerYcbcrConversionInfo {
	if x == nil {
		return nil
	}
	return x.ref11ff5547
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SamplerYcbcrConversionInfo) Free() {
	if x != nil && x.allocs11ff5547 != nil {
		x.allocs11ff5547.(*cgoAllocMap).Free()
		x.ref11ff5547 = nil
	}
}

// NewSamplerYcbcrConversionInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSamplerYcbcrConversionInfoRef(ref unsafe.Pointer) *SamplerYcbcrConversionInfo {
	if ref == nil {
		return nil
	}
	obj := new(SamplerYcbcrConversionInfo)
	obj.ref11ff5547 = (*C.VkSamplerYcbcrConversionInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SamplerYcbcrConversionInfo) PassRef() (*C.VkSamplerYcbcrConversionInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref11ff5547 != nil {
		return x.ref11ff5547, nil
	}
	mem11ff5547 := allocSamplerYcbcrConversionInfoMemory(1)
	ref11ff5547 := (*C.VkSamplerYcbcrConversionInfo)(mem11ff5547)
	allocs11ff5547 := new(cgoAllocMap)
	allocs11ff5547.Add(mem11ff5547)

	ref11ff5547.sType = (C.VkStructureType)(x.SType)

	ref11ff5547.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref11ff5547.conversion = *(*C.VkSamplerYcbcrConversion)(unsafe.Pointer(&x.Conversion))

	x.ref11ff5547 = ref11ff5547
	x.allocs11ff5547 = allocs11ff5547
	return ref11ff5547, allocs11ff5547

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SamplerYcbcrConversionInfo) PassValue() (C.VkSamplerYcbcrConversionInfo, *cgoAllocMap) {
	if x.ref11ff5547 != nil {
		return *x.ref11ff5547, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SamplerYcbcrConversionInfo) Deref() {
	if x.ref11ff5547 == nil {
		return
	}
	x.SType = (StructureType)(x.ref11ff5547.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref11ff5547.pNext))
	x.Conversion = *(*SamplerYcbcrConversion)(unsafe.Pointer(&x.ref11ff5547.conversion))
}

// allocDescriptorUpdateTemplateCreateInfoMemory allocates memory for type C.VkDescriptorUpdateTemplateCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDescriptorUpdateTemplateCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDescriptorUpdateTemplateCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDescriptorUpdateTemplateCreateInfoValue = unsafe.Sizeof([1]C.VkDescriptorUpdateTemplateCreateInfo{})

// copyPDescriptorUpdateTemplateEntryBytes copies the data from Go slice as *C.VkDescriptorUpdateTemplateEntry.
func copyPDescriptorUpdateTemplateEntryBytes(slice *sliceHeader) (*C.VkDescriptorUpdateTemplateEntry, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfDescriptorUpdateTemplateEntryValue) * slice.Len,
		Cap:  int(sizeOfDescriptorUpdateTemplateEntryValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkDescriptorUpdateTemplateEntry)(mem0), allocs
}

// allocDescriptorUpdateTemplateEntryMemory allocates memory for type C.VkDescriptorUpdateTemplateEntry in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDescriptorUpdateTemplateEntryMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDescriptorUpdateTemplateEntryValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDescriptorUpdateTemplateEntryValue = unsafe.Sizeof([1]C.VkDescriptorUpdateTemplateEntry{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DescriptorUpdateTemplateCreateInfo) Ref() *C.VkDescriptorUpdateTemplateCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref2af95951
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DescriptorUpdateTemplateCreateInfo) Free() {
	if x != nil && x.allocs2af95951 != nil {
		x.allocs2af95951.(*cgoAllocMap).Free()
		x.ref2af95951 = nil
	}
}

// NewDescriptorUpdateTemplateCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDescriptorUpdateTemplateCreateInfoRef(ref unsafe.Pointer) *DescriptorUpdateTemplateCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(DescriptorUpdateTemplateCreateInfo)
	obj.ref2af95951 = (*C.VkDescriptorUpdateTemplateCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DescriptorUpdateTemplateCreateInfo) PassRef() (*C.VkDescriptorUpdateTemplateCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2af95951 != nil {
		return x.ref2af95951, nil
	}
	mem2af95951 := allocDescriptorUpdateTemplateCreateInfoMemory(1)
	ref2af95951 := (*C.VkDescriptorUpdateTemplateCreateInfo)(mem2af95951)
	allocs2af95951 := new(cgoAllocMap)
	allocs2af95951.Add(mem2af95951)

	ref2af95951.sType = (C.VkStructureType)(x.SType)

	ref2af95951.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref2af95951.flags = (C.VkDescriptorUpdateTemplateCreateFlags)(x.Flags)

	ref2af95951.descriptorUpdateEntryCount = (C.uint32_t)(x.DescriptorUpdateEntryCount)

	if x.PDescriptorUpdateEntries != nil {
		var cpDescriptorUpdateEntries_allocs *cgoAllocMap
		ref2af95951.pDescriptorUpdateEntries, cpDescriptorUpdateEntries_allocs = copyPDescriptorUpdateTemplateEntryBytes((*sliceHeader)(unsafe.Pointer(&x.PDescriptorUpdateEntries)))
		allocs2af95951.Borrow(cpDescriptorUpdateEntries_allocs)
	}

	ref2af95951.templateType = (C.VkDescriptorUpdateTemplateType)(x.TemplateType)

	ref2af95951.descriptorSetLayout = *(*C.VkDescriptorSetLayout)(unsafe.Pointer(&x.DescriptorSetLayout))

	ref2af95951.pipelineBindPoint = (C.VkPipelineBindPoint)(x.PipelineBindPoint)

	ref2af95951.pipelineLayout = *(*C.VkPipelineLayout)(unsafe.Pointer(&x.PipelineLayout))

	ref2af95951.set = (C.uint32_t)(x.Set)

	x.ref2af95951 = ref2af95951
	x.allocs2af95951 = allocs2af95951
	return ref2af95951, allocs2af95951

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DescriptorUpdateTemplateCreateInfo) PassValue() (C.VkDescriptorUpdateTemplateCreateInfo, *cgoAllocMap) {
	if x.ref2af95951 != nil {
		return *x.ref2af95951, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DescriptorUpdateTemplateCreateInfo) Deref() {
	if x.ref2af95951 == nil {
		return
	}
	x.SType = (StructureType)(x.ref2af95951.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref2af95951.pNext))
	x.Flags = (DescriptorUpdateTemplateCreateFlags)(x.ref2af95951.flags)
	x.DescriptorUpdateEntryCount = (uint32)(x.ref2af95951.descriptorUpdateEntryCount)
	hxf8b35a8 := (*sliceHeader)(unsafe.Pointer(&x.PDescriptorUpdateEntries))
	hxf8b35a8.Data = unsafe.Pointer(x.ref2af95951.pDescriptorUpdateEntries)
	hxf8b35a8.Cap = 0x7fffffff
	// hxf8b35a8.Len = ? x.PDescriptorUpdateEntries x.ref2af95951.pDescriptorUpdateEntries

	x.TemplateType = (DescriptorUpdateTemplateType)(x.ref2af95951.templateType)
	x.DescriptorSetLayout = *(*DescriptorSetLayout)(unsafe.Pointer(&x.ref2af95951.descriptorSetLayout))
	x.PipelineBindPoint = (PipelineBindPoint)(x.ref2af95951.pipelineBindPoint)
	x.PipelineLayout = *(*PipelineLayout)(unsafe.Pointer(&x.ref2af95951.pipelineLayout))
	x.Set = (uint32)(x.ref2af95951.set)
}

// allocPhysicalDeviceIDPropertiesMemory allocates memory for type C.VkPhysicalDeviceIDProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceIDPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceIDPropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceIDPropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceIDProperties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceIDProperties) Ref() *C.VkPhysicalDeviceIDProperties {
	if x == nil {
		return nil
	}
	return x.refe990a9f3
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceIDProperties) Free() {
	if x != nil && x.allocse990a9f3 != nil {
		x.allocse990a9f3.(*cgoAllocMap).Free()
		x.refe990a9f3 = nil
	}
}

// NewPhysicalDeviceIDPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceIDPropertiesRef(ref unsafe.Pointer) *PhysicalDeviceIDProperties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceIDProperties)
	obj.refe990a9f3 = (*C.VkPhysicalDeviceIDProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceIDProperties) PassRef() (*C.VkPhysicalDeviceIDProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe990a9f3 != nil {
		return x.refe990a9f3, nil
	}
	meme990a9f3 := allocPhysicalDeviceIDPropertiesMemory(1)
	refe990a9f3 := (*C.VkPhysicalDeviceIDProperties)(meme990a9f3)
	allocse990a9f3 := new(cgoAllocMap)
	allocse990a9f3.Add(meme990a9f3)

	refe990a9f3.sType = (C.VkStructureType)(x.SType)

	refe990a9f3.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	refe990a9f3.deviceUUID = *(*[16]C.uint8_t)(unsafe.Pointer(&x.DeviceUUID))

	refe990a9f3.driverUUID = *(*[16]C.uint8_t)(unsafe.Pointer(&x.DriverUUID))

	refe990a9f3.deviceLUID = *(*[8]C.uint8_t)(unsafe.Pointer(&x.DeviceLUID))

	refe990a9f3.deviceNodeMask = (C.uint32_t)(x.DeviceNodeMask)

	refe990a9f3.deviceLUIDValid = (C.VkBool32)(x.DeviceLUIDValid)

	x.refe990a9f3 = refe990a9f3
	x.allocse990a9f3 = allocse990a9f3
	return refe990a9f3, allocse990a9f3

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceIDProperties) PassValue() (C.VkPhysicalDeviceIDProperties, *cgoAllocMap) {
	if x.refe990a9f3 != nil {
		return *x.refe990a9f3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceIDProperties) Deref() {
	if x.refe990a9f3 == nil {
		return
	}
	x.SType = (StructureType)(x.refe990a9f3.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refe990a9f3.pNext))
	x.DeviceUUID = *(*[16]byte)(unsafe.Pointer(&x.refe990a9f3.deviceUUID))
	x.DriverUUID = *(*[16]byte)(unsafe.Pointer(&x.refe990a9f3.driverUUID))
	x.DeviceLUID = *(*[8]byte)(unsafe.Pointer(&x.refe990a9f3.deviceLUID))
	x.DeviceNodeMask = (uint32)(x.refe990a9f3.deviceNodeMask)
	x.DeviceLUIDValid = (Bool32)(x.refe990a9f3.deviceLUIDValid)
}

// allocPhysicalDeviceVulkan11PropertiesMemory allocates memory for type C.VkPhysicalDeviceVulkan11Properties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceVulkan11PropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceVulkan11PropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceVulkan11PropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceVulkan11Properties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceVulkan11Properties) Ref() *C.VkPhysicalDeviceVulkan11Properties {
	if x == nil {
		return nil
	}
	return x.refd27276a5
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceVulkan11Properties) Free() {
	if x != nil && x.allocsd27276a5 != nil {
		x.allocsd27276a5.(*cgoAllocMap).Free()
		x.refd27276a5 = nil
	}
}

// NewPhysicalDeviceVulkan11PropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceVulkan11PropertiesRef(ref unsafe.Pointer) *PhysicalDeviceVulkan11Properties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceVulkan11Properties)
	obj.refd27276a5 = (*C.VkPhysicalDeviceVulkan11Properties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceVulkan11Properties) PassRef() (*C.VkPhysicalDeviceVulkan11Properties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd27276a5 != nil {
		return x.refd27276a5, nil
	}
	memd27276a5 := allocPhysicalDeviceVulkan11PropertiesMemory(1)
	refd27276a5 := (*C.VkPhysicalDeviceVulkan11Properties)(memd27276a5)
	allocsd27276a5 := new(cgoAllocMap)
	allocsd27276a5.Add(memd27276a5)

	refd27276a5.sType = (C.VkStructureType)(x.SType)

	refd27276a5.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	refd27276a5.deviceUUID = *(*[16]C.uint8_t)(unsafe.Pointer(&x.DeviceUUID))

	refd27276a5.driverUUID = *(*[16]C.uint8_t)(unsafe.Pointer(&x.DriverUUID))

	refd27276a5.deviceLUID = *(*[8]C.uint8_t)(unsafe.Pointer(&x.DeviceLUID))

	refd27276a5.deviceNodeMask = (C.uint32_t)(x.DeviceNodeMask)

	refd27276a5.deviceLUIDValid = (C.VkBool32)(x.DeviceLUIDValid)

	refd27276a5.subgroupSize = (C.uint32_t)(x.SubgroupSize)

	refd27276a5.subgroupSupportedStages = (C.VkShaderStageFlags)(x.SubgroupSupportedStages)

	refd27276a5.subgroupSupportedOperations = (C.VkSubgroupFeatureFlags)(x.SubgroupSupportedOperations)

	refd27276a5.subgroupQuadOperationsInAllStages = (C.VkBool32)(x.SubgroupQuadOperationsInAllStages)

	refd27276a5.pointClippingBehavior = (C.VkPointClippingBehavior)(x.PointClippingBehavior)

	refd27276a5.maxMultiviewViewCount = (C.uint32_t)(x.MaxMultiviewViewCount)

	refd27276a5.maxMultiviewInstanceIndex = (C.uint32_t)(x.MaxMultiviewInstanceIndex)

	refd27276a5.protectedNoFault = (C.VkBool32)(x.ProtectedNoFault)

	refd27276a5.maxPerSetDescriptors = (C.uint32_t)(x.MaxPerSetDescriptors)

	refd27276a5.maxMemoryAllocationSize = (C.VkDeviceSize)(x.MaxMemoryAllocationSize)

	x.refd27276a5 = refd27276a5
	x.allocsd27276a5 = allocsd27276a5
	return refd27276a5, allocsd27276a5

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceVulkan11Properties) PassValue() (C.VkPhysicalDeviceVulkan11Properties, *cgoAllocMap) {
	if x.refd27276a5 != nil {
		return *x.refd27276a5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceVulkan11Properties) Deref() {
	if x.refd27276a5 == nil {
		return
	}
	x.SType = (StructureType)(x.refd27276a5.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refd27276a5.pNext))
	x.DeviceUUID = *(*[16]byte)(unsafe.Pointer(&x.refd27276a5.deviceUUID))
	x.DriverUUID = *(*[16]byte)(unsafe.Pointer(&x.refd27276a5.driverUUID))
	x.DeviceLUID = *(*[8]byte)(unsafe.Pointer(&x.refd27276a5.deviceLUID))
	x.DeviceNodeMask = (uint32)(x.refd27276a5.deviceNodeMask)
	x.DeviceLUIDValid = (Bool32)(x.refd27276a5.deviceLUIDValid)
	x.SubgroupSize = (uint32)(x.refd27276a5.subgroupSize)
	x.SubgroupSupportedStages = (ShaderStageFlags)(x.refd27276a5.subgroupSupportedStages)
	x.SubgroupSupportedOperations = (SubgroupFeatureFlags)(x.refd27276a5.subgroupSupportedOperations)
	x.SubgroupQuadOperationsInAllStages = (Bool32)(x.refd27276a5.subgroupQuadOperationsInAllStages)
	x.PointClippingBehavior = (PointClippingBehavior)(x.refd27276a5.pointClippingBehavior)
	x.MaxMultiviewViewCount = (uint32)(x.refd27276a5.maxMultiviewViewCount)
	x.MaxMultiviewInstanceIndex = (uint32)(x.refd27276a5.maxMultiviewInstanceIndex)
	x.ProtectedNoFault = (Bool32)(x.refd27276a5.protectedNoFault)
	x.MaxPerSetDescriptors = (uint32)(x.refd27276a5.maxPerSetDescriptors)
	x.MaxMemoryAllocationSize = (DeviceSize)(x.refd27276a5.maxMemoryAllocationSize)
}

// allocConformanceVersionMemory allocates memory for type C.VkConformanceVersion in C.
// The caller is responsible for freeing the this memory via C.free.
func allocConformanceVersionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfConformanceVersionValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfConformanceVersionValue = unsafe.Sizeof([1]C.VkConformanceVersion{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ConformanceVersion) Ref() *C.VkConformanceVersion {
	if x == nil {
		return nil
	}
	return x.reffb98ebcd
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ConformanceVersion) Free() {
	if x != nil && x.allocsfb98ebcd != nil {
		x.allocsfb98ebcd.(*cgoAllocMap).Free()
		x.reffb98ebcd = nil
	}
}

// NewConformanceVersionRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewConformanceVersionRef(ref unsafe.Pointer) *ConformanceVersion {
	if ref == nil {
		return nil
	}
	obj := new(ConformanceVersion)
	obj.reffb98ebcd = (*C.VkConformanceVersion)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ConformanceVersion) PassRef() (*C.VkConformanceVersion, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reffb98ebcd != nil {
		return x.reffb98ebcd, nil
	}
	memfb98ebcd := allocConformanceVersionMemory(1)
	reffb98ebcd := (*C.VkConformanceVersion)(memfb98ebcd)
	allocsfb98ebcd := new(cgoAllocMap)
	allocsfb98ebcd.Add(memfb98ebcd)

	reffb98ebcd.major = (C.uint8_t)(x.Major)

	reffb98ebcd.minor = (C.uint8_t)(x.Minor)

	reffb98ebcd.subminor = (C.uint8_t)(x.Subminor)

	reffb98ebcd.patch = (C.uint8_t)(x.Patch)

	x.reffb98ebcd = reffb98ebcd
	x.allocsfb98ebcd = allocsfb98ebcd
	return reffb98ebcd, allocsfb98ebcd

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ConformanceVersion) PassValue() (C.VkConformanceVersion, *cgoAllocMap) {
	if x.reffb98ebcd != nil {
		return *x.reffb98ebcd, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ConformanceVersion) Deref() {
	if x.reffb98ebcd == nil {
		return
	}
	x.Major = (byte)(x.reffb98ebcd.major)
	x.Minor = (byte)(x.reffb98ebcd.minor)
	x.Subminor = (byte)(x.reffb98ebcd.subminor)
	x.Patch = (byte)(x.reffb98ebcd.patch)
}

// allocPhysicalDeviceVulkan12PropertiesMemory allocates memory for type C.VkPhysicalDeviceVulkan12Properties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceVulkan12PropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceVulkan12PropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceVulkan12PropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceVulkan12Properties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceVulkan12Properties) Ref() *C.VkPhysicalDeviceVulkan12Properties {
	if x == nil {
		return nil
	}
	return x.ref4b9010a4
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceVulkan12Properties) Free() {
	if x != nil && x.allocs4b9010a4 != nil {
		x.allocs4b9010a4.(*cgoAllocMap).Free()
		x.ref4b9010a4 = nil
	}
}

// NewPhysicalDeviceVulkan12PropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceVulkan12PropertiesRef(ref unsafe.Pointer) *PhysicalDeviceVulkan12Properties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceVulkan12Properties)
	obj.ref4b9010a4 = (*C.VkPhysicalDeviceVulkan12Properties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceVulkan12Properties) PassRef() (*C.VkPhysicalDeviceVulkan12Properties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4b9010a4 != nil {
		return x.ref4b9010a4, nil
	}
	mem4b9010a4 := allocPhysicalDeviceVulkan12PropertiesMemory(1)
	ref4b9010a4 := (*C.VkPhysicalDeviceVulkan12Properties)(mem4b9010a4)
	allocs4b9010a4 := new(cgoAllocMap)
	allocs4b9010a4.Add(mem4b9010a4)

	ref4b9010a4.sType = (C.VkStructureType)(x.SType)

	ref4b9010a4.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref4b9010a4.driverID = (C.VkDriverId)(x.DriverID)

	ref4b9010a4.driverName = *(*[256]C.char)(unsafe.Pointer(&x.DriverName))

	ref4b9010a4.driverInfo = *(*[256]C.char)(unsafe.Pointer(&x.DriverInfo))

	var cconformanceVersion_allocs *cgoAllocMap
	ref4b9010a4.conformanceVersion, cconformanceVersion_allocs = x.ConformanceVersion.PassValue()
	allocs4b9010a4.Borrow(cconformanceVersion_allocs)

	ref4b9010a4.denormBehaviorIndependence = (C.VkShaderFloatControlsIndependence)(x.DenormBehaviorIndependence)

	ref4b9010a4.roundingModeIndependence = (C.VkShaderFloatControlsIndependence)(x.RoundingModeIndependence)

	ref4b9010a4.shaderSignedZeroInfNanPreserveFloat16 = (C.VkBool32)(x.ShaderSignedZeroInfNanPreserveFloat16)

	ref4b9010a4.shaderSignedZeroInfNanPreserveFloat32 = (C.VkBool32)(x.ShaderSignedZeroInfNanPreserveFloat32)

	ref4b9010a4.shaderSignedZeroInfNanPreserveFloat64 = (C.VkBool32)(x.ShaderSignedZeroInfNanPreserveFloat64)

	ref4b9010a4.shaderDenormPreserveFloat16 = (C.VkBool32)(x.ShaderDenormPreserveFloat16)

	ref4b9010a4.shaderDenormPreserveFloat32 = (C.VkBool32)(x.ShaderDenormPreserveFloat32)

	ref4b9010a4.shaderDenormPreserveFloat64 = (C.VkBool32)(x.ShaderDenormPreserveFloat64)

	ref4b9010a4.shaderDenormFlushToZeroFloat16 = (C.VkBool32)(x.ShaderDenormFlushToZeroFloat16)

	ref4b9010a4.shaderDenormFlushToZeroFloat32 = (C.VkBool32)(x.ShaderDenormFlushToZeroFloat32)

	ref4b9010a4.shaderDenormFlushToZeroFloat64 = (C.VkBool32)(x.ShaderDenormFlushToZeroFloat64)

	ref4b9010a4.shaderRoundingModeRTEFloat16 = (C.VkBool32)(x.ShaderRoundingModeRTEFloat16)

	ref4b9010a4.shaderRoundingModeRTEFloat32 = (C.VkBool32)(x.ShaderRoundingModeRTEFloat32)

	ref4b9010a4.shaderRoundingModeRTEFloat64 = (C.VkBool32)(x.ShaderRoundingModeRTEFloat64)

	ref4b9010a4.shaderRoundingModeRTZFloat16 = (C.VkBool32)(x.ShaderRoundingModeRTZFloat16)

	ref4b9010a4.shaderRoundingModeRTZFloat32 = (C.VkBool32)(x.ShaderRoundingModeRTZFloat32)

	ref4b9010a4.shaderRoundingModeRTZFloat64 = (C.VkBool32)(x.ShaderRoundingModeRTZFloat64)

	ref4b9010a4.maxUpdateAfterBindDescriptorsInAllPools = (C.uint32_t)(x.MaxUpdateAfterBindDescriptorsInAllPools)

	ref4b9010a4.shaderUniformBufferArrayNonUniformIndexingNative = (C.VkBool32)(x.ShaderUniformBufferArrayNonUniformIndexingNative)

	ref4b9010a4.shaderSampledImageArrayNonUniformIndexingNative = (C.VkBool32)(x.ShaderSampledImageArrayNonUniformIndexingNative)

	ref4b9010a4.shaderStorageBufferArrayNonUniformIndexingNative = (C.VkBool32)(x.ShaderStorageBufferArrayNonUniformIndexingNative)

	ref4b9010a4.shaderStorageImageArrayNonUniformIndexingNative = (C.VkBool32)(x.ShaderStorageImageArrayNonUniformIndexingNative)

	ref4b9010a4.shaderInputAttachmentArrayNonUniformIndexingNative = (C.VkBool32)(x.ShaderInputAttachmentArrayNonUniformIndexingNative)

	ref4b9010a4.robustBufferAccessUpdateAfterBind = (C.VkBool32)(x.RobustBufferAccessUpdateAfterBind)

	ref4b9010a4.quadDivergentImplicitLod = (C.VkBool32)(x.QuadDivergentImplicitLod)

	ref4b9010a4.maxPerStageDescriptorUpdateAfterBindSamplers = (C.uint32_t)(x.MaxPerStageDescriptorUpdateAfterBindSamplers)

	ref4b9010a4.maxPerStageDescriptorUpdateAfterBindUniformBuffers = (C.uint32_t)(x.MaxPerStageDescriptorUpdateAfterBindUniformBuffers)

	ref4b9010a4.maxPerStageDescriptorUpdateAfterBindStorageBuffers = (C.uint32_t)(x.MaxPerStageDescriptorUpdateAfterBindStorageBuffers)

	ref4b9010a4.maxPerStageDescriptorUpdateAfterBindSampledImages = (C.uint32_t)(x.MaxPerStageDescriptorUpdateAfterBindSampledImages)

	ref4b9010a4.maxPerStageDescriptorUpdateAfterBindStorageImages = (C.uint32_t)(x.MaxPerStageDescriptorUpdateAfterBindStorageImages)

	ref4b9010a4.maxPerStageDescriptorUpdateAfterBindInputAttachments = (C.uint32_t)(x.MaxPerStageDescriptorUpdateAfterBindInputAttachments)

	ref4b9010a4.maxPerStageUpdateAfterBindResources = (C.uint32_t)(x.MaxPerStageUpdateAfterBindResources)

	ref4b9010a4.maxDescriptorSetUpdateAfterBindSamplers = (C.uint32_t)(x.MaxDescriptorSetUpdateAfterBindSamplers)

	ref4b9010a4.maxDescriptorSetUpdateAfterBindUniformBuffers = (C.uint32_t)(x.MaxDescriptorSetUpdateAfterBindUniformBuffers)

	ref4b9010a4.maxDescriptorSetUpdateAfterBindUniformBuffersDynamic = (C.uint32_t)(x.MaxDescriptorSetUpdateAfterBindUniformBuffersDynamic)

	ref4b9010a4.maxDescriptorSetUpdateAfterBindStorageBuffers = (C.uint32_t)(x.MaxDescriptorSetUpdateAfterBindStorageBuffers)

	ref4b9010a4.maxDescriptorSetUpdateAfterBindStorageBuffersDynamic = (C.uint32_t)(x.MaxDescriptorSetUpdateAfterBindStorageBuffersDynamic)

	ref4b9010a4.maxDescriptorSetUpdateAfterBindSampledImages = (C.uint32_t)(x.MaxDescriptorSetUpdateAfterBindSampledImages)

	ref4b9010a4.maxDescriptorSetUpdateAfterBindStorageImages = (C.uint32_t)(x.MaxDescriptorSetUpdateAfterBindStorageImages)

	ref4b9010a4.maxDescriptorSetUpdateAfterBindInputAttachments = (C.uint32_t)(x.MaxDescriptorSetUpdateAfterBindInputAttachments)

	ref4b9010a4.supportedDepthResolveModes = (C.VkResolveModeFlags)(x.SupportedDepthResolveModes)

	ref4b9010a4.supportedStencilResolveModes = (C.VkResolveModeFlags)(x.SupportedStencilResolveModes)

	ref4b9010a4.independentResolveNone = (C.VkBool32)(x.IndependentResolveNone)

	ref4b9010a4.independentResolve = (C.VkBool32)(x.IndependentResolve)

	ref4b9010a4.filterMinmaxSingleComponentFormats = (C.VkBool32)(x.FilterMinmaxSingleComponentFormats)

	ref4b9010a4.filterMinmaxImageComponentMapping = (C.VkBool32)(x.FilterMinmaxImageComponentMapping)

	ref4b9010a4.maxTimelineSemaphoreValueDifference = (C.uint64_t)(x.MaxTimelineSemaphoreValueDifference)

	ref4b9010a4.framebufferIntegerColorSampleCounts = (C.VkSampleCountFlags)(x.FramebufferIntegerColorSampleCounts)

	x.ref4b9010a4 = ref4b9010a4
	x.allocs4b9010a4 = allocs4b9010a4
	return ref4b9010a4, allocs4b9010a4

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceVulkan12Properties) PassValue() (C.VkPhysicalDeviceVulkan12Properties, *cgoAllocMap) {
	if x.ref4b9010a4 != nil {
		return *x.ref4b9010a4, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceVulkan12Properties) Deref() {
	if x.ref4b9010a4 == nil {
		return
	}
	x.SType = (StructureType)(x.ref4b9010a4.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref4b9010a4.pNext))
	x.DriverID = (DriverId)(x.ref4b9010a4.driverID)
	x.DriverName = *(*[256]byte)(unsafe.Pointer(&x.ref4b9010a4.driverName))
	x.DriverInfo = *(*[256]byte)(unsafe.Pointer(&x.ref4b9010a4.driverInfo))
	x.ConformanceVersion = *NewConformanceVersionRef(unsafe.Pointer(&x.ref4b9010a4.conformanceVersion))
	x.DenormBehaviorIndependence = (ShaderFloatControlsIndependence)(x.ref4b9010a4.denormBehaviorIndependence)
	x.RoundingModeIndependence = (ShaderFloatControlsIndependence)(x.ref4b9010a4.roundingModeIndependence)
	x.ShaderSignedZeroInfNanPreserveFloat16 = (Bool32)(x.ref4b9010a4.shaderSignedZeroInfNanPreserveFloat16)
	x.ShaderSignedZeroInfNanPreserveFloat32 = (Bool32)(x.ref4b9010a4.shaderSignedZeroInfNanPreserveFloat32)
	x.ShaderSignedZeroInfNanPreserveFloat64 = (Bool32)(x.ref4b9010a4.shaderSignedZeroInfNanPreserveFloat64)
	x.ShaderDenormPreserveFloat16 = (Bool32)(x.ref4b9010a4.shaderDenormPreserveFloat16)
	x.ShaderDenormPreserveFloat32 = (Bool32)(x.ref4b9010a4.shaderDenormPreserveFloat32)
	x.ShaderDenormPreserveFloat64 = (Bool32)(x.ref4b9010a4.shaderDenormPreserveFloat64)
	x.ShaderDenormFlushToZeroFloat16 = (Bool32)(x.ref4b9010a4.shaderDenormFlushToZeroFloat16)
	x.ShaderDenormFlushToZeroFloat32 = (Bool32)(x.ref4b9010a4.shaderDenormFlushToZeroFloat32)
	x.ShaderDenormFlushToZeroFloat64 = (Bool32)(x.ref4b9010a4.shaderDenormFlushToZeroFloat64)
	x.ShaderRoundingModeRTEFloat16 = (Bool32)(x.ref4b9010a4.shaderRoundingModeRTEFloat16)
	x.ShaderRoundingModeRTEFloat32 = (Bool32)(x.ref4b9010a4.shaderRoundingModeRTEFloat32)
	x.ShaderRoundingModeRTEFloat64 = (Bool32)(x.ref4b9010a4.shaderRoundingModeRTEFloat64)
	x.ShaderRoundingModeRTZFloat16 = (Bool32)(x.ref4b9010a4.shaderRoundingModeRTZFloat16)
	x.ShaderRoundingModeRTZFloat32 = (Bool32)(x.ref4b9010a4.shaderRoundingModeRTZFloat32)
	x.ShaderRoundingModeRTZFloat64 = (Bool32)(x.ref4b9010a4.shaderRoundingModeRTZFloat64)
	x.MaxUpdateAfterBindDescriptorsInAllPools = (uint32)(x.ref4b9010a4.maxUpdateAfterBindDescriptorsInAllPools)
	x.ShaderUniformBufferArrayNonUniformIndexingNative = (Bool32)(x.ref4b9010a4.shaderUniformBufferArrayNonUniformIndexingNative)
	x.ShaderSampledImageArrayNonUniformIndexingNative = (Bool32)(x.ref4b9010a4.shaderSampledImageArrayNonUniformIndexingNative)
	x.ShaderStorageBufferArrayNonUniformIndexingNative = (Bool32)(x.ref4b9010a4.shaderStorageBufferArrayNonUniformIndexingNative)
	x.ShaderStorageImageArrayNonUniformIndexingNative = (Bool32)(x.ref4b9010a4.shaderStorageImageArrayNonUniformIndexingNative)
	x.ShaderInputAttachmentArrayNonUniformIndexingNative = (Bool32)(x.ref4b9010a4.shaderInputAttachmentArrayNonUniformIndexingNative)
	x.RobustBufferAccessUpdateAfterBind = (Bool32)(x.ref4b9010a4.robustBufferAccessUpdateAfterBind)
	x.QuadDivergentImplicitLod = (Bool32)(x.ref4b9010a4.quadDivergentImplicitLod)
	x.MaxPerStageDescriptorUpdateAfterBindSamplers = (uint32)(x.ref4b9010a4.maxPerStageDescriptorUpdateAfterBindSamplers)
	x.MaxPerStageDescriptorUpdateAfterBindUniformBuffers = (uint32)(x.ref4b9010a4.maxPerStageDescriptorUpdateAfterBindUniformBuffers)
	x.MaxPerStageDescriptorUpdateAfterBindStorageBuffers = (uint32)(x.ref4b9010a4.maxPerStageDescriptorUpdateAfterBindStorageBuffers)
	x.MaxPerStageDescriptorUpdateAfterBindSampledImages = (uint32)(x.ref4b9010a4.maxPerStageDescriptorUpdateAfterBindSampledImages)
	x.MaxPerStageDescriptorUpdateAfterBindStorageImages = (uint32)(x.ref4b9010a4.maxPerStageDescriptorUpdateAfterBindStorageImages)
	x.MaxPerStageDescriptorUpdateAfterBindInputAttachments = (uint32)(x.ref4b9010a4.maxPerStageDescriptorUpdateAfterBindInputAttachments)
	x.MaxPerStageUpdateAfterBindResources = (uint32)(x.ref4b9010a4.maxPerStageUpdateAfterBindResources)
	x.MaxDescriptorSetUpdateAfterBindSamplers = (uint32)(x.ref4b9010a4.maxDescriptorSetUpdateAfterBindSamplers)
	x.MaxDescriptorSetUpdateAfterBindUniformBuffers = (uint32)(x.ref4b9010a4.maxDescriptorSetUpdateAfterBindUniformBuffers)
	x.MaxDescriptorSetUpdateAfterBindUniformBuffersDynamic = (uint32)(x.ref4b9010a4.maxDescriptorSetUpdateAfterBindUniformBuffersDynamic)
	x.MaxDescriptorSetUpdateAfterBindStorageBuffers = (uint32)(x.ref4b9010a4.maxDescriptorSetUpdateAfterBindStorageBuffers)
	x.MaxDescriptorSetUpdateAfterBindStorageBuffersDynamic = (uint32)(x.ref4b9010a4.maxDescriptorSetUpdateAfterBindStorageBuffersDynamic)
	x.MaxDescriptorSetUpdateAfterBindSampledImages = (uint32)(x.ref4b9010a4.maxDescriptorSetUpdateAfterBindSampledImages)
	x.MaxDescriptorSetUpdateAfterBindStorageImages = (uint32)(x.ref4b9010a4.maxDescriptorSetUpdateAfterBindStorageImages)
	x.MaxDescriptorSetUpdateAfterBindInputAttachments = (uint32)(x.ref4b9010a4.maxDescriptorSetUpdateAfterBindInputAttachments)
	x.SupportedDepthResolveModes = (ResolveModeFlags)(x.ref4b9010a4.supportedDepthResolveModes)
	x.SupportedStencilResolveModes = (ResolveModeFlags)(x.ref4b9010a4.supportedStencilResolveModes)
	x.IndependentResolveNone = (Bool32)(x.ref4b9010a4.independentResolveNone)
	x.IndependentResolve = (Bool32)(x.ref4b9010a4.independentResolve)
	x.FilterMinmaxSingleComponentFormats = (Bool32)(x.ref4b9010a4.filterMinmaxSingleComponentFormats)
	x.FilterMinmaxImageComponentMapping = (Bool32)(x.ref4b9010a4.filterMinmaxImageComponentMapping)
	x.MaxTimelineSemaphoreValueDifference = (uint64)(x.ref4b9010a4.maxTimelineSemaphoreValueDifference)
	x.FramebufferIntegerColorSampleCounts = (SampleCountFlags)(x.ref4b9010a4.framebufferIntegerColorSampleCounts)
}

// allocImageFormatListCreateInfoMemory allocates memory for type C.VkImageFormatListCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageFormatListCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageFormatListCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfImageFormatListCreateInfoValue = unsafe.Sizeof([1]C.VkImageFormatListCreateInfo{})

// copyPFormatBytes copies the data from Go slice as *C.VkFormat.
func copyPFormatBytes(slice *sliceHeader) (*C.VkFormat, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfFormatValue) * slice.Len,
		Cap:  int(sizeOfFormatValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkFormat)(mem0), allocs
}

// allocFormatMemory allocates memory for type C.VkFormat in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFormatMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFormatValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFormatValue = unsafe.Sizeof([1]C.VkFormat{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImageFormatListCreateInfo) Ref() *C.VkImageFormatListCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref76fdc95e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImageFormatListCreateInfo) Free() {
	if x != nil && x.allocs76fdc95e != nil {
		x.allocs76fdc95e.(*cgoAllocMap).Free()
		x.ref76fdc95e = nil
	}
}

// NewImageFormatListCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageFormatListCreateInfoRef(ref unsafe.Pointer) *ImageFormatListCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(ImageFormatListCreateInfo)
	obj.ref76fdc95e = (*C.VkImageFormatListCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImageFormatListCreateInfo) PassRef() (*C.VkImageFormatListCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref76fdc95e != nil {
		return x.ref76fdc95e, nil
	}
	mem76fdc95e := allocImageFormatListCreateInfoMemory(1)
	ref76fdc95e := (*C.VkImageFormatListCreateInfo)(mem76fdc95e)
	allocs76fdc95e := new(cgoAllocMap)
	allocs76fdc95e.Add(mem76fdc95e)

	ref76fdc95e.sType = (C.VkStructureType)(x.SType)

	ref76fdc95e.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref76fdc95e.viewFormatCount = (C.uint32_t)(x.ViewFormatCount)

	if x.PViewFormats != nil {
		var cpViewFormats_allocs *cgoAllocMap
		ref76fdc95e.pViewFormats, cpViewFormats_allocs = copyPFormatBytes((*sliceHeader)(unsafe.Pointer(&x.PViewFormats)))
		allocs76fdc95e.Borrow(cpViewFormats_allocs)
	}

	x.ref76fdc95e = ref76fdc95e
	x.allocs76fdc95e = allocs76fdc95e
	return ref76fdc95e, allocs76fdc95e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImageFormatListCreateInfo) PassValue() (C.VkImageFormatListCreateInfo, *cgoAllocMap) {
	if x.ref76fdc95e != nil {
		return *x.ref76fdc95e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImageFormatListCreateInfo) Deref() {
	if x.ref76fdc95e == nil {
		return
	}
	x.SType = (StructureType)(x.ref76fdc95e.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref76fdc95e.pNext))
	x.ViewFormatCount = (uint32)(x.ref76fdc95e.viewFormatCount)
	hxf8959c2 := (*sliceHeader)(unsafe.Pointer(&x.PViewFormats))
	hxf8959c2.Data = unsafe.Pointer(x.ref76fdc95e.pViewFormats)
	hxf8959c2.Cap = 0x7fffffff
	// hxf8959c2.Len = ? x.PViewFormats x.ref76fdc95e.pViewFormats

}

// allocSubpassDescription2Memory allocates memory for type C.VkSubpassDescription2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSubpassDescription2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSubpassDescription2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSubpassDescription2Value = unsafe.Sizeof([1]C.VkSubpassDescription2{})

// copyPAttachmentReference2Bytes copies the data from Go slice as *C.VkAttachmentReference2.
func copyPAttachmentReference2Bytes(slice *sliceHeader) (*C.VkAttachmentReference2, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfAttachmentReference2Value) * slice.Len,
		Cap:  int(sizeOfAttachmentReference2Value) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkAttachmentReference2)(mem0), allocs
}

// allocAttachmentReference2Memory allocates memory for type C.VkAttachmentReference2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAttachmentReference2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAttachmentReference2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfAttachmentReference2Value = unsafe.Sizeof([1]C.VkAttachmentReference2{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SubpassDescription2) Ref() *C.VkSubpassDescription2 {
	if x == nil {
		return nil
	}
	return x.ref7cdffe39
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SubpassDescription2) Free() {
	if x != nil && x.allocs7cdffe39 != nil {
		x.allocs7cdffe39.(*cgoAllocMap).Free()
		x.ref7cdffe39 = nil
	}
}

// NewSubpassDescription2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSubpassDescription2Ref(ref unsafe.Pointer) *SubpassDescription2 {
	if ref == nil {
		return nil
	}
	obj := new(SubpassDescription2)
	obj.ref7cdffe39 = (*C.VkSubpassDescription2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SubpassDescription2) PassRef() (*C.VkSubpassDescription2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7cdffe39 != nil {
		return x.ref7cdffe39, nil
	}
	mem7cdffe39 := allocSubpassDescription2Memory(1)
	ref7cdffe39 := (*C.VkSubpassDescription2)(mem7cdffe39)
	allocs7cdffe39 := new(cgoAllocMap)
	allocs7cdffe39.Add(mem7cdffe39)

	ref7cdffe39.sType = (C.VkStructureType)(x.SType)

	ref7cdffe39.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref7cdffe39.flags = (C.VkSubpassDescriptionFlags)(x.Flags)

	ref7cdffe39.pipelineBindPoint = (C.VkPipelineBindPoint)(x.PipelineBindPoint)

	ref7cdffe39.viewMask = (C.uint32_t)(x.ViewMask)

	ref7cdffe39.inputAttachmentCount = (C.uint32_t)(x.InputAttachmentCount)

	if x.PInputAttachments != nil {
		var cpInputAttachments_allocs *cgoAllocMap
		ref7cdffe39.pInputAttachments, cpInputAttachments_allocs = copyPAttachmentReference2Bytes((*sliceHeader)(unsafe.Pointer(&x.PInputAttachments)))
		allocs7cdffe39.Borrow(cpInputAttachments_allocs)
	}

	ref7cdffe39.colorAttachmentCount = (C.uint32_t)(x.ColorAttachmentCount)

	if x.PColorAttachments != nil {
		var cpColorAttachments_allocs *cgoAllocMap
		ref7cdffe39.pColorAttachments, cpColorAttachments_allocs = copyPAttachmentReference2Bytes((*sliceHeader)(unsafe.Pointer(&x.PColorAttachments)))
		allocs7cdffe39.Borrow(cpColorAttachments_allocs)
	}

	if x.PResolveAttachments != nil {
		var cpResolveAttachments_allocs *cgoAllocMap
		ref7cdffe39.pResolveAttachments, cpResolveAttachments_allocs = copyPAttachmentReference2Bytes((*sliceHeader)(unsafe.Pointer(&x.PResolveAttachments)))
		allocs7cdffe39.Borrow(cpResolveAttachments_allocs)
	}

	if x.PDepthStencilAttachment != nil {
		var cpDepthStencilAttachment_allocs *cgoAllocMap
		ref7cdffe39.pDepthStencilAttachment, cpDepthStencilAttachment_allocs = copyPAttachmentReference2Bytes((*sliceHeader)(unsafe.Pointer(&x.PDepthStencilAttachment)))
		allocs7cdffe39.Borrow(cpDepthStencilAttachment_allocs)
	}

	ref7cdffe39.preserveAttachmentCount = (C.uint32_t)(x.PreserveAttachmentCount)

	if x.PPreserveAttachments != nil {
		var cpPreserveAttachments_allocs *cgoAllocMap
		ref7cdffe39.pPreserveAttachments, cpPreserveAttachments_allocs = copyPUint32_tBytes((*sliceHeader)(unsafe.Pointer(&x.PPreserveAttachments)))
		allocs7cdffe39.Borrow(cpPreserveAttachments_allocs)
	}

	x.ref7cdffe39 = ref7cdffe39
	x.allocs7cdffe39 = allocs7cdffe39
	return ref7cdffe39, allocs7cdffe39

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SubpassDescription2) PassValue() (C.VkSubpassDescription2, *cgoAllocMap) {
	if x.ref7cdffe39 != nil {
		return *x.ref7cdffe39, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SubpassDescription2) Deref() {
	if x.ref7cdffe39 == nil {
		return
	}
	x.SType = (StructureType)(x.ref7cdffe39.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref7cdffe39.pNext))
	x.Flags = (SubpassDescriptionFlags)(x.ref7cdffe39.flags)
	x.PipelineBindPoint = (PipelineBindPoint)(x.ref7cdffe39.pipelineBindPoint)
	x.ViewMask = (uint32)(x.ref7cdffe39.viewMask)
	x.InputAttachmentCount = (uint32)(x.ref7cdffe39.inputAttachmentCount)
	hxfb029a7 := (*sliceHeader)(unsafe.Pointer(&x.PInputAttachments))
	hxfb029a7.Data = unsafe.Pointer(x.ref7cdffe39.pInputAttachments)
	hxfb029a7.Cap = 0x7fffffff
	// hxfb029a7.Len = ? x.PInputAttachments x.ref7cdffe39.pInputAttachments

	x.ColorAttachmentCount = (uint32)(x.ref7cdffe39.colorAttachmentCount)
	hxf7d15a2 := (*sliceHeader)(unsafe.Pointer(&x.PColorAttachments))
	hxf7d15a2.Data = unsafe.Pointer(x.ref7cdffe39.pColorAttachments)
	hxf7d15a2.Cap = 0x7fffffff
	// hxf7d15a2.Len = ? x.PColorAttachments x.ref7cdffe39.pColorAttachments

	hxf8dbbe5 := (*sliceHeader)(unsafe.Pointer(&x.PResolveAttachments))
	hxf8dbbe5.Data = unsafe.Pointer(x.ref7cdffe39.pResolveAttachments)
	hxf8dbbe5.Cap = 0x7fffffff
	// hxf8dbbe5.Len = ? x.PResolveAttachments x.ref7cdffe39.pResolveAttachments

	hxf766ff8 := (*sliceHeader)(unsafe.Pointer(&x.PDepthStencilAttachment))
	hxf766ff8.Data = unsafe.Pointer(x.ref7cdffe39.pDepthStencilAttachment)
	hxf766ff8.Cap = 0x7fffffff
	// hxf766ff8.Len = ? x.PDepthStencilAttachment x.ref7cdffe39.pDepthStencilAttachment

	x.PreserveAttachmentCount = (uint32)(x.ref7cdffe39.preserveAttachmentCount)
	hxf9b1633 := (*sliceHeader)(unsafe.Pointer(&x.PPreserveAttachments))
	hxf9b1633.Data = unsafe.Pointer(x.ref7cdffe39.pPreserveAttachments)
	hxf9b1633.Cap = 0x7fffffff
	// hxf9b1633.Len = ? x.PPreserveAttachments x.ref7cdffe39.pPreserveAttachments

}

// allocRenderPassCreateInfo2Memory allocates memory for type C.VkRenderPassCreateInfo2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRenderPassCreateInfo2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRenderPassCreateInfo2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfRenderPassCreateInfo2Value = unsafe.Sizeof([1]C.VkRenderPassCreateInfo2{})

// copyPAttachmentDescription2Bytes copies the data from Go slice as *C.VkAttachmentDescription2.
func copyPAttachmentDescription2Bytes(slice *sliceHeader) (*C.VkAttachmentDescription2, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfAttachmentDescription2Value) * slice.Len,
		Cap:  int(sizeOfAttachmentDescription2Value) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkAttachmentDescription2)(mem0), allocs
}

// allocAttachmentDescription2Memory allocates memory for type C.VkAttachmentDescription2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAttachmentDescription2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAttachmentDescription2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfAttachmentDescription2Value = unsafe.Sizeof([1]C.VkAttachmentDescription2{})

// unpackSSubpassDescription2 transforms a sliced Go data structure into plain C format.
func unpackSSubpassDescription2(x []SubpassDescription2) (unpacked *C.VkSubpassDescription2, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocSubpassDescription2Memory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSubpassDescription2)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSubpassDescription2)(h.Data)
	return
}

// copyPSubpassDependency2Bytes copies the data from Go slice as *C.VkSubpassDependency2.
func copyPSubpassDependency2Bytes(slice *sliceHeader) (*C.VkSubpassDependency2, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfSubpassDependency2Value) * slice.Len,
		Cap:  int(sizeOfSubpassDependency2Value) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkSubpassDependency2)(mem0), allocs
}

// allocSubpassDependency2Memory allocates memory for type C.VkSubpassDependency2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSubpassDependency2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSubpassDependency2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSubpassDependency2Value = unsafe.Sizeof([1]C.VkSubpassDependency2{})

// packSSubpassDescription2 reads sliced Go data structure out from plain C format.
func packSSubpassDescription2(v []SubpassDescription2, ptr0 *C.VkSubpassDescription2) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSubpassDescription2Value]C.VkSubpassDescription2)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSubpassDescription2Ref(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RenderPassCreateInfo2) Ref() *C.VkRenderPassCreateInfo2 {
	if x == nil {
		return nil
	}
	return x.ref1e86f565
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RenderPassCreateInfo2) Free() {
	if x != nil && x.allocs1e86f565 != nil {
		x.allocs1e86f565.(*cgoAllocMap).Free()
		x.ref1e86f565 = nil
	}
}

// NewRenderPassCreateInfo2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRenderPassCreateInfo2Ref(ref unsafe.Pointer) *RenderPassCreateInfo2 {
	if ref == nil {
		return nil
	}
	obj := new(RenderPassCreateInfo2)
	obj.ref1e86f565 = (*C.VkRenderPassCreateInfo2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RenderPassCreateInfo2) PassRef() (*C.VkRenderPassCreateInfo2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1e86f565 != nil {
		return x.ref1e86f565, nil
	}
	mem1e86f565 := allocRenderPassCreateInfo2Memory(1)
	ref1e86f565 := (*C.VkRenderPassCreateInfo2)(mem1e86f565)
	allocs1e86f565 := new(cgoAllocMap)
	allocs1e86f565.Add(mem1e86f565)

	ref1e86f565.sType = (C.VkStructureType)(x.SType)

	ref1e86f565.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref1e86f565.flags = (C.VkRenderPassCreateFlags)(x.Flags)

	ref1e86f565.attachmentCount = (C.uint32_t)(x.AttachmentCount)

	if x.PAttachments != nil {
		var cpAttachments_allocs *cgoAllocMap
		ref1e86f565.pAttachments, cpAttachments_allocs = copyPAttachmentDescription2Bytes((*sliceHeader)(unsafe.Pointer(&x.PAttachments)))
		allocs1e86f565.Borrow(cpAttachments_allocs)
	}

	ref1e86f565.subpassCount = (C.uint32_t)(x.SubpassCount)

	var cpSubpasses_allocs *cgoAllocMap
	ref1e86f565.pSubpasses, cpSubpasses_allocs = unpackSSubpassDescription2(x.PSubpasses)
	allocs1e86f565.Borrow(cpSubpasses_allocs)

	ref1e86f565.dependencyCount = (C.uint32_t)(x.DependencyCount)

	if x.PDependencies != nil {
		var cpDependencies_allocs *cgoAllocMap
		ref1e86f565.pDependencies, cpDependencies_allocs = copyPSubpassDependency2Bytes((*sliceHeader)(unsafe.Pointer(&x.PDependencies)))
		allocs1e86f565.Borrow(cpDependencies_allocs)
	}

	ref1e86f565.correlatedViewMaskCount = (C.uint32_t)(x.CorrelatedViewMaskCount)

	if x.PCorrelatedViewMasks != nil {
		var cpCorrelatedViewMasks_allocs *cgoAllocMap
		ref1e86f565.pCorrelatedViewMasks, cpCorrelatedViewMasks_allocs = copyPUint32_tBytes((*sliceHeader)(unsafe.Pointer(&x.PCorrelatedViewMasks)))
		allocs1e86f565.Borrow(cpCorrelatedViewMasks_allocs)
	}

	x.ref1e86f565 = ref1e86f565
	x.allocs1e86f565 = allocs1e86f565
	return ref1e86f565, allocs1e86f565

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RenderPassCreateInfo2) PassValue() (C.VkRenderPassCreateInfo2, *cgoAllocMap) {
	if x.ref1e86f565 != nil {
		return *x.ref1e86f565, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *RenderPassCreateInfo2) Deref() {
	if x.ref1e86f565 == nil {
		return
	}
	x.SType = (StructureType)(x.ref1e86f565.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref1e86f565.pNext))
	x.Flags = (RenderPassCreateFlags)(x.ref1e86f565.flags)
	x.AttachmentCount = (uint32)(x.ref1e86f565.attachmentCount)
	hxf502c9a := (*sliceHeader)(unsafe.Pointer(&x.PAttachments))
	hxf502c9a.Data = unsafe.Pointer(x.ref1e86f565.pAttachments)
	hxf502c9a.Cap = 0x7fffffff
	// hxf502c9a.Len = ? x.PAttachments x.ref1e86f565.pAttachments

	x.SubpassCount = (uint32)(x.ref1e86f565.subpassCount)
	packSSubpassDescription2(x.PSubpasses, x.ref1e86f565.pSubpasses)
	x.DependencyCount = (uint32)(x.ref1e86f565.dependencyCount)
	hxf4a9453 := (*sliceHeader)(unsafe.Pointer(&x.PDependencies))
	hxf4a9453.Data = unsafe.Pointer(x.ref1e86f565.pDependencies)
	hxf4a9453.Cap = 0x7fffffff
	// hxf4a9453.Len = ? x.PDependencies x.ref1e86f565.pDependencies

	x.CorrelatedViewMaskCount = (uint32)(x.ref1e86f565.correlatedViewMaskCount)
	hxf1a1416 := (*sliceHeader)(unsafe.Pointer(&x.PCorrelatedViewMasks))
	hxf1a1416.Data = unsafe.Pointer(x.ref1e86f565.pCorrelatedViewMasks)
	hxf1a1416.Cap = 0x7fffffff
	// hxf1a1416.Len = ? x.PCorrelatedViewMasks x.ref1e86f565.pCorrelatedViewMasks

}

// allocPhysicalDeviceDriverPropertiesMemory allocates memory for type C.VkPhysicalDeviceDriverProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceDriverPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceDriverPropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceDriverPropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceDriverProperties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceDriverProperties) Ref() *C.VkPhysicalDeviceDriverProperties {
	if x == nil {
		return nil
	}
	return x.ref492c8b68
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceDriverProperties) Free() {
	if x != nil && x.allocs492c8b68 != nil {
		x.allocs492c8b68.(*cgoAllocMap).Free()
		x.ref492c8b68 = nil
	}
}

// NewPhysicalDeviceDriverPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceDriverPropertiesRef(ref unsafe.Pointer) *PhysicalDeviceDriverProperties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceDriverProperties)
	obj.ref492c8b68 = (*C.VkPhysicalDeviceDriverProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceDriverProperties) PassRef() (*C.VkPhysicalDeviceDriverProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref492c8b68 != nil {
		return x.ref492c8b68, nil
	}
	mem492c8b68 := allocPhysicalDeviceDriverPropertiesMemory(1)
	ref492c8b68 := (*C.VkPhysicalDeviceDriverProperties)(mem492c8b68)
	allocs492c8b68 := new(cgoAllocMap)
	allocs492c8b68.Add(mem492c8b68)

	ref492c8b68.sType = (C.VkStructureType)(x.SType)

	ref492c8b68.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref492c8b68.driverID = (C.VkDriverId)(x.DriverID)

	ref492c8b68.driverName = *(*[256]C.char)(unsafe.Pointer(&x.DriverName))

	ref492c8b68.driverInfo = *(*[256]C.char)(unsafe.Pointer(&x.DriverInfo))

	var cconformanceVersion_allocs *cgoAllocMap
	ref492c8b68.conformanceVersion, cconformanceVersion_allocs = x.ConformanceVersion.PassValue()
	allocs492c8b68.Borrow(cconformanceVersion_allocs)

	x.ref492c8b68 = ref492c8b68
	x.allocs492c8b68 = allocs492c8b68
	return ref492c8b68, allocs492c8b68

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceDriverProperties) PassValue() (C.VkPhysicalDeviceDriverProperties, *cgoAllocMap) {
	if x.ref492c8b68 != nil {
		return *x.ref492c8b68, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceDriverProperties) Deref() {
	if x.ref492c8b68 == nil {
		return
	}
	x.SType = (StructureType)(x.ref492c8b68.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref492c8b68.pNext))
	x.DriverID = (DriverId)(x.ref492c8b68.driverID)
	x.DriverName = *(*[256]byte)(unsafe.Pointer(&x.ref492c8b68.driverName))
	x.DriverInfo = *(*[256]byte)(unsafe.Pointer(&x.ref492c8b68.driverInfo))
	x.ConformanceVersion = *NewConformanceVersionRef(unsafe.Pointer(&x.ref492c8b68.conformanceVersion))
}

// allocDescriptorSetLayoutBindingFlagsCreateInfoMemory allocates memory for type C.VkDescriptorSetLayoutBindingFlagsCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDescriptorSetLayoutBindingFlagsCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDescriptorSetLayoutBindingFlagsCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDescriptorSetLayoutBindingFlagsCreateInfoValue = unsafe.Sizeof([1]C.VkDescriptorSetLayoutBindingFlagsCreateInfo{})

// copyPDescriptorBindingFlagsBytes copies the data from Go slice as *C.VkDescriptorBindingFlags.
func copyPDescriptorBindingFlagsBytes(slice *sliceHeader) (*C.VkDescriptorBindingFlags, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfDescriptorBindingFlagsValue) * slice.Len,
		Cap:  int(sizeOfDescriptorBindingFlagsValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkDescriptorBindingFlags)(mem0), allocs
}

// allocDescriptorBindingFlagsMemory allocates memory for type C.VkDescriptorBindingFlags in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDescriptorBindingFlagsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDescriptorBindingFlagsValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDescriptorBindingFlagsValue = unsafe.Sizeof([1]C.VkDescriptorBindingFlags{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DescriptorSetLayoutBindingFlagsCreateInfo) Ref() *C.VkDescriptorSetLayoutBindingFlagsCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref84838c4d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DescriptorSetLayoutBindingFlagsCreateInfo) Free() {
	if x != nil && x.allocs84838c4d != nil {
		x.allocs84838c4d.(*cgoAllocMap).Free()
		x.ref84838c4d = nil
	}
}

// NewDescriptorSetLayoutBindingFlagsCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDescriptorSetLayoutBindingFlagsCreateInfoRef(ref unsafe.Pointer) *DescriptorSetLayoutBindingFlagsCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(DescriptorSetLayoutBindingFlagsCreateInfo)
	obj.ref84838c4d = (*C.VkDescriptorSetLayoutBindingFlagsCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DescriptorSetLayoutBindingFlagsCreateInfo) PassRef() (*C.VkDescriptorSetLayoutBindingFlagsCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref84838c4d != nil {
		return x.ref84838c4d, nil
	}
	mem84838c4d := allocDescriptorSetLayoutBindingFlagsCreateInfoMemory(1)
	ref84838c4d := (*C.VkDescriptorSetLayoutBindingFlagsCreateInfo)(mem84838c4d)
	allocs84838c4d := new(cgoAllocMap)
	allocs84838c4d.Add(mem84838c4d)

	ref84838c4d.sType = (C.VkStructureType)(x.SType)

	ref84838c4d.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref84838c4d.bindingCount = (C.uint32_t)(x.BindingCount)

	if x.PBindingFlags != nil {
		var cpBindingFlags_allocs *cgoAllocMap
		ref84838c4d.pBindingFlags, cpBindingFlags_allocs = copyPDescriptorBindingFlagsBytes((*sliceHeader)(unsafe.Pointer(&x.PBindingFlags)))
		allocs84838c4d.Borrow(cpBindingFlags_allocs)
	}

	x.ref84838c4d = ref84838c4d
	x.allocs84838c4d = allocs84838c4d
	return ref84838c4d, allocs84838c4d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DescriptorSetLayoutBindingFlagsCreateInfo) PassValue() (C.VkDescriptorSetLayoutBindingFlagsCreateInfo, *cgoAllocMap) {
	if x.ref84838c4d != nil {
		return *x.ref84838c4d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DescriptorSetLayoutBindingFlagsCreateInfo) Deref() {
	if x.ref84838c4d == nil {
		return
	}
	x.SType = (StructureType)(x.ref84838c4d.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref84838c4d.pNext))
	x.BindingCount = (uint32)(x.ref84838c4d.bindingCount)
	hxf92be66 := (*sliceHeader)(unsafe.Pointer(&x.PBindingFlags))
	hxf92be66.Data = unsafe.Pointer(x.ref84838c4d.pBindingFlags)
	hxf92be66.Cap = 0x7fffffff
	// hxf92be66.Len = ? x.PBindingFlags x.ref84838c4d.pBindingFlags

}

// allocDescriptorSetVariableDescriptorCountAllocateInfoMemory allocates memory for type C.VkDescriptorSetVariableDescriptorCountAllocateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDescriptorSetVariableDescriptorCountAllocateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDescriptorSetVariableDescriptorCountAllocateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDescriptorSetVariableDescriptorCountAllocateInfoValue = unsafe.Sizeof([1]C.VkDescriptorSetVariableDescriptorCountAllocateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DescriptorSetVariableDescriptorCountAllocateInfo) Ref() *C.VkDescriptorSetVariableDescriptorCountAllocateInfo {
	if x == nil {
		return nil
	}
	return x.ref7969c9a7
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DescriptorSetVariableDescriptorCountAllocateInfo) Free() {
	if x != nil && x.allocs7969c9a7 != nil {
		x.allocs7969c9a7.(*cgoAllocMap).Free()
		x.ref7969c9a7 = nil
	}
}

// NewDescriptorSetVariableDescriptorCountAllocateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDescriptorSetVariableDescriptorCountAllocateInfoRef(ref unsafe.Pointer) *DescriptorSetVariableDescriptorCountAllocateInfo {
	if ref == nil {
		return nil
	}
	obj := new(DescriptorSetVariableDescriptorCountAllocateInfo)
	obj.ref7969c9a7 = (*C.VkDescriptorSetVariableDescriptorCountAllocateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DescriptorSetVariableDescriptorCountAllocateInfo) PassRef() (*C.VkDescriptorSetVariableDescriptorCountAllocateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7969c9a7 != nil {
		return x.ref7969c9a7, nil
	}
	mem7969c9a7 := allocDescriptorSetVariableDescriptorCountAllocateInfoMemory(1)
	ref7969c9a7 := (*C.VkDescriptorSetVariableDescriptorCountAllocateInfo)(mem7969c9a7)
	allocs7969c9a7 := new(cgoAllocMap)
	allocs7969c9a7.Add(mem7969c9a7)

	ref7969c9a7.sType = (C.VkStructureType)(x.SType)

	ref7969c9a7.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref7969c9a7.descriptorSetCount = (C.uint32_t)(x.DescriptorSetCount)

	if x.PDescriptorCounts != nil {
		var cpDescriptorCounts_allocs *cgoAllocMap
		ref7969c9a7.pDescriptorCounts, cpDescriptorCounts_allocs = copyPUint32_tBytes((*sliceHeader)(unsafe.Pointer(&x.PDescriptorCounts)))
		allocs7969c9a7.Borrow(cpDescriptorCounts_allocs)
	}

	x.ref7969c9a7 = ref7969c9a7
	x.allocs7969c9a7 = allocs7969c9a7
	return ref7969c9a7, allocs7969c9a7

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DescriptorSetVariableDescriptorCountAllocateInfo) PassValue() (C.VkDescriptorSetVariableDescriptorCountAllocateInfo, *cgoAllocMap) {
	if x.ref7969c9a7 != nil {
		return *x.ref7969c9a7, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DescriptorSetVariableDescriptorCountAllocateInfo) Deref() {
	if x.ref7969c9a7 == nil {
		return
	}
	x.SType = (StructureType)(x.ref7969c9a7.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref7969c9a7.pNext))
	x.DescriptorSetCount = (uint32)(x.ref7969c9a7.descriptorSetCount)
	hxf4b5187 := (*sliceHeader)(unsafe.Pointer(&x.PDescriptorCounts))
	hxf4b5187.Data = unsafe.Pointer(x.ref7969c9a7.pDescriptorCounts)
	hxf4b5187.Cap = 0x7fffffff
	// hxf4b5187.Len = ? x.PDescriptorCounts x.ref7969c9a7.pDescriptorCounts

}

// allocSubpassDescriptionDepthStencilResolveMemory allocates memory for type C.VkSubpassDescriptionDepthStencilResolve in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSubpassDescriptionDepthStencilResolveMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSubpassDescriptionDepthStencilResolveValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSubpassDescriptionDepthStencilResolveValue = unsafe.Sizeof([1]C.VkSubpassDescriptionDepthStencilResolve{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SubpassDescriptionDepthStencilResolve) Ref() *C.VkSubpassDescriptionDepthStencilResolve {
	if x == nil {
		return nil
	}
	return x.refc46545a8
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SubpassDescriptionDepthStencilResolve) Free() {
	if x != nil && x.allocsc46545a8 != nil {
		x.allocsc46545a8.(*cgoAllocMap).Free()
		x.refc46545a8 = nil
	}
}

// NewSubpassDescriptionDepthStencilResolveRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSubpassDescriptionDepthStencilResolveRef(ref unsafe.Pointer) *SubpassDescriptionDepthStencilResolve {
	if ref == nil {
		return nil
	}
	obj := new(SubpassDescriptionDepthStencilResolve)
	obj.refc46545a8 = (*C.VkSubpassDescriptionDepthStencilResolve)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SubpassDescriptionDepthStencilResolve) PassRef() (*C.VkSubpassDescriptionDepthStencilResolve, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc46545a8 != nil {
		return x.refc46545a8, nil
	}
	memc46545a8 := allocSubpassDescriptionDepthStencilResolveMemory(1)
	refc46545a8 := (*C.VkSubpassDescriptionDepthStencilResolve)(memc46545a8)
	allocsc46545a8 := new(cgoAllocMap)
	allocsc46545a8.Add(memc46545a8)

	refc46545a8.sType = (C.VkStructureType)(x.SType)

	refc46545a8.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	refc46545a8.depthResolveMode = (C.VkResolveModeFlagBits)(x.DepthResolveMode)

	refc46545a8.stencilResolveMode = (C.VkResolveModeFlagBits)(x.StencilResolveMode)

	if x.PDepthStencilResolveAttachment != nil {
		var cpDepthStencilResolveAttachment_allocs *cgoAllocMap
		refc46545a8.pDepthStencilResolveAttachment, cpDepthStencilResolveAttachment_allocs = copyPAttachmentReference2Bytes((*sliceHeader)(unsafe.Pointer(&x.PDepthStencilResolveAttachment)))
		allocsc46545a8.Borrow(cpDepthStencilResolveAttachment_allocs)
	}

	x.refc46545a8 = refc46545a8
	x.allocsc46545a8 = allocsc46545a8
	return refc46545a8, allocsc46545a8

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SubpassDescriptionDepthStencilResolve) PassValue() (C.VkSubpassDescriptionDepthStencilResolve, *cgoAllocMap) {
	if x.refc46545a8 != nil {
		return *x.refc46545a8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SubpassDescriptionDepthStencilResolve) Deref() {
	if x.refc46545a8 == nil {
		return
	}
	x.SType = (StructureType)(x.refc46545a8.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refc46545a8.pNext))
	x.DepthResolveMode = (ResolveModeFlagBits)(x.refc46545a8.depthResolveMode)
	x.StencilResolveMode = (ResolveModeFlagBits)(x.refc46545a8.stencilResolveMode)
	hxf177f79 := (*sliceHeader)(unsafe.Pointer(&x.PDepthStencilResolveAttachment))
	hxf177f79.Data = unsafe.Pointer(x.refc46545a8.pDepthStencilResolveAttachment)
	hxf177f79.Cap = 0x7fffffff
	// hxf177f79.Len = ? x.PDepthStencilResolveAttachment x.refc46545a8.pDepthStencilResolveAttachment

}

// allocFramebufferAttachmentImageInfoMemory allocates memory for type C.VkFramebufferAttachmentImageInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFramebufferAttachmentImageInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFramebufferAttachmentImageInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFramebufferAttachmentImageInfoValue = unsafe.Sizeof([1]C.VkFramebufferAttachmentImageInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FramebufferAttachmentImageInfo) Ref() *C.VkFramebufferAttachmentImageInfo {
	if x == nil {
		return nil
	}
	return x.refe569691c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FramebufferAttachmentImageInfo) Free() {
	if x != nil && x.allocse569691c != nil {
		x.allocse569691c.(*cgoAllocMap).Free()
		x.refe569691c = nil
	}
}

// NewFramebufferAttachmentImageInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFramebufferAttachmentImageInfoRef(ref unsafe.Pointer) *FramebufferAttachmentImageInfo {
	if ref == nil {
		return nil
	}
	obj := new(FramebufferAttachmentImageInfo)
	obj.refe569691c = (*C.VkFramebufferAttachmentImageInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FramebufferAttachmentImageInfo) PassRef() (*C.VkFramebufferAttachmentImageInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe569691c != nil {
		return x.refe569691c, nil
	}
	meme569691c := allocFramebufferAttachmentImageInfoMemory(1)
	refe569691c := (*C.VkFramebufferAttachmentImageInfo)(meme569691c)
	allocse569691c := new(cgoAllocMap)
	allocse569691c.Add(meme569691c)

	refe569691c.sType = (C.VkStructureType)(x.SType)

	refe569691c.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	refe569691c.flags = (C.VkImageCreateFlags)(x.Flags)

	refe569691c.usage = (C.VkImageUsageFlags)(x.Usage)

	refe569691c.width = (C.uint32_t)(x.Width)

	refe569691c.height = (C.uint32_t)(x.Height)

	refe569691c.layerCount = (C.uint32_t)(x.LayerCount)

	refe569691c.viewFormatCount = (C.uint32_t)(x.ViewFormatCount)

	if x.PViewFormats != nil {
		var cpViewFormats_allocs *cgoAllocMap
		refe569691c.pViewFormats, cpViewFormats_allocs = copyPFormatBytes((*sliceHeader)(unsafe.Pointer(&x.PViewFormats)))
		allocse569691c.Borrow(cpViewFormats_allocs)
	}

	x.refe569691c = refe569691c
	x.allocse569691c = allocse569691c
	return refe569691c, allocse569691c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FramebufferAttachmentImageInfo) PassValue() (C.VkFramebufferAttachmentImageInfo, *cgoAllocMap) {
	if x.refe569691c != nil {
		return *x.refe569691c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FramebufferAttachmentImageInfo) Deref() {
	if x.refe569691c == nil {
		return
	}
	x.SType = (StructureType)(x.refe569691c.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refe569691c.pNext))
	x.Flags = (ImageCreateFlags)(x.refe569691c.flags)
	x.Usage = (ImageUsageFlags)(x.refe569691c.usage)
	x.Width = (uint32)(x.refe569691c.width)
	x.Height = (uint32)(x.refe569691c.height)
	x.LayerCount = (uint32)(x.refe569691c.layerCount)
	x.ViewFormatCount = (uint32)(x.refe569691c.viewFormatCount)
	hxfaa359c := (*sliceHeader)(unsafe.Pointer(&x.PViewFormats))
	hxfaa359c.Data = unsafe.Pointer(x.refe569691c.pViewFormats)
	hxfaa359c.Cap = 0x7fffffff
	// hxfaa359c.Len = ? x.PViewFormats x.refe569691c.pViewFormats

}

// allocFramebufferAttachmentsCreateInfoMemory allocates memory for type C.VkFramebufferAttachmentsCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFramebufferAttachmentsCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFramebufferAttachmentsCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFramebufferAttachmentsCreateInfoValue = unsafe.Sizeof([1]C.VkFramebufferAttachmentsCreateInfo{})

// unpackSFramebufferAttachmentImageInfo transforms a sliced Go data structure into plain C format.
func unpackSFramebufferAttachmentImageInfo(x []FramebufferAttachmentImageInfo) (unpacked *C.VkFramebufferAttachmentImageInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocFramebufferAttachmentImageInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkFramebufferAttachmentImageInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkFramebufferAttachmentImageInfo)(h.Data)
	return
}

// packSFramebufferAttachmentImageInfo reads sliced Go data structure out from plain C format.
func packSFramebufferAttachmentImageInfo(v []FramebufferAttachmentImageInfo, ptr0 *C.VkFramebufferAttachmentImageInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfFramebufferAttachmentImageInfoValue]C.VkFramebufferAttachmentImageInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewFramebufferAttachmentImageInfoRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FramebufferAttachmentsCreateInfo) Ref() *C.VkFramebufferAttachmentsCreateInfo {
	if x == nil {
		return nil
	}
	return x.reff3bb4ec3
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FramebufferAttachmentsCreateInfo) Free() {
	if x != nil && x.allocsf3bb4ec3 != nil {
		x.allocsf3bb4ec3.(*cgoAllocMap).Free()
		x.reff3bb4ec3 = nil
	}
}

// NewFramebufferAttachmentsCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFramebufferAttachmentsCreateInfoRef(ref unsafe.Pointer) *FramebufferAttachmentsCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(FramebufferAttachmentsCreateInfo)
	obj.reff3bb4ec3 = (*C.VkFramebufferAttachmentsCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FramebufferAttachmentsCreateInfo) PassRef() (*C.VkFramebufferAttachmentsCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff3bb4ec3 != nil {
		return x.reff3bb4ec3, nil
	}
	memf3bb4ec3 := allocFramebufferAttachmentsCreateInfoMemory(1)
	reff3bb4ec3 := (*C.VkFramebufferAttachmentsCreateInfo)(memf3bb4ec3)
	allocsf3bb4ec3 := new(cgoAllocMap)
	allocsf3bb4ec3.Add(memf3bb4ec3)

	reff3bb4ec3.sType = (C.VkStructureType)(x.SType)

	reff3bb4ec3.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	reff3bb4ec3.attachmentImageInfoCount = (C.uint32_t)(x.AttachmentImageInfoCount)

	var cpAttachmentImageInfos_allocs *cgoAllocMap
	reff3bb4ec3.pAttachmentImageInfos, cpAttachmentImageInfos_allocs = unpackSFramebufferAttachmentImageInfo(x.PAttachmentImageInfos)
	allocsf3bb4ec3.Borrow(cpAttachmentImageInfos_allocs)

	x.reff3bb4ec3 = reff3bb4ec3
	x.allocsf3bb4ec3 = allocsf3bb4ec3
	return reff3bb4ec3, allocsf3bb4ec3

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FramebufferAttachmentsCreateInfo) PassValue() (C.VkFramebufferAttachmentsCreateInfo, *cgoAllocMap) {
	if x.reff3bb4ec3 != nil {
		return *x.reff3bb4ec3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FramebufferAttachmentsCreateInfo) Deref() {
	if x.reff3bb4ec3 == nil {
		return
	}
	x.SType = (StructureType)(x.reff3bb4ec3.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.reff3bb4ec3.pNext))
	x.AttachmentImageInfoCount = (uint32)(x.reff3bb4ec3.attachmentImageInfoCount)
	packSFramebufferAttachmentImageInfo(x.PAttachmentImageInfos, x.reff3bb4ec3.pAttachmentImageInfos)
}

// allocRenderPassAttachmentBeginInfoMemory allocates memory for type C.VkRenderPassAttachmentBeginInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRenderPassAttachmentBeginInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRenderPassAttachmentBeginInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfRenderPassAttachmentBeginInfoValue = unsafe.Sizeof([1]C.VkRenderPassAttachmentBeginInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RenderPassAttachmentBeginInfo) Ref() *C.VkRenderPassAttachmentBeginInfo {
	if x == nil {
		return nil
	}
	return x.ref5c976537
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RenderPassAttachmentBeginInfo) Free() {
	if x != nil && x.allocs5c976537 != nil {
		x.allocs5c976537.(*cgoAllocMap).Free()
		x.ref5c976537 = nil
	}
}

// NewRenderPassAttachmentBeginInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRenderPassAttachmentBeginInfoRef(ref unsafe.Pointer) *RenderPassAttachmentBeginInfo {
	if ref == nil {
		return nil
	}
	obj := new(RenderPassAttachmentBeginInfo)
	obj.ref5c976537 = (*C.VkRenderPassAttachmentBeginInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RenderPassAttachmentBeginInfo) PassRef() (*C.VkRenderPassAttachmentBeginInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5c976537 != nil {
		return x.ref5c976537, nil
	}
	mem5c976537 := allocRenderPassAttachmentBeginInfoMemory(1)
	ref5c976537 := (*C.VkRenderPassAttachmentBeginInfo)(mem5c976537)
	allocs5c976537 := new(cgoAllocMap)
	allocs5c976537.Add(mem5c976537)

	ref5c976537.sType = (C.VkStructureType)(x.SType)

	ref5c976537.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref5c976537.attachmentCount = (C.uint32_t)(x.AttachmentCount)

	if x.PAttachments != nil {
		var cpAttachments_allocs *cgoAllocMap
		ref5c976537.pAttachments, cpAttachments_allocs = copyPImageViewBytes((*sliceHeader)(unsafe.Pointer(&x.PAttachments)))
		allocs5c976537.Borrow(cpAttachments_allocs)
	}

	x.ref5c976537 = ref5c976537
	x.allocs5c976537 = allocs5c976537
	return ref5c976537, allocs5c976537

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RenderPassAttachmentBeginInfo) PassValue() (C.VkRenderPassAttachmentBeginInfo, *cgoAllocMap) {
	if x.ref5c976537 != nil {
		return *x.ref5c976537, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *RenderPassAttachmentBeginInfo) Deref() {
	if x.ref5c976537 == nil {
		return
	}
	x.SType = (StructureType)(x.ref5c976537.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref5c976537.pNext))
	x.AttachmentCount = (uint32)(x.ref5c976537.attachmentCount)
	hxfa897de := (*sliceHeader)(unsafe.Pointer(&x.PAttachments))
	hxfa897de.Data = unsafe.Pointer(x.ref5c976537.pAttachments)
	hxfa897de.Cap = 0x7fffffff
	// hxfa897de.Len = ? x.PAttachments x.ref5c976537.pAttachments

}

// allocTimelineSemaphoreSubmitInfoMemory allocates memory for type C.VkTimelineSemaphoreSubmitInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTimelineSemaphoreSubmitInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTimelineSemaphoreSubmitInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTimelineSemaphoreSubmitInfoValue = unsafe.Sizeof([1]C.VkTimelineSemaphoreSubmitInfo{})

// copyPUint64_tBytes copies the data from Go slice as *C.uint64_t.
func copyPUint64_tBytes(slice *sliceHeader) (*C.uint64_t, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfUint64_tValue) * slice.Len,
		Cap:  int(sizeOfUint64_tValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.uint64_t)(mem0), allocs
}

// allocUint64_tMemory allocates memory for type C.uint64_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocUint64_tMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfUint64_tValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfUint64_tValue = unsafe.Sizeof([1]C.uint64_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TimelineSemaphoreSubmitInfo) Ref() *C.VkTimelineSemaphoreSubmitInfo {
	if x == nil {
		return nil
	}
	return x.refc447a049
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TimelineSemaphoreSubmitInfo) Free() {
	if x != nil && x.allocsc447a049 != nil {
		x.allocsc447a049.(*cgoAllocMap).Free()
		x.refc447a049 = nil
	}
}

// NewTimelineSemaphoreSubmitInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTimelineSemaphoreSubmitInfoRef(ref unsafe.Pointer) *TimelineSemaphoreSubmitInfo {
	if ref == nil {
		return nil
	}
	obj := new(TimelineSemaphoreSubmitInfo)
	obj.refc447a049 = (*C.VkTimelineSemaphoreSubmitInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TimelineSemaphoreSubmitInfo) PassRef() (*C.VkTimelineSemaphoreSubmitInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc447a049 != nil {
		return x.refc447a049, nil
	}
	memc447a049 := allocTimelineSemaphoreSubmitInfoMemory(1)
	refc447a049 := (*C.VkTimelineSemaphoreSubmitInfo)(memc447a049)
	allocsc447a049 := new(cgoAllocMap)
	allocsc447a049.Add(memc447a049)

	refc447a049.sType = (C.VkStructureType)(x.SType)

	refc447a049.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	refc447a049.waitSemaphoreValueCount = (C.uint32_t)(x.WaitSemaphoreValueCount)

	if x.PWaitSemaphoreValues != nil {
		var cpWaitSemaphoreValues_allocs *cgoAllocMap
		refc447a049.pWaitSemaphoreValues, cpWaitSemaphoreValues_allocs = copyPUint64_tBytes((*sliceHeader)(unsafe.Pointer(&x.PWaitSemaphoreValues)))
		allocsc447a049.Borrow(cpWaitSemaphoreValues_allocs)
	}

	refc447a049.signalSemaphoreValueCount = (C.uint32_t)(x.SignalSemaphoreValueCount)

	if x.PSignalSemaphoreValues != nil {
		var cpSignalSemaphoreValues_allocs *cgoAllocMap
		refc447a049.pSignalSemaphoreValues, cpSignalSemaphoreValues_allocs = copyPUint64_tBytes((*sliceHeader)(unsafe.Pointer(&x.PSignalSemaphoreValues)))
		allocsc447a049.Borrow(cpSignalSemaphoreValues_allocs)
	}

	x.refc447a049 = refc447a049
	x.allocsc447a049 = allocsc447a049
	return refc447a049, allocsc447a049

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TimelineSemaphoreSubmitInfo) PassValue() (C.VkTimelineSemaphoreSubmitInfo, *cgoAllocMap) {
	if x.refc447a049 != nil {
		return *x.refc447a049, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TimelineSemaphoreSubmitInfo) Deref() {
	if x.refc447a049 == nil {
		return
	}
	x.SType = (StructureType)(x.refc447a049.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refc447a049.pNext))
	x.WaitSemaphoreValueCount = (uint32)(x.refc447a049.waitSemaphoreValueCount)
	hxfe33f90 := (*sliceHeader)(unsafe.Pointer(&x.PWaitSemaphoreValues))
	hxfe33f90.Data = unsafe.Pointer(x.refc447a049.pWaitSemaphoreValues)
	hxfe33f90.Cap = 0x7fffffff
	// hxfe33f90.Len = ? x.PWaitSemaphoreValues x.refc447a049.pWaitSemaphoreValues

	x.SignalSemaphoreValueCount = (uint32)(x.refc447a049.signalSemaphoreValueCount)
	hxf08bba9 := (*sliceHeader)(unsafe.Pointer(&x.PSignalSemaphoreValues))
	hxf08bba9.Data = unsafe.Pointer(x.refc447a049.pSignalSemaphoreValues)
	hxf08bba9.Cap = 0x7fffffff
	// hxf08bba9.Len = ? x.PSignalSemaphoreValues x.refc447a049.pSignalSemaphoreValues

}

// allocSemaphoreWaitInfoMemory allocates memory for type C.VkSemaphoreWaitInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSemaphoreWaitInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSemaphoreWaitInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSemaphoreWaitInfoValue = unsafe.Sizeof([1]C.VkSemaphoreWaitInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SemaphoreWaitInfo) Ref() *C.VkSemaphoreWaitInfo {
	if x == nil {
		return nil
	}
	return x.ref5e4f71e8
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SemaphoreWaitInfo) Free() {
	if x != nil && x.allocs5e4f71e8 != nil {
		x.allocs5e4f71e8.(*cgoAllocMap).Free()
		x.ref5e4f71e8 = nil
	}
}

// NewSemaphoreWaitInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSemaphoreWaitInfoRef(ref unsafe.Pointer) *SemaphoreWaitInfo {
	if ref == nil {
		return nil
	}
	obj := new(SemaphoreWaitInfo)
	obj.ref5e4f71e8 = (*C.VkSemaphoreWaitInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SemaphoreWaitInfo) PassRef() (*C.VkSemaphoreWaitInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5e4f71e8 != nil {
		return x.ref5e4f71e8, nil
	}
	mem5e4f71e8 := allocSemaphoreWaitInfoMemory(1)
	ref5e4f71e8 := (*C.VkSemaphoreWaitInfo)(mem5e4f71e8)
	allocs5e4f71e8 := new(cgoAllocMap)
	allocs5e4f71e8.Add(mem5e4f71e8)

	ref5e4f71e8.sType = (C.VkStructureType)(x.SType)

	ref5e4f71e8.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref5e4f71e8.flags = (C.VkSemaphoreWaitFlags)(x.Flags)

	ref5e4f71e8.semaphoreCount = (C.uint32_t)(x.SemaphoreCount)

	if x.PSemaphores != nil {
		var cpSemaphores_allocs *cgoAllocMap
		ref5e4f71e8.pSemaphores, cpSemaphores_allocs = copyPSemaphoreBytes((*sliceHeader)(unsafe.Pointer(&x.PSemaphores)))
		allocs5e4f71e8.Borrow(cpSemaphores_allocs)
	}

	if x.PValues != nil {
		var cpValues_allocs *cgoAllocMap
		ref5e4f71e8.pValues, cpValues_allocs = copyPUint64_tBytes((*sliceHeader)(unsafe.Pointer(&x.PValues)))
		allocs5e4f71e8.Borrow(cpValues_allocs)
	}

	x.ref5e4f71e8 = ref5e4f71e8
	x.allocs5e4f71e8 = allocs5e4f71e8
	return ref5e4f71e8, allocs5e4f71e8

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SemaphoreWaitInfo) PassValue() (C.VkSemaphoreWaitInfo, *cgoAllocMap) {
	if x.ref5e4f71e8 != nil {
		return *x.ref5e4f71e8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SemaphoreWaitInfo) Deref() {
	if x.ref5e4f71e8 == nil {
		return
	}
	x.SType = (StructureType)(x.ref5e4f71e8.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref5e4f71e8.pNext))
	x.Flags = (SemaphoreWaitFlags)(x.ref5e4f71e8.flags)
	x.SemaphoreCount = (uint32)(x.ref5e4f71e8.semaphoreCount)
	hxfd3aa9c := (*sliceHeader)(unsafe.Pointer(&x.PSemaphores))
	hxfd3aa9c.Data = unsafe.Pointer(x.ref5e4f71e8.pSemaphores)
	hxfd3aa9c.Cap = 0x7fffffff
	// hxfd3aa9c.Len = ? x.PSemaphores x.ref5e4f71e8.pSemaphores

	hxfb2f596 := (*sliceHeader)(unsafe.Pointer(&x.PValues))
	hxfb2f596.Data = unsafe.Pointer(x.ref5e4f71e8.pValues)
	hxfb2f596.Cap = 0x7fffffff
	// hxfb2f596.Len = ? x.PValues x.ref5e4f71e8.pValues

}

// allocSemaphoreSignalInfoMemory allocates memory for type C.VkSemaphoreSignalInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSemaphoreSignalInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSemaphoreSignalInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSemaphoreSignalInfoValue = unsafe.Sizeof([1]C.VkSemaphoreSignalInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SemaphoreSignalInfo) Ref() *C.VkSemaphoreSignalInfo {
	if x == nil {
		return nil
	}
	return x.ref126d16a2
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SemaphoreSignalInfo) Free() {
	if x != nil && x.allocs126d16a2 != nil {
		x.allocs126d16a2.(*cgoAllocMap).Free()
		x.ref126d16a2 = nil
	}
}

// NewSemaphoreSignalInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSemaphoreSignalInfoRef(ref unsafe.Pointer) *SemaphoreSignalInfo {
	if ref == nil {
		return nil
	}
	obj := new(SemaphoreSignalInfo)
	obj.ref126d16a2 = (*C.VkSemaphoreSignalInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SemaphoreSignalInfo) PassRef() (*C.VkSemaphoreSignalInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref126d16a2 != nil {
		return x.ref126d16a2, nil
	}
	mem126d16a2 := allocSemaphoreSignalInfoMemory(1)
	ref126d16a2 := (*C.VkSemaphoreSignalInfo)(mem126d16a2)
	allocs126d16a2 := new(cgoAllocMap)
	allocs126d16a2.Add(mem126d16a2)

	ref126d16a2.sType = (C.VkStructureType)(x.SType)

	ref126d16a2.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref126d16a2.semaphore = *(*C.VkSemaphore)(unsafe.Pointer(&x.Semaphore))

	ref126d16a2.value = (C.uint64_t)(x.Value)

	x.ref126d16a2 = ref126d16a2
	x.allocs126d16a2 = allocs126d16a2
	return ref126d16a2, allocs126d16a2

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SemaphoreSignalInfo) PassValue() (C.VkSemaphoreSignalInfo, *cgoAllocMap) {
	if x.ref126d16a2 != nil {
		return *x.ref126d16a2, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SemaphoreSignalInfo) Deref() {
	if x.ref126d16a2 == nil {
		return
	}
	x.SType = (StructureType)(x.ref126d16a2.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref126d16a2.pNext))
	x.Semaphore = *(*Semaphore)(unsafe.Pointer(&x.ref126d16a2.semaphore))
	x.Value = (uint64)(x.ref126d16a2.value)
}

// allocBufferDeviceAddressInfoMemory allocates memory for type C.VkBufferDeviceAddressInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBufferDeviceAddressInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBufferDeviceAddressInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBufferDeviceAddressInfoValue = unsafe.Sizeof([1]C.VkBufferDeviceAddressInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BufferDeviceAddressInfo) Ref() *C.VkBufferDeviceAddressInfo {
	if x == nil {
		return nil
	}
	return x.ref347b43e3
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BufferDeviceAddressInfo) Free() {
	if x != nil && x.allocs347b43e3 != nil {
		x.allocs347b43e3.(*cgoAllocMap).Free()
		x.ref347b43e3 = nil
	}
}

// NewBufferDeviceAddressInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBufferDeviceAddressInfoRef(ref unsafe.Pointer) *BufferDeviceAddressInfo {
	if ref == nil {
		return nil
	}
	obj := new(BufferDeviceAddressInfo)
	obj.ref347b43e3 = (*C.VkBufferDeviceAddressInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BufferDeviceAddressInfo) PassRef() (*C.VkBufferDeviceAddressInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref347b43e3 != nil {
		return x.ref347b43e3, nil
	}
	mem347b43e3 := allocBufferDeviceAddressInfoMemory(1)
	ref347b43e3 := (*C.VkBufferDeviceAddressInfo)(mem347b43e3)
	allocs347b43e3 := new(cgoAllocMap)
	allocs347b43e3.Add(mem347b43e3)

	ref347b43e3.sType = (C.VkStructureType)(x.SType)

	ref347b43e3.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref347b43e3.buffer = *(*C.VkBuffer)(unsafe.Pointer(&x.Buffer))

	x.ref347b43e3 = ref347b43e3
	x.allocs347b43e3 = allocs347b43e3
	return ref347b43e3, allocs347b43e3

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BufferDeviceAddressInfo) PassValue() (C.VkBufferDeviceAddressInfo, *cgoAllocMap) {
	if x.ref347b43e3 != nil {
		return *x.ref347b43e3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BufferDeviceAddressInfo) Deref() {
	if x.ref347b43e3 == nil {
		return
	}
	x.SType = (StructureType)(x.ref347b43e3.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref347b43e3.pNext))
	x.Buffer = *(*Buffer)(unsafe.Pointer(&x.ref347b43e3.buffer))
}

// allocDeviceMemoryOpaqueCaptureAddressInfoMemory allocates memory for type C.VkDeviceMemoryOpaqueCaptureAddressInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceMemoryOpaqueCaptureAddressInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceMemoryOpaqueCaptureAddressInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDeviceMemoryOpaqueCaptureAddressInfoValue = unsafe.Sizeof([1]C.VkDeviceMemoryOpaqueCaptureAddressInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DeviceMemoryOpaqueCaptureAddressInfo) Ref() *C.VkDeviceMemoryOpaqueCaptureAddressInfo {
	if x == nil {
		return nil
	}
	return x.refbbe30c6e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DeviceMemoryOpaqueCaptureAddressInfo) Free() {
	if x != nil && x.allocsbbe30c6e != nil {
		x.allocsbbe30c6e.(*cgoAllocMap).Free()
		x.refbbe30c6e = nil
	}
}

// NewDeviceMemoryOpaqueCaptureAddressInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDeviceMemoryOpaqueCaptureAddressInfoRef(ref unsafe.Pointer) *DeviceMemoryOpaqueCaptureAddressInfo {
	if ref == nil {
		return nil
	}
	obj := new(DeviceMemoryOpaqueCaptureAddressInfo)
	obj.refbbe30c6e = (*C.VkDeviceMemoryOpaqueCaptureAddressInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DeviceMemoryOpaqueCaptureAddressInfo) PassRef() (*C.VkDeviceMemoryOpaqueCaptureAddressInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refbbe30c6e != nil {
		return x.refbbe30c6e, nil
	}
	membbe30c6e := allocDeviceMemoryOpaqueCaptureAddressInfoMemory(1)
	refbbe30c6e := (*C.VkDeviceMemoryOpaqueCaptureAddressInfo)(membbe30c6e)
	allocsbbe30c6e := new(cgoAllocMap)
	allocsbbe30c6e.Add(membbe30c6e)

	refbbe30c6e.sType = (C.VkStructureType)(x.SType)

	refbbe30c6e.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	refbbe30c6e.memory = *(*C.VkDeviceMemory)(unsafe.Pointer(&x.Memory))

	x.refbbe30c6e = refbbe30c6e
	x.allocsbbe30c6e = allocsbbe30c6e
	return refbbe30c6e, allocsbbe30c6e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DeviceMemoryOpaqueCaptureAddressInfo) PassValue() (C.VkDeviceMemoryOpaqueCaptureAddressInfo, *cgoAllocMap) {
	if x.refbbe30c6e != nil {
		return *x.refbbe30c6e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DeviceMemoryOpaqueCaptureAddressInfo) Deref() {
	if x.refbbe30c6e == nil {
		return
	}
	x.SType = (StructureType)(x.refbbe30c6e.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refbbe30c6e.pNext))
	x.Memory = *(*DeviceMemory)(unsafe.Pointer(&x.refbbe30c6e.memory))
}

// allocPipelineCreationFeedbackCreateInfoMemory allocates memory for type C.VkPipelineCreationFeedbackCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineCreationFeedbackCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineCreationFeedbackCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPipelineCreationFeedbackCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineCreationFeedbackCreateInfo{})

// copyPPipelineCreationFeedbackBytes copies the data from Go slice as *C.VkPipelineCreationFeedback.
func copyPPipelineCreationFeedbackBytes(slice *sliceHeader) (*C.VkPipelineCreationFeedback, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfPipelineCreationFeedbackValue) * slice.Len,
		Cap:  int(sizeOfPipelineCreationFeedbackValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkPipelineCreationFeedback)(mem0), allocs
}

// allocPipelineCreationFeedbackMemory allocates memory for type C.VkPipelineCreationFeedback in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineCreationFeedbackMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineCreationFeedbackValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPipelineCreationFeedbackValue = unsafe.Sizeof([1]C.VkPipelineCreationFeedback{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineCreationFeedbackCreateInfo) Ref() *C.VkPipelineCreationFeedbackCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref4fcf7570
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineCreationFeedbackCreateInfo) Free() {
	if x != nil && x.allocs4fcf7570 != nil {
		x.allocs4fcf7570.(*cgoAllocMap).Free()
		x.ref4fcf7570 = nil
	}
}

// NewPipelineCreationFeedbackCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineCreationFeedbackCreateInfoRef(ref unsafe.Pointer) *PipelineCreationFeedbackCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineCreationFeedbackCreateInfo)
	obj.ref4fcf7570 = (*C.VkPipelineCreationFeedbackCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineCreationFeedbackCreateInfo) PassRef() (*C.VkPipelineCreationFeedbackCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4fcf7570 != nil {
		return x.ref4fcf7570, nil
	}
	mem4fcf7570 := allocPipelineCreationFeedbackCreateInfoMemory(1)
	ref4fcf7570 := (*C.VkPipelineCreationFeedbackCreateInfo)(mem4fcf7570)
	allocs4fcf7570 := new(cgoAllocMap)
	allocs4fcf7570.Add(mem4fcf7570)

	ref4fcf7570.sType = (C.VkStructureType)(x.SType)

	ref4fcf7570.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	if x.PPipelineCreationFeedback != nil {
		var cpPipelineCreationFeedback_allocs *cgoAllocMap
		ref4fcf7570.pPipelineCreationFeedback, cpPipelineCreationFeedback_allocs = copyPPipelineCreationFeedbackBytes((*sliceHeader)(unsafe.Pointer(&x.PPipelineCreationFeedback)))
		allocs4fcf7570.Borrow(cpPipelineCreationFeedback_allocs)
	}

	ref4fcf7570.pipelineStageCreationFeedbackCount = (C.uint32_t)(x.PipelineStageCreationFeedbackCount)

	if x.PPipelineStageCreationFeedbacks != nil {
		var cpPipelineStageCreationFeedbacks_allocs *cgoAllocMap
		ref4fcf7570.pPipelineStageCreationFeedbacks, cpPipelineStageCreationFeedbacks_allocs = copyPPipelineCreationFeedbackBytes((*sliceHeader)(unsafe.Pointer(&x.PPipelineStageCreationFeedbacks)))
		allocs4fcf7570.Borrow(cpPipelineStageCreationFeedbacks_allocs)
	}

	x.ref4fcf7570 = ref4fcf7570
	x.allocs4fcf7570 = allocs4fcf7570
	return ref4fcf7570, allocs4fcf7570

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineCreationFeedbackCreateInfo) PassValue() (C.VkPipelineCreationFeedbackCreateInfo, *cgoAllocMap) {
	if x.ref4fcf7570 != nil {
		return *x.ref4fcf7570, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineCreationFeedbackCreateInfo) Deref() {
	if x.ref4fcf7570 == nil {
		return
	}
	x.SType = (StructureType)(x.ref4fcf7570.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref4fcf7570.pNext))
	hxf11683e := (*sliceHeader)(unsafe.Pointer(&x.PPipelineCreationFeedback))
	hxf11683e.Data = unsafe.Pointer(x.ref4fcf7570.pPipelineCreationFeedback)
	hxf11683e.Cap = 0x7fffffff
	// hxf11683e.Len = ? x.PPipelineCreationFeedback x.ref4fcf7570.pPipelineCreationFeedback

	x.PipelineStageCreationFeedbackCount = (uint32)(x.ref4fcf7570.pipelineStageCreationFeedbackCount)
	hxfd9261b := (*sliceHeader)(unsafe.Pointer(&x.PPipelineStageCreationFeedbacks))
	hxfd9261b.Data = unsafe.Pointer(x.ref4fcf7570.pPipelineStageCreationFeedbacks)
	hxfd9261b.Cap = 0x7fffffff
	// hxfd9261b.Len = ? x.PPipelineStageCreationFeedbacks x.ref4fcf7570.pPipelineStageCreationFeedbacks

}

// allocPhysicalDeviceToolPropertiesMemory allocates memory for type C.VkPhysicalDeviceToolProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceToolPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceToolPropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceToolPropertiesValue = unsafe.Sizeof([1]C.VkPhysicalDeviceToolProperties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceToolProperties) Ref() *C.VkPhysicalDeviceToolProperties {
	if x == nil {
		return nil
	}
	return x.ref88f98ec3
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceToolProperties) Free() {
	if x != nil && x.allocs88f98ec3 != nil {
		x.allocs88f98ec3.(*cgoAllocMap).Free()
		x.ref88f98ec3 = nil
	}
}

// NewPhysicalDeviceToolPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceToolPropertiesRef(ref unsafe.Pointer) *PhysicalDeviceToolProperties {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceToolProperties)
	obj.ref88f98ec3 = (*C.VkPhysicalDeviceToolProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceToolProperties) PassRef() (*C.VkPhysicalDeviceToolProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref88f98ec3 != nil {
		return x.ref88f98ec3, nil
	}
	mem88f98ec3 := allocPhysicalDeviceToolPropertiesMemory(1)
	ref88f98ec3 := (*C.VkPhysicalDeviceToolProperties)(mem88f98ec3)
	allocs88f98ec3 := new(cgoAllocMap)
	allocs88f98ec3.Add(mem88f98ec3)

	ref88f98ec3.sType = (C.VkStructureType)(x.SType)

	ref88f98ec3.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref88f98ec3.name = *(*[256]C.char)(unsafe.Pointer(&x.Name))

	ref88f98ec3.version = *(*[256]C.char)(unsafe.Pointer(&x.Version))

	ref88f98ec3.purposes = (C.VkToolPurposeFlags)(x.Purposes)

	ref88f98ec3.description = *(*[256]C.char)(unsafe.Pointer(&x.Description))

	ref88f98ec3.layer = *(*[256]C.char)(unsafe.Pointer(&x.Layer))

	x.ref88f98ec3 = ref88f98ec3
	x.allocs88f98ec3 = allocs88f98ec3
	return ref88f98ec3, allocs88f98ec3

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceToolProperties) PassValue() (C.VkPhysicalDeviceToolProperties, *cgoAllocMap) {
	if x.ref88f98ec3 != nil {
		return *x.ref88f98ec3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceToolProperties) Deref() {
	if x.ref88f98ec3 == nil {
		return
	}
	x.SType = (StructureType)(x.ref88f98ec3.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref88f98ec3.pNext))
	x.Name = *(*[256]byte)(unsafe.Pointer(&x.ref88f98ec3.name))
	x.Version = *(*[256]byte)(unsafe.Pointer(&x.ref88f98ec3.version))
	x.Purposes = (ToolPurposeFlags)(x.ref88f98ec3.purposes)
	x.Description = *(*[256]byte)(unsafe.Pointer(&x.ref88f98ec3.description))
	x.Layer = *(*[256]byte)(unsafe.Pointer(&x.ref88f98ec3.layer))
}

// allocBufferMemoryBarrier2Memory allocates memory for type C.VkBufferMemoryBarrier2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBufferMemoryBarrier2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBufferMemoryBarrier2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBufferMemoryBarrier2Value = unsafe.Sizeof([1]C.VkBufferMemoryBarrier2{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BufferMemoryBarrier2) Ref() *C.VkBufferMemoryBarrier2 {
	if x == nil {
		return nil
	}
	return x.ref8ded93f5
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BufferMemoryBarrier2) Free() {
	if x != nil && x.allocs8ded93f5 != nil {
		x.allocs8ded93f5.(*cgoAllocMap).Free()
		x.ref8ded93f5 = nil
	}
}

// NewBufferMemoryBarrier2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBufferMemoryBarrier2Ref(ref unsafe.Pointer) *BufferMemoryBarrier2 {
	if ref == nil {
		return nil
	}
	obj := new(BufferMemoryBarrier2)
	obj.ref8ded93f5 = (*C.VkBufferMemoryBarrier2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BufferMemoryBarrier2) PassRef() (*C.VkBufferMemoryBarrier2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref8ded93f5 != nil {
		return x.ref8ded93f5, nil
	}
	mem8ded93f5 := allocBufferMemoryBarrier2Memory(1)
	ref8ded93f5 := (*C.VkBufferMemoryBarrier2)(mem8ded93f5)
	allocs8ded93f5 := new(cgoAllocMap)
	allocs8ded93f5.Add(mem8ded93f5)

	ref8ded93f5.sType = (C.VkStructureType)(x.SType)

	ref8ded93f5.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref8ded93f5.srcStageMask = (C.VkPipelineStageFlags2)(x.SrcStageMask)

	ref8ded93f5.srcAccessMask = (C.VkAccessFlags2)(x.SrcAccessMask)

	ref8ded93f5.dstStageMask = (C.VkPipelineStageFlags2)(x.DstStageMask)

	ref8ded93f5.dstAccessMask = (C.VkAccessFlags2)(x.DstAccessMask)

	ref8ded93f5.srcQueueFamilyIndex = (C.uint32_t)(x.SrcQueueFamilyIndex)

	ref8ded93f5.dstQueueFamilyIndex = (C.uint32_t)(x.DstQueueFamilyIndex)

	ref8ded93f5.buffer = *(*C.VkBuffer)(unsafe.Pointer(&x.Buffer))

	ref8ded93f5.offset = (C.VkDeviceSize)(x.Offset)

	ref8ded93f5.size = (C.VkDeviceSize)(x.Size)

	x.ref8ded93f5 = ref8ded93f5
	x.allocs8ded93f5 = allocs8ded93f5
	return ref8ded93f5, allocs8ded93f5

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BufferMemoryBarrier2) PassValue() (C.VkBufferMemoryBarrier2, *cgoAllocMap) {
	if x.ref8ded93f5 != nil {
		return *x.ref8ded93f5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BufferMemoryBarrier2) Deref() {
	if x.ref8ded93f5 == nil {
		return
	}
	x.SType = (StructureType)(x.ref8ded93f5.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref8ded93f5.pNext))
	x.SrcStageMask = (PipelineStageFlags2)(x.ref8ded93f5.srcStageMask)
	x.SrcAccessMask = (AccessFlags2)(x.ref8ded93f5.srcAccessMask)
	x.DstStageMask = (PipelineStageFlags2)(x.ref8ded93f5.dstStageMask)
	x.DstAccessMask = (AccessFlags2)(x.ref8ded93f5.dstAccessMask)
	x.SrcQueueFamilyIndex = (uint32)(x.ref8ded93f5.srcQueueFamilyIndex)
	x.DstQueueFamilyIndex = (uint32)(x.ref8ded93f5.dstQueueFamilyIndex)
	x.Buffer = *(*Buffer)(unsafe.Pointer(&x.ref8ded93f5.buffer))
	x.Offset = (DeviceSize)(x.ref8ded93f5.offset)
	x.Size = (DeviceSize)(x.ref8ded93f5.size)
}

// allocImageMemoryBarrier2Memory allocates memory for type C.VkImageMemoryBarrier2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageMemoryBarrier2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageMemoryBarrier2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfImageMemoryBarrier2Value = unsafe.Sizeof([1]C.VkImageMemoryBarrier2{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImageMemoryBarrier2) Ref() *C.VkImageMemoryBarrier2 {
	if x == nil {
		return nil
	}
	return x.refb3bc376a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImageMemoryBarrier2) Free() {
	if x != nil && x.allocsb3bc376a != nil {
		x.allocsb3bc376a.(*cgoAllocMap).Free()
		x.refb3bc376a = nil
	}
}

// NewImageMemoryBarrier2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageMemoryBarrier2Ref(ref unsafe.Pointer) *ImageMemoryBarrier2 {
	if ref == nil {
		return nil
	}
	obj := new(ImageMemoryBarrier2)
	obj.refb3bc376a = (*C.VkImageMemoryBarrier2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImageMemoryBarrier2) PassRef() (*C.VkImageMemoryBarrier2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb3bc376a != nil {
		return x.refb3bc376a, nil
	}
	memb3bc376a := allocImageMemoryBarrier2Memory(1)
	refb3bc376a := (*C.VkImageMemoryBarrier2)(memb3bc376a)
	allocsb3bc376a := new(cgoAllocMap)
	allocsb3bc376a.Add(memb3bc376a)

	refb3bc376a.sType = (C.VkStructureType)(x.SType)

	refb3bc376a.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	refb3bc376a.srcStageMask = (C.VkPipelineStageFlags2)(x.SrcStageMask)

	refb3bc376a.srcAccessMask = (C.VkAccessFlags2)(x.SrcAccessMask)

	refb3bc376a.dstStageMask = (C.VkPipelineStageFlags2)(x.DstStageMask)

	refb3bc376a.dstAccessMask = (C.VkAccessFlags2)(x.DstAccessMask)

	refb3bc376a.oldLayout = (C.VkImageLayout)(x.OldLayout)

	refb3bc376a.newLayout = (C.VkImageLayout)(x.NewLayout)

	refb3bc376a.srcQueueFamilyIndex = (C.uint32_t)(x.SrcQueueFamilyIndex)

	refb3bc376a.dstQueueFamilyIndex = (C.uint32_t)(x.DstQueueFamilyIndex)

	refb3bc376a.image = *(*C.VkImage)(unsafe.Pointer(&x.Image))

	refb3bc376a.subresourceRange = *(*C.VkImageSubresourceRange)(unsafe.Pointer(&x.SubresourceRange))

	x.refb3bc376a = refb3bc376a
	x.allocsb3bc376a = allocsb3bc376a
	return refb3bc376a, allocsb3bc376a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImageMemoryBarrier2) PassValue() (C.VkImageMemoryBarrier2, *cgoAllocMap) {
	if x.refb3bc376a != nil {
		return *x.refb3bc376a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImageMemoryBarrier2) Deref() {
	if x.refb3bc376a == nil {
		return
	}
	x.SType = (StructureType)(x.refb3bc376a.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refb3bc376a.pNext))
	x.SrcStageMask = (PipelineStageFlags2)(x.refb3bc376a.srcStageMask)
	x.SrcAccessMask = (AccessFlags2)(x.refb3bc376a.srcAccessMask)
	x.DstStageMask = (PipelineStageFlags2)(x.refb3bc376a.dstStageMask)
	x.DstAccessMask = (AccessFlags2)(x.refb3bc376a.dstAccessMask)
	x.OldLayout = (ImageLayout)(x.refb3bc376a.oldLayout)
	x.NewLayout = (ImageLayout)(x.refb3bc376a.newLayout)
	x.SrcQueueFamilyIndex = (uint32)(x.refb3bc376a.srcQueueFamilyIndex)
	x.DstQueueFamilyIndex = (uint32)(x.refb3bc376a.dstQueueFamilyIndex)
	x.Image = *(*Image)(unsafe.Pointer(&x.refb3bc376a.image))
	x.SubresourceRange = *(*ImageSubresourceRange)(unsafe.Pointer(&x.refb3bc376a.subresourceRange))
}

// allocDependencyInfoMemory allocates memory for type C.VkDependencyInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDependencyInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDependencyInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDependencyInfoValue = unsafe.Sizeof([1]C.VkDependencyInfo{})

// copyPMemoryBarrier2Bytes copies the data from Go slice as *C.VkMemoryBarrier2.
func copyPMemoryBarrier2Bytes(slice *sliceHeader) (*C.VkMemoryBarrier2, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfMemoryBarrier2Value) * slice.Len,
		Cap:  int(sizeOfMemoryBarrier2Value) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkMemoryBarrier2)(mem0), allocs
}

// allocMemoryBarrier2Memory allocates memory for type C.VkMemoryBarrier2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMemoryBarrier2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMemoryBarrier2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfMemoryBarrier2Value = unsafe.Sizeof([1]C.VkMemoryBarrier2{})

// unpackSBufferMemoryBarrier2 transforms a sliced Go data structure into plain C format.
func unpackSBufferMemoryBarrier2(x []BufferMemoryBarrier2) (unpacked *C.VkBufferMemoryBarrier2, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocBufferMemoryBarrier2Memory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkBufferMemoryBarrier2)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkBufferMemoryBarrier2)(h.Data)
	return
}

// unpackSImageMemoryBarrier2 transforms a sliced Go data structure into plain C format.
func unpackSImageMemoryBarrier2(x []ImageMemoryBarrier2) (unpacked *C.VkImageMemoryBarrier2, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocImageMemoryBarrier2Memory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkImageMemoryBarrier2)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkImageMemoryBarrier2)(h.Data)
	return
}

// packSBufferMemoryBarrier2 reads sliced Go data structure out from plain C format.
func packSBufferMemoryBarrier2(v []BufferMemoryBarrier2, ptr0 *C.VkBufferMemoryBarrier2) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfBufferMemoryBarrier2Value]C.VkBufferMemoryBarrier2)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewBufferMemoryBarrier2Ref(unsafe.Pointer(&ptr1))
	}
}

// packSImageMemoryBarrier2 reads sliced Go data structure out from plain C format.
func packSImageMemoryBarrier2(v []ImageMemoryBarrier2, ptr0 *C.VkImageMemoryBarrier2) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfImageMemoryBarrier2Value]C.VkImageMemoryBarrier2)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewImageMemoryBarrier2Ref(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DependencyInfo) Ref() *C.VkDependencyInfo {
	if x == nil {
		return nil
	}
	return x.ref18c760d2
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DependencyInfo) Free() {
	if x != nil && x.allocs18c760d2 != nil {
		x.allocs18c760d2.(*cgoAllocMap).Free()
		x.ref18c760d2 = nil
	}
}

// NewDependencyInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDependencyInfoRef(ref unsafe.Pointer) *DependencyInfo {
	if ref == nil {
		return nil
	}
	obj := new(DependencyInfo)
	obj.ref18c760d2 = (*C.VkDependencyInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DependencyInfo) PassRef() (*C.VkDependencyInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref18c760d2 != nil {
		return x.ref18c760d2, nil
	}
	mem18c760d2 := allocDependencyInfoMemory(1)
	ref18c760d2 := (*C.VkDependencyInfo)(mem18c760d2)
	allocs18c760d2 := new(cgoAllocMap)
	allocs18c760d2.Add(mem18c760d2)

	ref18c760d2.sType = (C.VkStructureType)(x.SType)

	ref18c760d2.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref18c760d2.dependencyFlags = (C.VkDependencyFlags)(x.DependencyFlags)

	ref18c760d2.memoryBarrierCount = (C.uint32_t)(x.MemoryBarrierCount)

	if x.PMemoryBarriers != nil {
		var cpMemoryBarriers_allocs *cgoAllocMap
		ref18c760d2.pMemoryBarriers, cpMemoryBarriers_allocs = copyPMemoryBarrier2Bytes((*sliceHeader)(unsafe.Pointer(&x.PMemoryBarriers)))
		allocs18c760d2.Borrow(cpMemoryBarriers_allocs)
	}

	ref18c760d2.bufferMemoryBarrierCount = (C.uint32_t)(x.BufferMemoryBarrierCount)

	var cpBufferMemoryBarriers_allocs *cgoAllocMap
	ref18c760d2.pBufferMemoryBarriers, cpBufferMemoryBarriers_allocs = unpackSBufferMemoryBarrier2(x.PBufferMemoryBarriers)
	allocs18c760d2.Borrow(cpBufferMemoryBarriers_allocs)

	ref18c760d2.imageMemoryBarrierCount = (C.uint32_t)(x.ImageMemoryBarrierCount)

	var cpImageMemoryBarriers_allocs *cgoAllocMap
	ref18c760d2.pImageMemoryBarriers, cpImageMemoryBarriers_allocs = unpackSImageMemoryBarrier2(x.PImageMemoryBarriers)
	allocs18c760d2.Borrow(cpImageMemoryBarriers_allocs)

	x.ref18c760d2 = ref18c760d2
	x.allocs18c760d2 = allocs18c760d2
	return ref18c760d2, allocs18c760d2

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DependencyInfo) PassValue() (C.VkDependencyInfo, *cgoAllocMap) {
	if x.ref18c760d2 != nil {
		return *x.ref18c760d2, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DependencyInfo) Deref() {
	if x.ref18c760d2 == nil {
		return
	}
	x.SType = (StructureType)(x.ref18c760d2.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref18c760d2.pNext))
	x.DependencyFlags = (DependencyFlags)(x.ref18c760d2.dependencyFlags)
	x.MemoryBarrierCount = (uint32)(x.ref18c760d2.memoryBarrierCount)
	hxf77d2ac := (*sliceHeader)(unsafe.Pointer(&x.PMemoryBarriers))
	hxf77d2ac.Data = unsafe.Pointer(x.ref18c760d2.pMemoryBarriers)
	hxf77d2ac.Cap = 0x7fffffff
	// hxf77d2ac.Len = ? x.PMemoryBarriers x.ref18c760d2.pMemoryBarriers

	x.BufferMemoryBarrierCount = (uint32)(x.ref18c760d2.bufferMemoryBarrierCount)
	packSBufferMemoryBarrier2(x.PBufferMemoryBarriers, x.ref18c760d2.pBufferMemoryBarriers)
	x.ImageMemoryBarrierCount = (uint32)(x.ref18c760d2.imageMemoryBarrierCount)
	packSImageMemoryBarrier2(x.PImageMemoryBarriers, x.ref18c760d2.pImageMemoryBarriers)
}

// allocSemaphoreSubmitInfoMemory allocates memory for type C.VkSemaphoreSubmitInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSemaphoreSubmitInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSemaphoreSubmitInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSemaphoreSubmitInfoValue = unsafe.Sizeof([1]C.VkSemaphoreSubmitInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SemaphoreSubmitInfo) Ref() *C.VkSemaphoreSubmitInfo {
	if x == nil {
		return nil
	}
	return x.ref9d52ed10
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SemaphoreSubmitInfo) Free() {
	if x != nil && x.allocs9d52ed10 != nil {
		x.allocs9d52ed10.(*cgoAllocMap).Free()
		x.ref9d52ed10 = nil
	}
}

// NewSemaphoreSubmitInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSemaphoreSubmitInfoRef(ref unsafe.Pointer) *SemaphoreSubmitInfo {
	if ref == nil {
		return nil
	}
	obj := new(SemaphoreSubmitInfo)
	obj.ref9d52ed10 = (*C.VkSemaphoreSubmitInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SemaphoreSubmitInfo) PassRef() (*C.VkSemaphoreSubmitInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9d52ed10 != nil {
		return x.ref9d52ed10, nil
	}
	mem9d52ed10 := allocSemaphoreSubmitInfoMemory(1)
	ref9d52ed10 := (*C.VkSemaphoreSubmitInfo)(mem9d52ed10)
	allocs9d52ed10 := new(cgoAllocMap)
	allocs9d52ed10.Add(mem9d52ed10)

	ref9d52ed10.sType = (C.VkStructureType)(x.SType)

	ref9d52ed10.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref9d52ed10.semaphore = *(*C.VkSemaphore)(unsafe.Pointer(&x.Semaphore))

	ref9d52ed10.value = (C.uint64_t)(x.Value)

	ref9d52ed10.stageMask = (C.VkPipelineStageFlags2)(x.StageMask)

	ref9d52ed10.deviceIndex = (C.uint32_t)(x.DeviceIndex)

	x.ref9d52ed10 = ref9d52ed10
	x.allocs9d52ed10 = allocs9d52ed10
	return ref9d52ed10, allocs9d52ed10

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SemaphoreSubmitInfo) PassValue() (C.VkSemaphoreSubmitInfo, *cgoAllocMap) {
	if x.ref9d52ed10 != nil {
		return *x.ref9d52ed10, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SemaphoreSubmitInfo) Deref() {
	if x.ref9d52ed10 == nil {
		return
	}
	x.SType = (StructureType)(x.ref9d52ed10.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref9d52ed10.pNext))
	x.Semaphore = *(*Semaphore)(unsafe.Pointer(&x.ref9d52ed10.semaphore))
	x.Value = (uint64)(x.ref9d52ed10.value)
	x.StageMask = (PipelineStageFlags2)(x.ref9d52ed10.stageMask)
	x.DeviceIndex = (uint32)(x.ref9d52ed10.deviceIndex)
}

// allocCommandBufferSubmitInfoMemory allocates memory for type C.VkCommandBufferSubmitInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCommandBufferSubmitInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCommandBufferSubmitInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCommandBufferSubmitInfoValue = unsafe.Sizeof([1]C.VkCommandBufferSubmitInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CommandBufferSubmitInfo) Ref() *C.VkCommandBufferSubmitInfo {
	if x == nil {
		return nil
	}
	return x.ref67c6884a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CommandBufferSubmitInfo) Free() {
	if x != nil && x.allocs67c6884a != nil {
		x.allocs67c6884a.(*cgoAllocMap).Free()
		x.ref67c6884a = nil
	}
}

// NewCommandBufferSubmitInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCommandBufferSubmitInfoRef(ref unsafe.Pointer) *CommandBufferSubmitInfo {
	if ref == nil {
		return nil
	}
	obj := new(CommandBufferSubmitInfo)
	obj.ref67c6884a = (*C.VkCommandBufferSubmitInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CommandBufferSubmitInfo) PassRef() (*C.VkCommandBufferSubmitInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref67c6884a != nil {
		return x.ref67c6884a, nil
	}
	mem67c6884a := allocCommandBufferSubmitInfoMemory(1)
	ref67c6884a := (*C.VkCommandBufferSubmitInfo)(mem67c6884a)
	allocs67c6884a := new(cgoAllocMap)
	allocs67c6884a.Add(mem67c6884a)

	ref67c6884a.sType = (C.VkStructureType)(x.SType)

	ref67c6884a.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref67c6884a.commandBuffer = *(*C.VkCommandBuffer)(unsafe.Pointer(&x.CommandBuffer))

	ref67c6884a.deviceMask = (C.uint32_t)(x.DeviceMask)

	x.ref67c6884a = ref67c6884a
	x.allocs67c6884a = allocs67c6884a
	return ref67c6884a, allocs67c6884a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CommandBufferSubmitInfo) PassValue() (C.VkCommandBufferSubmitInfo, *cgoAllocMap) {
	if x.ref67c6884a != nil {
		return *x.ref67c6884a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CommandBufferSubmitInfo) Deref() {
	if x.ref67c6884a == nil {
		return
	}
	x.SType = (StructureType)(x.ref67c6884a.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref67c6884a.pNext))
	x.CommandBuffer = *(*CommandBuffer)(unsafe.Pointer(&x.ref67c6884a.commandBuffer))
	x.DeviceMask = (uint32)(x.ref67c6884a.deviceMask)
}

// allocSubmitInfo2Memory allocates memory for type C.VkSubmitInfo2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSubmitInfo2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSubmitInfo2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSubmitInfo2Value = unsafe.Sizeof([1]C.VkSubmitInfo2{})

// unpackSSemaphoreSubmitInfo transforms a sliced Go data structure into plain C format.
func unpackSSemaphoreSubmitInfo(x []SemaphoreSubmitInfo) (unpacked *C.VkSemaphoreSubmitInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocSemaphoreSubmitInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSemaphoreSubmitInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSemaphoreSubmitInfo)(h.Data)
	return
}

// unpackSCommandBufferSubmitInfo transforms a sliced Go data structure into plain C format.
func unpackSCommandBufferSubmitInfo(x []CommandBufferSubmitInfo) (unpacked *C.VkCommandBufferSubmitInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocCommandBufferSubmitInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkCommandBufferSubmitInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkCommandBufferSubmitInfo)(h.Data)
	return
}

// packSSemaphoreSubmitInfo reads sliced Go data structure out from plain C format.
func packSSemaphoreSubmitInfo(v []SemaphoreSubmitInfo, ptr0 *C.VkSemaphoreSubmitInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSemaphoreSubmitInfoValue]C.VkSemaphoreSubmitInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSemaphoreSubmitInfoRef(unsafe.Pointer(&ptr1))
	}
}

// packSCommandBufferSubmitInfo reads sliced Go data structure out from plain C format.
func packSCommandBufferSubmitInfo(v []CommandBufferSubmitInfo, ptr0 *C.VkCommandBufferSubmitInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfCommandBufferSubmitInfoValue]C.VkCommandBufferSubmitInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewCommandBufferSubmitInfoRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SubmitInfo2) Ref() *C.VkSubmitInfo2 {
	if x == nil {
		return nil
	}
	return x.ref51f3e20a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SubmitInfo2) Free() {
	if x != nil && x.allocs51f3e20a != nil {
		x.allocs51f3e20a.(*cgoAllocMap).Free()
		x.ref51f3e20a = nil
	}
}

// NewSubmitInfo2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSubmitInfo2Ref(ref unsafe.Pointer) *SubmitInfo2 {
	if ref == nil {
		return nil
	}
	obj := new(SubmitInfo2)
	obj.ref51f3e20a = (*C.VkSubmitInfo2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SubmitInfo2) PassRef() (*C.VkSubmitInfo2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref51f3e20a != nil {
		return x.ref51f3e20a, nil
	}
	mem51f3e20a := allocSubmitInfo2Memory(1)
	ref51f3e20a := (*C.VkSubmitInfo2)(mem51f3e20a)
	allocs51f3e20a := new(cgoAllocMap)
	allocs51f3e20a.Add(mem51f3e20a)

	ref51f3e20a.sType = (C.VkStructureType)(x.SType)

	ref51f3e20a.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref51f3e20a.flags = (C.VkSubmitFlags)(x.Flags)

	ref51f3e20a.waitSemaphoreInfoCount = (C.uint32_t)(x.WaitSemaphoreInfoCount)

	var cpWaitSemaphoreInfos_allocs *cgoAllocMap
	ref51f3e20a.pWaitSemaphoreInfos, cpWaitSemaphoreInfos_allocs = unpackSSemaphoreSubmitInfo(x.PWaitSemaphoreInfos)
	allocs51f3e20a.Borrow(cpWaitSemaphoreInfos_allocs)

	ref51f3e20a.commandBufferInfoCount = (C.uint32_t)(x.CommandBufferInfoCount)

	var cpCommandBufferInfos_allocs *cgoAllocMap
	ref51f3e20a.pCommandBufferInfos, cpCommandBufferInfos_allocs = unpackSCommandBufferSubmitInfo(x.PCommandBufferInfos)
	allocs51f3e20a.Borrow(cpCommandBufferInfos_allocs)

	ref51f3e20a.signalSemaphoreInfoCount = (C.uint32_t)(x.SignalSemaphoreInfoCount)

	var cpSignalSemaphoreInfos_allocs *cgoAllocMap
	ref51f3e20a.pSignalSemaphoreInfos, cpSignalSemaphoreInfos_allocs = unpackSSemaphoreSubmitInfo(x.PSignalSemaphoreInfos)
	allocs51f3e20a.Borrow(cpSignalSemaphoreInfos_allocs)

	x.ref51f3e20a = ref51f3e20a
	x.allocs51f3e20a = allocs51f3e20a
	return ref51f3e20a, allocs51f3e20a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SubmitInfo2) PassValue() (C.VkSubmitInfo2, *cgoAllocMap) {
	if x.ref51f3e20a != nil {
		return *x.ref51f3e20a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SubmitInfo2) Deref() {
	if x.ref51f3e20a == nil {
		return
	}
	x.SType = (StructureType)(x.ref51f3e20a.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref51f3e20a.pNext))
	x.Flags = (SubmitFlags)(x.ref51f3e20a.flags)
	x.WaitSemaphoreInfoCount = (uint32)(x.ref51f3e20a.waitSemaphoreInfoCount)
	packSSemaphoreSubmitInfo(x.PWaitSemaphoreInfos, x.ref51f3e20a.pWaitSemaphoreInfos)
	x.CommandBufferInfoCount = (uint32)(x.ref51f3e20a.commandBufferInfoCount)
	packSCommandBufferSubmitInfo(x.PCommandBufferInfos, x.ref51f3e20a.pCommandBufferInfos)
	x.SignalSemaphoreInfoCount = (uint32)(x.ref51f3e20a.signalSemaphoreInfoCount)
	packSSemaphoreSubmitInfo(x.PSignalSemaphoreInfos, x.ref51f3e20a.pSignalSemaphoreInfos)
}

// allocCopyBufferInfo2Memory allocates memory for type C.VkCopyBufferInfo2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCopyBufferInfo2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCopyBufferInfo2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCopyBufferInfo2Value = unsafe.Sizeof([1]C.VkCopyBufferInfo2{})

// copyPBufferCopy2Bytes copies the data from Go slice as *C.VkBufferCopy2.
func copyPBufferCopy2Bytes(slice *sliceHeader) (*C.VkBufferCopy2, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfBufferCopy2Value) * slice.Len,
		Cap:  int(sizeOfBufferCopy2Value) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkBufferCopy2)(mem0), allocs
}

// allocBufferCopy2Memory allocates memory for type C.VkBufferCopy2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBufferCopy2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBufferCopy2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBufferCopy2Value = unsafe.Sizeof([1]C.VkBufferCopy2{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CopyBufferInfo2) Ref() *C.VkCopyBufferInfo2 {
	if x == nil {
		return nil
	}
	return x.ref95a1aa26
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CopyBufferInfo2) Free() {
	if x != nil && x.allocs95a1aa26 != nil {
		x.allocs95a1aa26.(*cgoAllocMap).Free()
		x.ref95a1aa26 = nil
	}
}

// NewCopyBufferInfo2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCopyBufferInfo2Ref(ref unsafe.Pointer) *CopyBufferInfo2 {
	if ref == nil {
		return nil
	}
	obj := new(CopyBufferInfo2)
	obj.ref95a1aa26 = (*C.VkCopyBufferInfo2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CopyBufferInfo2) PassRef() (*C.VkCopyBufferInfo2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref95a1aa26 != nil {
		return x.ref95a1aa26, nil
	}
	mem95a1aa26 := allocCopyBufferInfo2Memory(1)
	ref95a1aa26 := (*C.VkCopyBufferInfo2)(mem95a1aa26)
	allocs95a1aa26 := new(cgoAllocMap)
	allocs95a1aa26.Add(mem95a1aa26)

	ref95a1aa26.sType = (C.VkStructureType)(x.SType)

	ref95a1aa26.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref95a1aa26.srcBuffer = *(*C.VkBuffer)(unsafe.Pointer(&x.SrcBuffer))

	ref95a1aa26.dstBuffer = *(*C.VkBuffer)(unsafe.Pointer(&x.DstBuffer))

	ref95a1aa26.regionCount = (C.uint32_t)(x.RegionCount)

	if x.PRegions != nil {
		var cpRegions_allocs *cgoAllocMap
		ref95a1aa26.pRegions, cpRegions_allocs = copyPBufferCopy2Bytes((*sliceHeader)(unsafe.Pointer(&x.PRegions)))
		allocs95a1aa26.Borrow(cpRegions_allocs)
	}

	x.ref95a1aa26 = ref95a1aa26
	x.allocs95a1aa26 = allocs95a1aa26
	return ref95a1aa26, allocs95a1aa26

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CopyBufferInfo2) PassValue() (C.VkCopyBufferInfo2, *cgoAllocMap) {
	if x.ref95a1aa26 != nil {
		return *x.ref95a1aa26, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CopyBufferInfo2) Deref() {
	if x.ref95a1aa26 == nil {
		return
	}
	x.SType = (StructureType)(x.ref95a1aa26.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref95a1aa26.pNext))
	x.SrcBuffer = *(*Buffer)(unsafe.Pointer(&x.ref95a1aa26.srcBuffer))
	x.DstBuffer = *(*Buffer)(unsafe.Pointer(&x.ref95a1aa26.dstBuffer))
	x.RegionCount = (uint32)(x.ref95a1aa26.regionCount)
	hxff6a91e := (*sliceHeader)(unsafe.Pointer(&x.PRegions))
	hxff6a91e.Data = unsafe.Pointer(x.ref95a1aa26.pRegions)
	hxff6a91e.Cap = 0x7fffffff
	// hxff6a91e.Len = ? x.PRegions x.ref95a1aa26.pRegions

}

// allocCopyImageInfo2Memory allocates memory for type C.VkCopyImageInfo2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCopyImageInfo2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCopyImageInfo2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCopyImageInfo2Value = unsafe.Sizeof([1]C.VkCopyImageInfo2{})

// copyPImageCopy2Bytes copies the data from Go slice as *C.VkImageCopy2.
func copyPImageCopy2Bytes(slice *sliceHeader) (*C.VkImageCopy2, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfImageCopy2Value) * slice.Len,
		Cap:  int(sizeOfImageCopy2Value) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkImageCopy2)(mem0), allocs
}

// allocImageCopy2Memory allocates memory for type C.VkImageCopy2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageCopy2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageCopy2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfImageCopy2Value = unsafe.Sizeof([1]C.VkImageCopy2{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CopyImageInfo2) Ref() *C.VkCopyImageInfo2 {
	if x == nil {
		return nil
	}
	return x.ref73df1447
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CopyImageInfo2) Free() {
	if x != nil && x.allocs73df1447 != nil {
		x.allocs73df1447.(*cgoAllocMap).Free()
		x.ref73df1447 = nil
	}
}

// NewCopyImageInfo2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCopyImageInfo2Ref(ref unsafe.Pointer) *CopyImageInfo2 {
	if ref == nil {
		return nil
	}
	obj := new(CopyImageInfo2)
	obj.ref73df1447 = (*C.VkCopyImageInfo2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CopyImageInfo2) PassRef() (*C.VkCopyImageInfo2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref73df1447 != nil {
		return x.ref73df1447, nil
	}
	mem73df1447 := allocCopyImageInfo2Memory(1)
	ref73df1447 := (*C.VkCopyImageInfo2)(mem73df1447)
	allocs73df1447 := new(cgoAllocMap)
	allocs73df1447.Add(mem73df1447)

	ref73df1447.sType = (C.VkStructureType)(x.SType)

	ref73df1447.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref73df1447.srcImage = *(*C.VkImage)(unsafe.Pointer(&x.SrcImage))

	ref73df1447.srcImageLayout = (C.VkImageLayout)(x.SrcImageLayout)

	ref73df1447.dstImage = *(*C.VkImage)(unsafe.Pointer(&x.DstImage))

	ref73df1447.dstImageLayout = (C.VkImageLayout)(x.DstImageLayout)

	ref73df1447.regionCount = (C.uint32_t)(x.RegionCount)

	if x.PRegions != nil {
		var cpRegions_allocs *cgoAllocMap
		ref73df1447.pRegions, cpRegions_allocs = copyPImageCopy2Bytes((*sliceHeader)(unsafe.Pointer(&x.PRegions)))
		allocs73df1447.Borrow(cpRegions_allocs)
	}

	x.ref73df1447 = ref73df1447
	x.allocs73df1447 = allocs73df1447
	return ref73df1447, allocs73df1447

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CopyImageInfo2) PassValue() (C.VkCopyImageInfo2, *cgoAllocMap) {
	if x.ref73df1447 != nil {
		return *x.ref73df1447, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CopyImageInfo2) Deref() {
	if x.ref73df1447 == nil {
		return
	}
	x.SType = (StructureType)(x.ref73df1447.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref73df1447.pNext))
	x.SrcImage = *(*Image)(unsafe.Pointer(&x.ref73df1447.srcImage))
	x.SrcImageLayout = (ImageLayout)(x.ref73df1447.srcImageLayout)
	x.DstImage = *(*Image)(unsafe.Pointer(&x.ref73df1447.dstImage))
	x.DstImageLayout = (ImageLayout)(x.ref73df1447.dstImageLayout)
	x.RegionCount = (uint32)(x.ref73df1447.regionCount)
	hxf971c70 := (*sliceHeader)(unsafe.Pointer(&x.PRegions))
	hxf971c70.Data = unsafe.Pointer(x.ref73df1447.pRegions)
	hxf971c70.Cap = 0x7fffffff
	// hxf971c70.Len = ? x.PRegions x.ref73df1447.pRegions

}

// allocCopyBufferToImageInfo2Memory allocates memory for type C.VkCopyBufferToImageInfo2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCopyBufferToImageInfo2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCopyBufferToImageInfo2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCopyBufferToImageInfo2Value = unsafe.Sizeof([1]C.VkCopyBufferToImageInfo2{})

// copyPBufferImageCopy2Bytes copies the data from Go slice as *C.VkBufferImageCopy2.
func copyPBufferImageCopy2Bytes(slice *sliceHeader) (*C.VkBufferImageCopy2, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfBufferImageCopy2Value) * slice.Len,
		Cap:  int(sizeOfBufferImageCopy2Value) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkBufferImageCopy2)(mem0), allocs
}

// allocBufferImageCopy2Memory allocates memory for type C.VkBufferImageCopy2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBufferImageCopy2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBufferImageCopy2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBufferImageCopy2Value = unsafe.Sizeof([1]C.VkBufferImageCopy2{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CopyBufferToImageInfo2) Ref() *C.VkCopyBufferToImageInfo2 {
	if x == nil {
		return nil
	}
	return x.refa8b5363c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CopyBufferToImageInfo2) Free() {
	if x != nil && x.allocsa8b5363c != nil {
		x.allocsa8b5363c.(*cgoAllocMap).Free()
		x.refa8b5363c = nil
	}
}

// NewCopyBufferToImageInfo2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCopyBufferToImageInfo2Ref(ref unsafe.Pointer) *CopyBufferToImageInfo2 {
	if ref == nil {
		return nil
	}
	obj := new(CopyBufferToImageInfo2)
	obj.refa8b5363c = (*C.VkCopyBufferToImageInfo2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CopyBufferToImageInfo2) PassRef() (*C.VkCopyBufferToImageInfo2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa8b5363c != nil {
		return x.refa8b5363c, nil
	}
	mema8b5363c := allocCopyBufferToImageInfo2Memory(1)
	refa8b5363c := (*C.VkCopyBufferToImageInfo2)(mema8b5363c)
	allocsa8b5363c := new(cgoAllocMap)
	allocsa8b5363c.Add(mema8b5363c)

	refa8b5363c.sType = (C.VkStructureType)(x.SType)

	refa8b5363c.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	refa8b5363c.srcBuffer = *(*C.VkBuffer)(unsafe.Pointer(&x.SrcBuffer))

	refa8b5363c.dstImage = *(*C.VkImage)(unsafe.Pointer(&x.DstImage))

	refa8b5363c.dstImageLayout = (C.VkImageLayout)(x.DstImageLayout)

	refa8b5363c.regionCount = (C.uint32_t)(x.RegionCount)

	if x.PRegions != nil {
		var cpRegions_allocs *cgoAllocMap
		refa8b5363c.pRegions, cpRegions_allocs = copyPBufferImageCopy2Bytes((*sliceHeader)(unsafe.Pointer(&x.PRegions)))
		allocsa8b5363c.Borrow(cpRegions_allocs)
	}

	x.refa8b5363c = refa8b5363c
	x.allocsa8b5363c = allocsa8b5363c
	return refa8b5363c, allocsa8b5363c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CopyBufferToImageInfo2) PassValue() (C.VkCopyBufferToImageInfo2, *cgoAllocMap) {
	if x.refa8b5363c != nil {
		return *x.refa8b5363c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CopyBufferToImageInfo2) Deref() {
	if x.refa8b5363c == nil {
		return
	}
	x.SType = (StructureType)(x.refa8b5363c.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refa8b5363c.pNext))
	x.SrcBuffer = *(*Buffer)(unsafe.Pointer(&x.refa8b5363c.srcBuffer))
	x.DstImage = *(*Image)(unsafe.Pointer(&x.refa8b5363c.dstImage))
	x.DstImageLayout = (ImageLayout)(x.refa8b5363c.dstImageLayout)
	x.RegionCount = (uint32)(x.refa8b5363c.regionCount)
	hxf047235 := (*sliceHeader)(unsafe.Pointer(&x.PRegions))
	hxf047235.Data = unsafe.Pointer(x.refa8b5363c.pRegions)
	hxf047235.Cap = 0x7fffffff
	// hxf047235.Len = ? x.PRegions x.refa8b5363c.pRegions

}

// allocCopyImageToBufferInfo2Memory allocates memory for type C.VkCopyImageToBufferInfo2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCopyImageToBufferInfo2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCopyImageToBufferInfo2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCopyImageToBufferInfo2Value = unsafe.Sizeof([1]C.VkCopyImageToBufferInfo2{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CopyImageToBufferInfo2) Ref() *C.VkCopyImageToBufferInfo2 {
	if x == nil {
		return nil
	}
	return x.refa81aa2a6
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CopyImageToBufferInfo2) Free() {
	if x != nil && x.allocsa81aa2a6 != nil {
		x.allocsa81aa2a6.(*cgoAllocMap).Free()
		x.refa81aa2a6 = nil
	}
}

// NewCopyImageToBufferInfo2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCopyImageToBufferInfo2Ref(ref unsafe.Pointer) *CopyImageToBufferInfo2 {
	if ref == nil {
		return nil
	}
	obj := new(CopyImageToBufferInfo2)
	obj.refa81aa2a6 = (*C.VkCopyImageToBufferInfo2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CopyImageToBufferInfo2) PassRef() (*C.VkCopyImageToBufferInfo2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa81aa2a6 != nil {
		return x.refa81aa2a6, nil
	}
	mema81aa2a6 := allocCopyImageToBufferInfo2Memory(1)
	refa81aa2a6 := (*C.VkCopyImageToBufferInfo2)(mema81aa2a6)
	allocsa81aa2a6 := new(cgoAllocMap)
	allocsa81aa2a6.Add(mema81aa2a6)

	refa81aa2a6.sType = (C.VkStructureType)(x.SType)

	refa81aa2a6.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	refa81aa2a6.srcImage = *(*C.VkImage)(unsafe.Pointer(&x.SrcImage))

	refa81aa2a6.srcImageLayout = (C.VkImageLayout)(x.SrcImageLayout)

	refa81aa2a6.dstBuffer = *(*C.VkBuffer)(unsafe.Pointer(&x.DstBuffer))

	refa81aa2a6.regionCount = (C.uint32_t)(x.RegionCount)

	if x.PRegions != nil {
		var cpRegions_allocs *cgoAllocMap
		refa81aa2a6.pRegions, cpRegions_allocs = copyPBufferImageCopy2Bytes((*sliceHeader)(unsafe.Pointer(&x.PRegions)))
		allocsa81aa2a6.Borrow(cpRegions_allocs)
	}

	x.refa81aa2a6 = refa81aa2a6
	x.allocsa81aa2a6 = allocsa81aa2a6
	return refa81aa2a6, allocsa81aa2a6

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CopyImageToBufferInfo2) PassValue() (C.VkCopyImageToBufferInfo2, *cgoAllocMap) {
	if x.refa81aa2a6 != nil {
		return *x.refa81aa2a6, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CopyImageToBufferInfo2) Deref() {
	if x.refa81aa2a6 == nil {
		return
	}
	x.SType = (StructureType)(x.refa81aa2a6.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refa81aa2a6.pNext))
	x.SrcImage = *(*Image)(unsafe.Pointer(&x.refa81aa2a6.srcImage))
	x.SrcImageLayout = (ImageLayout)(x.refa81aa2a6.srcImageLayout)
	x.DstBuffer = *(*Buffer)(unsafe.Pointer(&x.refa81aa2a6.dstBuffer))
	x.RegionCount = (uint32)(x.refa81aa2a6.regionCount)
	hxf612a5d := (*sliceHeader)(unsafe.Pointer(&x.PRegions))
	hxf612a5d.Data = unsafe.Pointer(x.refa81aa2a6.pRegions)
	hxf612a5d.Cap = 0x7fffffff
	// hxf612a5d.Len = ? x.PRegions x.refa81aa2a6.pRegions

}

// allocBlitImageInfo2Memory allocates memory for type C.VkBlitImageInfo2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBlitImageInfo2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBlitImageInfo2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBlitImageInfo2Value = unsafe.Sizeof([1]C.VkBlitImageInfo2{})

// copyPImageBlit2Bytes copies the data from Go slice as *C.VkImageBlit2.
func copyPImageBlit2Bytes(slice *sliceHeader) (*C.VkImageBlit2, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfImageBlit2Value) * slice.Len,
		Cap:  int(sizeOfImageBlit2Value) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkImageBlit2)(mem0), allocs
}

// allocImageBlit2Memory allocates memory for type C.VkImageBlit2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageBlit2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageBlit2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfImageBlit2Value = unsafe.Sizeof([1]C.VkImageBlit2{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BlitImageInfo2) Ref() *C.VkBlitImageInfo2 {
	if x == nil {
		return nil
	}
	return x.ref93f0395
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BlitImageInfo2) Free() {
	if x != nil && x.allocs93f0395 != nil {
		x.allocs93f0395.(*cgoAllocMap).Free()
		x.ref93f0395 = nil
	}
}

// NewBlitImageInfo2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBlitImageInfo2Ref(ref unsafe.Pointer) *BlitImageInfo2 {
	if ref == nil {
		return nil
	}
	obj := new(BlitImageInfo2)
	obj.ref93f0395 = (*C.VkBlitImageInfo2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BlitImageInfo2) PassRef() (*C.VkBlitImageInfo2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref93f0395 != nil {
		return x.ref93f0395, nil
	}
	mem93f0395 := allocBlitImageInfo2Memory(1)
	ref93f0395 := (*C.VkBlitImageInfo2)(mem93f0395)
	allocs93f0395 := new(cgoAllocMap)
	allocs93f0395.Add(mem93f0395)

	ref93f0395.sType = (C.VkStructureType)(x.SType)

	ref93f0395.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref93f0395.srcImage = *(*C.VkImage)(unsafe.Pointer(&x.SrcImage))

	ref93f0395.srcImageLayout = (C.VkImageLayout)(x.SrcImageLayout)

	ref93f0395.dstImage = *(*C.VkImage)(unsafe.Pointer(&x.DstImage))

	ref93f0395.dstImageLayout = (C.VkImageLayout)(x.DstImageLayout)

	ref93f0395.regionCount = (C.uint32_t)(x.RegionCount)

	if x.PRegions != nil {
		var cpRegions_allocs *cgoAllocMap
		ref93f0395.pRegions, cpRegions_allocs = copyPImageBlit2Bytes((*sliceHeader)(unsafe.Pointer(&x.PRegions)))
		allocs93f0395.Borrow(cpRegions_allocs)
	}

	ref93f0395.filter = (C.VkFilter)(x.Filter)

	x.ref93f0395 = ref93f0395
	x.allocs93f0395 = allocs93f0395
	return ref93f0395, allocs93f0395

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BlitImageInfo2) PassValue() (C.VkBlitImageInfo2, *cgoAllocMap) {
	if x.ref93f0395 != nil {
		return *x.ref93f0395, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BlitImageInfo2) Deref() {
	if x.ref93f0395 == nil {
		return
	}
	x.SType = (StructureType)(x.ref93f0395.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref93f0395.pNext))
	x.SrcImage = *(*Image)(unsafe.Pointer(&x.ref93f0395.srcImage))
	x.SrcImageLayout = (ImageLayout)(x.ref93f0395.srcImageLayout)
	x.DstImage = *(*Image)(unsafe.Pointer(&x.ref93f0395.dstImage))
	x.DstImageLayout = (ImageLayout)(x.ref93f0395.dstImageLayout)
	x.RegionCount = (uint32)(x.ref93f0395.regionCount)
	hxff58be3 := (*sliceHeader)(unsafe.Pointer(&x.PRegions))
	hxff58be3.Data = unsafe.Pointer(x.ref93f0395.pRegions)
	hxff58be3.Cap = 0x7fffffff
	// hxff58be3.Len = ? x.PRegions x.ref93f0395.pRegions

	x.Filter = (Filter)(x.ref93f0395.filter)
}

// allocResolveImageInfo2Memory allocates memory for type C.VkResolveImageInfo2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocResolveImageInfo2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfResolveImageInfo2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfResolveImageInfo2Value = unsafe.Sizeof([1]C.VkResolveImageInfo2{})

// copyPImageResolve2Bytes copies the data from Go slice as *C.VkImageResolve2.
func copyPImageResolve2Bytes(slice *sliceHeader) (*C.VkImageResolve2, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfImageResolve2Value) * slice.Len,
		Cap:  int(sizeOfImageResolve2Value) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkImageResolve2)(mem0), allocs
}

// allocImageResolve2Memory allocates memory for type C.VkImageResolve2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageResolve2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageResolve2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfImageResolve2Value = unsafe.Sizeof([1]C.VkImageResolve2{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ResolveImageInfo2) Ref() *C.VkResolveImageInfo2 {
	if x == nil {
		return nil
	}
	return x.ref407c4932
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ResolveImageInfo2) Free() {
	if x != nil && x.allocs407c4932 != nil {
		x.allocs407c4932.(*cgoAllocMap).Free()
		x.ref407c4932 = nil
	}
}

// NewResolveImageInfo2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewResolveImageInfo2Ref(ref unsafe.Pointer) *ResolveImageInfo2 {
	if ref == nil {
		return nil
	}
	obj := new(ResolveImageInfo2)
	obj.ref407c4932 = (*C.VkResolveImageInfo2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ResolveImageInfo2) PassRef() (*C.VkResolveImageInfo2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref407c4932 != nil {
		return x.ref407c4932, nil
	}
	mem407c4932 := allocResolveImageInfo2Memory(1)
	ref407c4932 := (*C.VkResolveImageInfo2)(mem407c4932)
	allocs407c4932 := new(cgoAllocMap)
	allocs407c4932.Add(mem407c4932)

	ref407c4932.sType = (C.VkStructureType)(x.SType)

	ref407c4932.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref407c4932.srcImage = *(*C.VkImage)(unsafe.Pointer(&x.SrcImage))

	ref407c4932.srcImageLayout = (C.VkImageLayout)(x.SrcImageLayout)

	ref407c4932.dstImage = *(*C.VkImage)(unsafe.Pointer(&x.DstImage))

	ref407c4932.dstImageLayout = (C.VkImageLayout)(x.DstImageLayout)

	ref407c4932.regionCount = (C.uint32_t)(x.RegionCount)

	if x.PRegions != nil {
		var cpRegions_allocs *cgoAllocMap
		ref407c4932.pRegions, cpRegions_allocs = copyPImageResolve2Bytes((*sliceHeader)(unsafe.Pointer(&x.PRegions)))
		allocs407c4932.Borrow(cpRegions_allocs)
	}

	x.ref407c4932 = ref407c4932
	x.allocs407c4932 = allocs407c4932
	return ref407c4932, allocs407c4932

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ResolveImageInfo2) PassValue() (C.VkResolveImageInfo2, *cgoAllocMap) {
	if x.ref407c4932 != nil {
		return *x.ref407c4932, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ResolveImageInfo2) Deref() {
	if x.ref407c4932 == nil {
		return
	}
	x.SType = (StructureType)(x.ref407c4932.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref407c4932.pNext))
	x.SrcImage = *(*Image)(unsafe.Pointer(&x.ref407c4932.srcImage))
	x.SrcImageLayout = (ImageLayout)(x.ref407c4932.srcImageLayout)
	x.DstImage = *(*Image)(unsafe.Pointer(&x.ref407c4932.dstImage))
	x.DstImageLayout = (ImageLayout)(x.ref407c4932.dstImageLayout)
	x.RegionCount = (uint32)(x.ref407c4932.regionCount)
	hxf79f3d5 := (*sliceHeader)(unsafe.Pointer(&x.PRegions))
	hxf79f3d5.Data = unsafe.Pointer(x.ref407c4932.pRegions)
	hxf79f3d5.Cap = 0x7fffffff
	// hxf79f3d5.Len = ? x.PRegions x.ref407c4932.pRegions

}

// allocRenderingAttachmentInfoMemory allocates memory for type C.VkRenderingAttachmentInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRenderingAttachmentInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRenderingAttachmentInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfRenderingAttachmentInfoValue = unsafe.Sizeof([1]C.VkRenderingAttachmentInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RenderingAttachmentInfo) Ref() *C.VkRenderingAttachmentInfo {
	if x == nil {
		return nil
	}
	return x.ref62eee071
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RenderingAttachmentInfo) Free() {
	if x != nil && x.allocs62eee071 != nil {
		x.allocs62eee071.(*cgoAllocMap).Free()
		x.ref62eee071 = nil
	}
}

// NewRenderingAttachmentInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRenderingAttachmentInfoRef(ref unsafe.Pointer) *RenderingAttachmentInfo {
	if ref == nil {
		return nil
	}
	obj := new(RenderingAttachmentInfo)
	obj.ref62eee071 = (*C.VkRenderingAttachmentInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RenderingAttachmentInfo) PassRef() (*C.VkRenderingAttachmentInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref62eee071 != nil {
		return x.ref62eee071, nil
	}
	mem62eee071 := allocRenderingAttachmentInfoMemory(1)
	ref62eee071 := (*C.VkRenderingAttachmentInfo)(mem62eee071)
	allocs62eee071 := new(cgoAllocMap)
	allocs62eee071.Add(mem62eee071)

	ref62eee071.sType = (C.VkStructureType)(x.SType)

	ref62eee071.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref62eee071.imageView = *(*C.VkImageView)(unsafe.Pointer(&x.ImageView))

	ref62eee071.imageLayout = (C.VkImageLayout)(x.ImageLayout)

	ref62eee071.resolveMode = (C.VkResolveModeFlagBits)(x.ResolveMode)

	ref62eee071.resolveImageView = *(*C.VkImageView)(unsafe.Pointer(&x.ResolveImageView))

	ref62eee071.resolveImageLayout = (C.VkImageLayout)(x.ResolveImageLayout)

	ref62eee071.loadOp = (C.VkAttachmentLoadOp)(x.LoadOp)

	ref62eee071.storeOp = (C.VkAttachmentStoreOp)(x.StoreOp)

	ref62eee071.clearValue = *(*C.VkClearValue)(unsafe.Pointer(&x.ClearValue))

	x.ref62eee071 = ref62eee071
	x.allocs62eee071 = allocs62eee071
	return ref62eee071, allocs62eee071

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RenderingAttachmentInfo) PassValue() (C.VkRenderingAttachmentInfo, *cgoAllocMap) {
	if x.ref62eee071 != nil {
		return *x.ref62eee071, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *RenderingAttachmentInfo) Deref() {
	if x.ref62eee071 == nil {
		return
	}
	x.SType = (StructureType)(x.ref62eee071.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref62eee071.pNext))
	x.ImageView = *(*ImageView)(unsafe.Pointer(&x.ref62eee071.imageView))
	x.ImageLayout = (ImageLayout)(x.ref62eee071.imageLayout)
	x.ResolveMode = (ResolveModeFlagBits)(x.ref62eee071.resolveMode)
	x.ResolveImageView = *(*ImageView)(unsafe.Pointer(&x.ref62eee071.resolveImageView))
	x.ResolveImageLayout = (ImageLayout)(x.ref62eee071.resolveImageLayout)
	x.LoadOp = (AttachmentLoadOp)(x.ref62eee071.loadOp)
	x.StoreOp = (AttachmentStoreOp)(x.ref62eee071.storeOp)
	x.ClearValue = *(*ClearValue)(unsafe.Pointer(&x.ref62eee071.clearValue))
}

// allocRenderingInfoMemory allocates memory for type C.VkRenderingInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRenderingInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRenderingInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfRenderingInfoValue = unsafe.Sizeof([1]C.VkRenderingInfo{})

// unpackSRenderingAttachmentInfo transforms a sliced Go data structure into plain C format.
func unpackSRenderingAttachmentInfo(x []RenderingAttachmentInfo) (unpacked *C.VkRenderingAttachmentInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocRenderingAttachmentInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkRenderingAttachmentInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkRenderingAttachmentInfo)(h.Data)
	return
}

// packSRenderingAttachmentInfo reads sliced Go data structure out from plain C format.
func packSRenderingAttachmentInfo(v []RenderingAttachmentInfo, ptr0 *C.VkRenderingAttachmentInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfRenderingAttachmentInfoValue]C.VkRenderingAttachmentInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewRenderingAttachmentInfoRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RenderingInfo) Ref() *C.VkRenderingInfo {
	if x == nil {
		return nil
	}
	return x.refe60d8c7
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RenderingInfo) Free() {
	if x != nil && x.allocse60d8c7 != nil {
		x.allocse60d8c7.(*cgoAllocMap).Free()
		x.refe60d8c7 = nil
	}
}

// NewRenderingInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRenderingInfoRef(ref unsafe.Pointer) *RenderingInfo {
	if ref == nil {
		return nil
	}
	obj := new(RenderingInfo)
	obj.refe60d8c7 = (*C.VkRenderingInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RenderingInfo) PassRef() (*C.VkRenderingInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe60d8c7 != nil {
		return x.refe60d8c7, nil
	}
	meme60d8c7 := allocRenderingInfoMemory(1)
	refe60d8c7 := (*C.VkRenderingInfo)(meme60d8c7)
	allocse60d8c7 := new(cgoAllocMap)
	allocse60d8c7.Add(meme60d8c7)

	refe60d8c7.sType = (C.VkStructureType)(x.SType)

	refe60d8c7.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	refe60d8c7.flags = (C.VkRenderingFlags)(x.Flags)

	refe60d8c7.renderArea = *(*C.VkRect2D)(unsafe.Pointer(&x.RenderArea))

	refe60d8c7.layerCount = (C.uint32_t)(x.LayerCount)

	refe60d8c7.viewMask = (C.uint32_t)(x.ViewMask)

	refe60d8c7.colorAttachmentCount = (C.uint32_t)(x.ColorAttachmentCount)

	var cpColorAttachments_allocs *cgoAllocMap
	refe60d8c7.pColorAttachments, cpColorAttachments_allocs = unpackSRenderingAttachmentInfo(x.PColorAttachments)
	allocse60d8c7.Borrow(cpColorAttachments_allocs)

	var cpDepthAttachment_allocs *cgoAllocMap
	refe60d8c7.pDepthAttachment, cpDepthAttachment_allocs = unpackSRenderingAttachmentInfo(x.PDepthAttachment)
	allocse60d8c7.Borrow(cpDepthAttachment_allocs)

	var cpStencilAttachment_allocs *cgoAllocMap
	refe60d8c7.pStencilAttachment, cpStencilAttachment_allocs = unpackSRenderingAttachmentInfo(x.PStencilAttachment)
	allocse60d8c7.Borrow(cpStencilAttachment_allocs)

	x.refe60d8c7 = refe60d8c7
	x.allocse60d8c7 = allocse60d8c7
	return refe60d8c7, allocse60d8c7

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RenderingInfo) PassValue() (C.VkRenderingInfo, *cgoAllocMap) {
	if x.refe60d8c7 != nil {
		return *x.refe60d8c7, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *RenderingInfo) Deref() {
	if x.refe60d8c7 == nil {
		return
	}
	x.SType = (StructureType)(x.refe60d8c7.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refe60d8c7.pNext))
	x.Flags = (RenderingFlags)(x.refe60d8c7.flags)
	x.RenderArea = *(*Rect2D)(unsafe.Pointer(&x.refe60d8c7.renderArea))
	x.LayerCount = (uint32)(x.refe60d8c7.layerCount)
	x.ViewMask = (uint32)(x.refe60d8c7.viewMask)
	x.ColorAttachmentCount = (uint32)(x.refe60d8c7.colorAttachmentCount)
	packSRenderingAttachmentInfo(x.PColorAttachments, x.refe60d8c7.pColorAttachments)
	packSRenderingAttachmentInfo(x.PDepthAttachment, x.refe60d8c7.pDepthAttachment)
	packSRenderingAttachmentInfo(x.PStencilAttachment, x.refe60d8c7.pStencilAttachment)
}

// allocPipelineRenderingCreateInfoMemory allocates memory for type C.VkPipelineRenderingCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineRenderingCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineRenderingCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPipelineRenderingCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineRenderingCreateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineRenderingCreateInfo) Ref() *C.VkPipelineRenderingCreateInfo {
	if x == nil {
		return nil
	}
	return x.ref2f948283
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineRenderingCreateInfo) Free() {
	if x != nil && x.allocs2f948283 != nil {
		x.allocs2f948283.(*cgoAllocMap).Free()
		x.ref2f948283 = nil
	}
}

// NewPipelineRenderingCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineRenderingCreateInfoRef(ref unsafe.Pointer) *PipelineRenderingCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineRenderingCreateInfo)
	obj.ref2f948283 = (*C.VkPipelineRenderingCreateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineRenderingCreateInfo) PassRef() (*C.VkPipelineRenderingCreateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2f948283 != nil {
		return x.ref2f948283, nil
	}
	mem2f948283 := allocPipelineRenderingCreateInfoMemory(1)
	ref2f948283 := (*C.VkPipelineRenderingCreateInfo)(mem2f948283)
	allocs2f948283 := new(cgoAllocMap)
	allocs2f948283.Add(mem2f948283)

	ref2f948283.sType = (C.VkStructureType)(x.SType)

	ref2f948283.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref2f948283.viewMask = (C.uint32_t)(x.ViewMask)

	ref2f948283.colorAttachmentCount = (C.uint32_t)(x.ColorAttachmentCount)

	if x.PColorAttachmentFormats != nil {
		var cpColorAttachmentFormats_allocs *cgoAllocMap
		ref2f948283.pColorAttachmentFormats, cpColorAttachmentFormats_allocs = copyPFormatBytes((*sliceHeader)(unsafe.Pointer(&x.PColorAttachmentFormats)))
		allocs2f948283.Borrow(cpColorAttachmentFormats_allocs)
	}

	ref2f948283.depthAttachmentFormat = (C.VkFormat)(x.DepthAttachmentFormat)

	ref2f948283.stencilAttachmentFormat = (C.VkFormat)(x.StencilAttachmentFormat)

	x.ref2f948283 = ref2f948283
	x.allocs2f948283 = allocs2f948283
	return ref2f948283, allocs2f948283

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineRenderingCreateInfo) PassValue() (C.VkPipelineRenderingCreateInfo, *cgoAllocMap) {
	if x.ref2f948283 != nil {
		return *x.ref2f948283, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineRenderingCreateInfo) Deref() {
	if x.ref2f948283 == nil {
		return
	}
	x.SType = (StructureType)(x.ref2f948283.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref2f948283.pNext))
	x.ViewMask = (uint32)(x.ref2f948283.viewMask)
	x.ColorAttachmentCount = (uint32)(x.ref2f948283.colorAttachmentCount)
	hxfbb2d22 := (*sliceHeader)(unsafe.Pointer(&x.PColorAttachmentFormats))
	hxfbb2d22.Data = unsafe.Pointer(x.ref2f948283.pColorAttachmentFormats)
	hxfbb2d22.Cap = 0x7fffffff
	// hxfbb2d22.Len = ? x.PColorAttachmentFormats x.ref2f948283.pColorAttachmentFormats

	x.DepthAttachmentFormat = (Format)(x.ref2f948283.depthAttachmentFormat)
	x.StencilAttachmentFormat = (Format)(x.ref2f948283.stencilAttachmentFormat)
}

// allocCommandBufferInheritanceRenderingInfoMemory allocates memory for type C.VkCommandBufferInheritanceRenderingInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCommandBufferInheritanceRenderingInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCommandBufferInheritanceRenderingInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCommandBufferInheritanceRenderingInfoValue = unsafe.Sizeof([1]C.VkCommandBufferInheritanceRenderingInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CommandBufferInheritanceRenderingInfo) Ref() *C.VkCommandBufferInheritanceRenderingInfo {
	if x == nil {
		return nil
	}
	return x.reff704c204
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CommandBufferInheritanceRenderingInfo) Free() {
	if x != nil && x.allocsf704c204 != nil {
		x.allocsf704c204.(*cgoAllocMap).Free()
		x.reff704c204 = nil
	}
}

// NewCommandBufferInheritanceRenderingInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCommandBufferInheritanceRenderingInfoRef(ref unsafe.Pointer) *CommandBufferInheritanceRenderingInfo {
	if ref == nil {
		return nil
	}
	obj := new(CommandBufferInheritanceRenderingInfo)
	obj.reff704c204 = (*C.VkCommandBufferInheritanceRenderingInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CommandBufferInheritanceRenderingInfo) PassRef() (*C.VkCommandBufferInheritanceRenderingInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff704c204 != nil {
		return x.reff704c204, nil
	}
	memf704c204 := allocCommandBufferInheritanceRenderingInfoMemory(1)
	reff704c204 := (*C.VkCommandBufferInheritanceRenderingInfo)(memf704c204)
	allocsf704c204 := new(cgoAllocMap)
	allocsf704c204.Add(memf704c204)

	reff704c204.sType = (C.VkStructureType)(x.SType)

	reff704c204.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	reff704c204.flags = (C.VkRenderingFlags)(x.Flags)

	reff704c204.viewMask = (C.uint32_t)(x.ViewMask)

	reff704c204.colorAttachmentCount = (C.uint32_t)(x.ColorAttachmentCount)

	if x.PColorAttachmentFormats != nil {
		var cpColorAttachmentFormats_allocs *cgoAllocMap
		reff704c204.pColorAttachmentFormats, cpColorAttachmentFormats_allocs = copyPFormatBytes((*sliceHeader)(unsafe.Pointer(&x.PColorAttachmentFormats)))
		allocsf704c204.Borrow(cpColorAttachmentFormats_allocs)
	}

	reff704c204.depthAttachmentFormat = (C.VkFormat)(x.DepthAttachmentFormat)

	reff704c204.stencilAttachmentFormat = (C.VkFormat)(x.StencilAttachmentFormat)

	reff704c204.rasterizationSamples = (C.VkSampleCountFlagBits)(x.RasterizationSamples)

	x.reff704c204 = reff704c204
	x.allocsf704c204 = allocsf704c204
	return reff704c204, allocsf704c204

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CommandBufferInheritanceRenderingInfo) PassValue() (C.VkCommandBufferInheritanceRenderingInfo, *cgoAllocMap) {
	if x.reff704c204 != nil {
		return *x.reff704c204, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CommandBufferInheritanceRenderingInfo) Deref() {
	if x.reff704c204 == nil {
		return
	}
	x.SType = (StructureType)(x.reff704c204.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.reff704c204.pNext))
	x.Flags = (RenderingFlags)(x.reff704c204.flags)
	x.ViewMask = (uint32)(x.reff704c204.viewMask)
	x.ColorAttachmentCount = (uint32)(x.reff704c204.colorAttachmentCount)
	hxff3831d := (*sliceHeader)(unsafe.Pointer(&x.PColorAttachmentFormats))
	hxff3831d.Data = unsafe.Pointer(x.reff704c204.pColorAttachmentFormats)
	hxff3831d.Cap = 0x7fffffff
	// hxff3831d.Len = ? x.PColorAttachmentFormats x.reff704c204.pColorAttachmentFormats

	x.DepthAttachmentFormat = (Format)(x.reff704c204.depthAttachmentFormat)
	x.StencilAttachmentFormat = (Format)(x.reff704c204.stencilAttachmentFormat)
	x.RasterizationSamples = (SampleCountFlagBits)(x.reff704c204.rasterizationSamples)
}

// allocDeviceBufferMemoryRequirementsMemory allocates memory for type C.VkDeviceBufferMemoryRequirements in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceBufferMemoryRequirementsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceBufferMemoryRequirementsValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDeviceBufferMemoryRequirementsValue = unsafe.Sizeof([1]C.VkDeviceBufferMemoryRequirements{})

// unpackSBufferCreateInfo transforms a sliced Go data structure into plain C format.
func unpackSBufferCreateInfo(x []BufferCreateInfo) (unpacked *C.VkBufferCreateInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocBufferCreateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkBufferCreateInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkBufferCreateInfo)(h.Data)
	return
}

// packSBufferCreateInfo reads sliced Go data structure out from plain C format.
func packSBufferCreateInfo(v []BufferCreateInfo, ptr0 *C.VkBufferCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfBufferCreateInfoValue]C.VkBufferCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewBufferCreateInfoRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DeviceBufferMemoryRequirements) Ref() *C.VkDeviceBufferMemoryRequirements {
	if x == nil {
		return nil
	}
	return x.ref30350e90
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DeviceBufferMemoryRequirements) Free() {
	if x != nil && x.allocs30350e90 != nil {
		x.allocs30350e90.(*cgoAllocMap).Free()
		x.ref30350e90 = nil
	}
}

// NewDeviceBufferMemoryRequirementsRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDeviceBufferMemoryRequirementsRef(ref unsafe.Pointer) *DeviceBufferMemoryRequirements {
	if ref == nil {
		return nil
	}
	obj := new(DeviceBufferMemoryRequirements)
	obj.ref30350e90 = (*C.VkDeviceBufferMemoryRequirements)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DeviceBufferMemoryRequirements) PassRef() (*C.VkDeviceBufferMemoryRequirements, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref30350e90 != nil {
		return x.ref30350e90, nil
	}
	mem30350e90 := allocDeviceBufferMemoryRequirementsMemory(1)
	ref30350e90 := (*C.VkDeviceBufferMemoryRequirements)(mem30350e90)
	allocs30350e90 := new(cgoAllocMap)
	allocs30350e90.Add(mem30350e90)

	ref30350e90.sType = (C.VkStructureType)(x.SType)

	ref30350e90.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	var cpCreateInfo_allocs *cgoAllocMap
	ref30350e90.pCreateInfo, cpCreateInfo_allocs = unpackSBufferCreateInfo(x.PCreateInfo)
	allocs30350e90.Borrow(cpCreateInfo_allocs)

	x.ref30350e90 = ref30350e90
	x.allocs30350e90 = allocs30350e90
	return ref30350e90, allocs30350e90

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DeviceBufferMemoryRequirements) PassValue() (C.VkDeviceBufferMemoryRequirements, *cgoAllocMap) {
	if x.ref30350e90 != nil {
		return *x.ref30350e90, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DeviceBufferMemoryRequirements) Deref() {
	if x.ref30350e90 == nil {
		return
	}
	x.SType = (StructureType)(x.ref30350e90.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref30350e90.pNext))
	packSBufferCreateInfo(x.PCreateInfo, x.ref30350e90.pCreateInfo)
}

// allocDeviceImageMemoryRequirementsMemory allocates memory for type C.VkDeviceImageMemoryRequirements in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceImageMemoryRequirementsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceImageMemoryRequirementsValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDeviceImageMemoryRequirementsValue = unsafe.Sizeof([1]C.VkDeviceImageMemoryRequirements{})

// unpackSImageCreateInfo transforms a sliced Go data structure into plain C format.
func unpackSImageCreateInfo(x []ImageCreateInfo) (unpacked *C.VkImageCreateInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocImageCreateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkImageCreateInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkImageCreateInfo)(h.Data)
	return
}

// packSImageCreateInfo reads sliced Go data structure out from plain C format.
func packSImageCreateInfo(v []ImageCreateInfo, ptr0 *C.VkImageCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfImageCreateInfoValue]C.VkImageCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewImageCreateInfoRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DeviceImageMemoryRequirements) Ref() *C.VkDeviceImageMemoryRequirements {
	if x == nil {
		return nil
	}
	return x.refd9532ea3
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DeviceImageMemoryRequirements) Free() {
	if x != nil && x.allocsd9532ea3 != nil {
		x.allocsd9532ea3.(*cgoAllocMap).Free()
		x.refd9532ea3 = nil
	}
}

// NewDeviceImageMemoryRequirementsRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDeviceImageMemoryRequirementsRef(ref unsafe.Pointer) *DeviceImageMemoryRequirements {
	if ref == nil {
		return nil
	}
	obj := new(DeviceImageMemoryRequirements)
	obj.refd9532ea3 = (*C.VkDeviceImageMemoryRequirements)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DeviceImageMemoryRequirements) PassRef() (*C.VkDeviceImageMemoryRequirements, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd9532ea3 != nil {
		return x.refd9532ea3, nil
	}
	memd9532ea3 := allocDeviceImageMemoryRequirementsMemory(1)
	refd9532ea3 := (*C.VkDeviceImageMemoryRequirements)(memd9532ea3)
	allocsd9532ea3 := new(cgoAllocMap)
	allocsd9532ea3.Add(memd9532ea3)

	refd9532ea3.sType = (C.VkStructureType)(x.SType)

	refd9532ea3.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	var cpCreateInfo_allocs *cgoAllocMap
	refd9532ea3.pCreateInfo, cpCreateInfo_allocs = unpackSImageCreateInfo(x.PCreateInfo)
	allocsd9532ea3.Borrow(cpCreateInfo_allocs)

	refd9532ea3.planeAspect = (C.VkImageAspectFlagBits)(x.PlaneAspect)

	x.refd9532ea3 = refd9532ea3
	x.allocsd9532ea3 = allocsd9532ea3
	return refd9532ea3, allocsd9532ea3

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DeviceImageMemoryRequirements) PassValue() (C.VkDeviceImageMemoryRequirements, *cgoAllocMap) {
	if x.refd9532ea3 != nil {
		return *x.refd9532ea3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DeviceImageMemoryRequirements) Deref() {
	if x.refd9532ea3 == nil {
		return
	}
	x.SType = (StructureType)(x.refd9532ea3.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refd9532ea3.pNext))
	packSImageCreateInfo(x.PCreateInfo, x.refd9532ea3.pCreateInfo)
	x.PlaneAspect = (ImageAspectFlagBits)(x.refd9532ea3.planeAspect)
}

// allocSwapchainCreateInfoMemory allocates memory for type C.VkSwapchainCreateInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSwapchainCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSwapchainCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSwapchainCreateInfoValue = unsafe.Sizeof([1]C.VkSwapchainCreateInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SwapchainCreateInfo) Ref() *C.VkSwapchainCreateInfoKHR {
	if x == nil {
		return nil
	}
	return x.refdb619e1c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SwapchainCreateInfo) Free() {
	if x != nil && x.allocsdb619e1c != nil {
		x.allocsdb619e1c.(*cgoAllocMap).Free()
		x.refdb619e1c = nil
	}
}

// NewSwapchainCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSwapchainCreateInfoRef(ref unsafe.Pointer) *SwapchainCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(SwapchainCreateInfo)
	obj.refdb619e1c = (*C.VkSwapchainCreateInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SwapchainCreateInfo) PassRef() (*C.VkSwapchainCreateInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refdb619e1c != nil {
		return x.refdb619e1c, nil
	}
	memdb619e1c := allocSwapchainCreateInfoMemory(1)
	refdb619e1c := (*C.VkSwapchainCreateInfoKHR)(memdb619e1c)
	allocsdb619e1c := new(cgoAllocMap)
	allocsdb619e1c.Add(memdb619e1c)

	refdb619e1c.sType = (C.VkStructureType)(x.SType)

	refdb619e1c.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	refdb619e1c.flags = (C.VkSwapchainCreateFlagsKHR)(x.Flags)

	refdb619e1c.surface = *(*C.VkSurfaceKHR)(unsafe.Pointer(&x.Surface))

	refdb619e1c.minImageCount = (C.uint32_t)(x.MinImageCount)

	refdb619e1c.imageFormat = (C.VkFormat)(x.ImageFormat)

	refdb619e1c.imageColorSpace = (C.VkColorSpaceKHR)(x.ImageColorSpace)

	refdb619e1c.imageExtent = *(*C.VkExtent2D)(unsafe.Pointer(&x.ImageExtent))

	refdb619e1c.imageArrayLayers = (C.uint32_t)(x.ImageArrayLayers)

	refdb619e1c.imageUsage = (C.VkImageUsageFlags)(x.ImageUsage)

	refdb619e1c.imageSharingMode = (C.VkSharingMode)(x.ImageSharingMode)

	refdb619e1c.queueFamilyIndexCount = (C.uint32_t)(x.QueueFamilyIndexCount)

	if x.PQueueFamilyIndices != nil {
		var cpQueueFamilyIndices_allocs *cgoAllocMap
		refdb619e1c.pQueueFamilyIndices, cpQueueFamilyIndices_allocs = copyPUint32_tBytes((*sliceHeader)(unsafe.Pointer(&x.PQueueFamilyIndices)))
		allocsdb619e1c.Borrow(cpQueueFamilyIndices_allocs)
	}

	refdb619e1c.preTransform = (C.VkSurfaceTransformFlagBitsKHR)(x.PreTransform)

	refdb619e1c.compositeAlpha = (C.VkCompositeAlphaFlagBitsKHR)(x.CompositeAlpha)

	refdb619e1c.presentMode = (C.VkPresentModeKHR)(x.PresentMode)

	refdb619e1c.clipped = (C.VkBool32)(x.Clipped)

	refdb619e1c.oldSwapchain = *(*C.VkSwapchainKHR)(unsafe.Pointer(&x.OldSwapchain))

	x.refdb619e1c = refdb619e1c
	x.allocsdb619e1c = allocsdb619e1c
	return refdb619e1c, allocsdb619e1c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SwapchainCreateInfo) PassValue() (C.VkSwapchainCreateInfoKHR, *cgoAllocMap) {
	if x.refdb619e1c != nil {
		return *x.refdb619e1c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SwapchainCreateInfo) Deref() {
	if x.refdb619e1c == nil {
		return
	}
	x.SType = (StructureType)(x.refdb619e1c.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refdb619e1c.pNext))
	x.Flags = (SwapchainCreateFlags)(x.refdb619e1c.flags)
	x.Surface = *(*Surface)(unsafe.Pointer(&x.refdb619e1c.surface))
	x.MinImageCount = (uint32)(x.refdb619e1c.minImageCount)
	x.ImageFormat = (Format)(x.refdb619e1c.imageFormat)
	x.ImageColorSpace = (ColorSpace)(x.refdb619e1c.imageColorSpace)
	x.ImageExtent = *(*Extent2D)(unsafe.Pointer(&x.refdb619e1c.imageExtent))
	x.ImageArrayLayers = (uint32)(x.refdb619e1c.imageArrayLayers)
	x.ImageUsage = (ImageUsageFlags)(x.refdb619e1c.imageUsage)
	x.ImageSharingMode = (SharingMode)(x.refdb619e1c.imageSharingMode)
	x.QueueFamilyIndexCount = (uint32)(x.refdb619e1c.queueFamilyIndexCount)
	hxf3b2498 := (*sliceHeader)(unsafe.Pointer(&x.PQueueFamilyIndices))
	hxf3b2498.Data = unsafe.Pointer(x.refdb619e1c.pQueueFamilyIndices)
	hxf3b2498.Cap = 0x7fffffff
	// hxf3b2498.Len = ? x.PQueueFamilyIndices x.refdb619e1c.pQueueFamilyIndices

	x.PreTransform = (SurfaceTransformFlagBits)(x.refdb619e1c.preTransform)
	x.CompositeAlpha = (CompositeAlphaFlagBits)(x.refdb619e1c.compositeAlpha)
	x.PresentMode = (PresentMode)(x.refdb619e1c.presentMode)
	x.Clipped = (Bool32)(x.refdb619e1c.clipped)
	x.OldSwapchain = *(*Swapchain)(unsafe.Pointer(&x.refdb619e1c.oldSwapchain))
}

// allocPresentInfoMemory allocates memory for type C.VkPresentInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPresentInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPresentInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPresentInfoValue = unsafe.Sizeof([1]C.VkPresentInfoKHR{})

// copyPSwapchainBytes copies the data from Go slice as *C.VkSwapchainKHR.
func copyPSwapchainBytes(slice *sliceHeader) (*C.VkSwapchainKHR, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfSwapchainValue) * slice.Len,
		Cap:  int(sizeOfSwapchainValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkSwapchainKHR)(mem0), allocs
}

// allocSwapchainMemory allocates memory for type C.VkSwapchainKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSwapchainMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSwapchainValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSwapchainValue = unsafe.Sizeof([1]C.VkSwapchainKHR{})

// copyPResultBytes copies the data from Go slice as *C.VkResult.
func copyPResultBytes(slice *sliceHeader) (*C.VkResult, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfResultValue) * slice.Len,
		Cap:  int(sizeOfResultValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkResult)(mem0), allocs
}

// allocResultMemory allocates memory for type C.VkResult in C.
// The caller is responsible for freeing the this memory via C.free.
func allocResultMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfResultValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfResultValue = unsafe.Sizeof([1]C.VkResult{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PresentInfo) Ref() *C.VkPresentInfoKHR {
	if x == nil {
		return nil
	}
	return x.ref1d0e82d4
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PresentInfo) Free() {
	if x != nil && x.allocs1d0e82d4 != nil {
		x.allocs1d0e82d4.(*cgoAllocMap).Free()
		x.ref1d0e82d4 = nil
	}
}

// NewPresentInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPresentInfoRef(ref unsafe.Pointer) *PresentInfo {
	if ref == nil {
		return nil
	}
	obj := new(PresentInfo)
	obj.ref1d0e82d4 = (*C.VkPresentInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PresentInfo) PassRef() (*C.VkPresentInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1d0e82d4 != nil {
		return x.ref1d0e82d4, nil
	}
	mem1d0e82d4 := allocPresentInfoMemory(1)
	ref1d0e82d4 := (*C.VkPresentInfoKHR)(mem1d0e82d4)
	allocs1d0e82d4 := new(cgoAllocMap)
	allocs1d0e82d4.Add(mem1d0e82d4)

	ref1d0e82d4.sType = (C.VkStructureType)(x.SType)

	ref1d0e82d4.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref1d0e82d4.waitSemaphoreCount = (C.uint32_t)(x.WaitSemaphoreCount)

	if x.PWaitSemaphores != nil {
		var cpWaitSemaphores_allocs *cgoAllocMap
		ref1d0e82d4.pWaitSemaphores, cpWaitSemaphores_allocs = copyPSemaphoreBytes((*sliceHeader)(unsafe.Pointer(&x.PWaitSemaphores)))
		allocs1d0e82d4.Borrow(cpWaitSemaphores_allocs)
	}

	ref1d0e82d4.swapchainCount = (C.uint32_t)(x.SwapchainCount)

	if x.PSwapchains != nil {
		var cpSwapchains_allocs *cgoAllocMap
		ref1d0e82d4.pSwapchains, cpSwapchains_allocs = copyPSwapchainBytes((*sliceHeader)(unsafe.Pointer(&x.PSwapchains)))
		allocs1d0e82d4.Borrow(cpSwapchains_allocs)
	}

	if x.PImageIndices != nil {
		var cpImageIndices_allocs *cgoAllocMap
		ref1d0e82d4.pImageIndices, cpImageIndices_allocs = copyPUint32_tBytes((*sliceHeader)(unsafe.Pointer(&x.PImageIndices)))
		allocs1d0e82d4.Borrow(cpImageIndices_allocs)
	}

	if x.PResults != nil {
		var cpResults_allocs *cgoAllocMap
		ref1d0e82d4.pResults, cpResults_allocs = copyPResultBytes((*sliceHeader)(unsafe.Pointer(&x.PResults)))
		allocs1d0e82d4.Borrow(cpResults_allocs)
	}

	x.ref1d0e82d4 = ref1d0e82d4
	x.allocs1d0e82d4 = allocs1d0e82d4
	return ref1d0e82d4, allocs1d0e82d4

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PresentInfo) PassValue() (C.VkPresentInfoKHR, *cgoAllocMap) {
	if x.ref1d0e82d4 != nil {
		return *x.ref1d0e82d4, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PresentInfo) Deref() {
	if x.ref1d0e82d4 == nil {
		return
	}
	x.SType = (StructureType)(x.ref1d0e82d4.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref1d0e82d4.pNext))
	x.WaitSemaphoreCount = (uint32)(x.ref1d0e82d4.waitSemaphoreCount)
	hxfe80fc5 := (*sliceHeader)(unsafe.Pointer(&x.PWaitSemaphores))
	hxfe80fc5.Data = unsafe.Pointer(x.ref1d0e82d4.pWaitSemaphores)
	hxfe80fc5.Cap = 0x7fffffff
	// hxfe80fc5.Len = ? x.PWaitSemaphores x.ref1d0e82d4.pWaitSemaphores

	x.SwapchainCount = (uint32)(x.ref1d0e82d4.swapchainCount)
	hxfc03c44 := (*sliceHeader)(unsafe.Pointer(&x.PSwapchains))
	hxfc03c44.Data = unsafe.Pointer(x.ref1d0e82d4.pSwapchains)
	hxfc03c44.Cap = 0x7fffffff
	// hxfc03c44.Len = ? x.PSwapchains x.ref1d0e82d4.pSwapchains

	hxf32b611 := (*sliceHeader)(unsafe.Pointer(&x.PImageIndices))
	hxf32b611.Data = unsafe.Pointer(x.ref1d0e82d4.pImageIndices)
	hxf32b611.Cap = 0x7fffffff
	// hxf32b611.Len = ? x.PImageIndices x.ref1d0e82d4.pImageIndices

	hxf187e71 := (*sliceHeader)(unsafe.Pointer(&x.PResults))
	hxf187e71.Data = unsafe.Pointer(x.ref1d0e82d4.pResults)
	hxf187e71.Cap = 0x7fffffff
	// hxf187e71.Len = ? x.PResults x.ref1d0e82d4.pResults

}

// allocImageSwapchainCreateInfoMemory allocates memory for type C.VkImageSwapchainCreateInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageSwapchainCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageSwapchainCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfImageSwapchainCreateInfoValue = unsafe.Sizeof([1]C.VkImageSwapchainCreateInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImageSwapchainCreateInfo) Ref() *C.VkImageSwapchainCreateInfoKHR {
	if x == nil {
		return nil
	}
	return x.refd83cc5d0
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImageSwapchainCreateInfo) Free() {
	if x != nil && x.allocsd83cc5d0 != nil {
		x.allocsd83cc5d0.(*cgoAllocMap).Free()
		x.refd83cc5d0 = nil
	}
}

// NewImageSwapchainCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageSwapchainCreateInfoRef(ref unsafe.Pointer) *ImageSwapchainCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(ImageSwapchainCreateInfo)
	obj.refd83cc5d0 = (*C.VkImageSwapchainCreateInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImageSwapchainCreateInfo) PassRef() (*C.VkImageSwapchainCreateInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd83cc5d0 != nil {
		return x.refd83cc5d0, nil
	}
	memd83cc5d0 := allocImageSwapchainCreateInfoMemory(1)
	refd83cc5d0 := (*C.VkImageSwapchainCreateInfoKHR)(memd83cc5d0)
	allocsd83cc5d0 := new(cgoAllocMap)
	allocsd83cc5d0.Add(memd83cc5d0)

	refd83cc5d0.sType = (C.VkStructureType)(x.SType)

	refd83cc5d0.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	refd83cc5d0.swapchain = *(*C.VkSwapchainKHR)(unsafe.Pointer(&x.Swapchain))

	x.refd83cc5d0 = refd83cc5d0
	x.allocsd83cc5d0 = allocsd83cc5d0
	return refd83cc5d0, allocsd83cc5d0

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImageSwapchainCreateInfo) PassValue() (C.VkImageSwapchainCreateInfoKHR, *cgoAllocMap) {
	if x.refd83cc5d0 != nil {
		return *x.refd83cc5d0, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImageSwapchainCreateInfo) Deref() {
	if x.refd83cc5d0 == nil {
		return
	}
	x.SType = (StructureType)(x.refd83cc5d0.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refd83cc5d0.pNext))
	x.Swapchain = *(*Swapchain)(unsafe.Pointer(&x.refd83cc5d0.swapchain))
}

// allocBindImageMemorySwapchainInfoMemory allocates memory for type C.VkBindImageMemorySwapchainInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBindImageMemorySwapchainInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBindImageMemorySwapchainInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBindImageMemorySwapchainInfoValue = unsafe.Sizeof([1]C.VkBindImageMemorySwapchainInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BindImageMemorySwapchainInfo) Ref() *C.VkBindImageMemorySwapchainInfoKHR {
	if x == nil {
		return nil
	}
	return x.ref1aa25cb6
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BindImageMemorySwapchainInfo) Free() {
	if x != nil && x.allocs1aa25cb6 != nil {
		x.allocs1aa25cb6.(*cgoAllocMap).Free()
		x.ref1aa25cb6 = nil
	}
}

// NewBindImageMemorySwapchainInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBindImageMemorySwapchainInfoRef(ref unsafe.Pointer) *BindImageMemorySwapchainInfo {
	if ref == nil {
		return nil
	}
	obj := new(BindImageMemorySwapchainInfo)
	obj.ref1aa25cb6 = (*C.VkBindImageMemorySwapchainInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BindImageMemorySwapchainInfo) PassRef() (*C.VkBindImageMemorySwapchainInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1aa25cb6 != nil {
		return x.ref1aa25cb6, nil
	}
	mem1aa25cb6 := allocBindImageMemorySwapchainInfoMemory(1)
	ref1aa25cb6 := (*C.VkBindImageMemorySwapchainInfoKHR)(mem1aa25cb6)
	allocs1aa25cb6 := new(cgoAllocMap)
	allocs1aa25cb6.Add(mem1aa25cb6)

	ref1aa25cb6.sType = (C.VkStructureType)(x.SType)

	ref1aa25cb6.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref1aa25cb6.swapchain = *(*C.VkSwapchainKHR)(unsafe.Pointer(&x.Swapchain))

	ref1aa25cb6.imageIndex = (C.uint32_t)(x.ImageIndex)

	x.ref1aa25cb6 = ref1aa25cb6
	x.allocs1aa25cb6 = allocs1aa25cb6
	return ref1aa25cb6, allocs1aa25cb6

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BindImageMemorySwapchainInfo) PassValue() (C.VkBindImageMemorySwapchainInfoKHR, *cgoAllocMap) {
	if x.ref1aa25cb6 != nil {
		return *x.ref1aa25cb6, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BindImageMemorySwapchainInfo) Deref() {
	if x.ref1aa25cb6 == nil {
		return
	}
	x.SType = (StructureType)(x.ref1aa25cb6.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref1aa25cb6.pNext))
	x.Swapchain = *(*Swapchain)(unsafe.Pointer(&x.ref1aa25cb6.swapchain))
	x.ImageIndex = (uint32)(x.ref1aa25cb6.imageIndex)
}

// allocAcquireNextImageInfoMemory allocates memory for type C.VkAcquireNextImageInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAcquireNextImageInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAcquireNextImageInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfAcquireNextImageInfoValue = unsafe.Sizeof([1]C.VkAcquireNextImageInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *AcquireNextImageInfo) Ref() *C.VkAcquireNextImageInfoKHR {
	if x == nil {
		return nil
	}
	return x.ref588806a5
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *AcquireNextImageInfo) Free() {
	if x != nil && x.allocs588806a5 != nil {
		x.allocs588806a5.(*cgoAllocMap).Free()
		x.ref588806a5 = nil
	}
}

// NewAcquireNextImageInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewAcquireNextImageInfoRef(ref unsafe.Pointer) *AcquireNextImageInfo {
	if ref == nil {
		return nil
	}
	obj := new(AcquireNextImageInfo)
	obj.ref588806a5 = (*C.VkAcquireNextImageInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *AcquireNextImageInfo) PassRef() (*C.VkAcquireNextImageInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref588806a5 != nil {
		return x.ref588806a5, nil
	}
	mem588806a5 := allocAcquireNextImageInfoMemory(1)
	ref588806a5 := (*C.VkAcquireNextImageInfoKHR)(mem588806a5)
	allocs588806a5 := new(cgoAllocMap)
	allocs588806a5.Add(mem588806a5)

	ref588806a5.sType = (C.VkStructureType)(x.SType)

	ref588806a5.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref588806a5.swapchain = *(*C.VkSwapchainKHR)(unsafe.Pointer(&x.Swapchain))

	ref588806a5.timeout = (C.uint64_t)(x.Timeout)

	ref588806a5.semaphore = *(*C.VkSemaphore)(unsafe.Pointer(&x.Semaphore))

	ref588806a5.fence = *(*C.VkFence)(unsafe.Pointer(&x.Fence))

	ref588806a5.deviceMask = (C.uint32_t)(x.DeviceMask)

	x.ref588806a5 = ref588806a5
	x.allocs588806a5 = allocs588806a5
	return ref588806a5, allocs588806a5

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x AcquireNextImageInfo) PassValue() (C.VkAcquireNextImageInfoKHR, *cgoAllocMap) {
	if x.ref588806a5 != nil {
		return *x.ref588806a5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *AcquireNextImageInfo) Deref() {
	if x.ref588806a5 == nil {
		return
	}
	x.SType = (StructureType)(x.ref588806a5.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref588806a5.pNext))
	x.Swapchain = *(*Swapchain)(unsafe.Pointer(&x.ref588806a5.swapchain))
	x.Timeout = (uint64)(x.ref588806a5.timeout)
	x.Semaphore = *(*Semaphore)(unsafe.Pointer(&x.ref588806a5.semaphore))
	x.Fence = *(*Fence)(unsafe.Pointer(&x.ref588806a5.fence))
	x.DeviceMask = (uint32)(x.ref588806a5.deviceMask)
}

// allocDeviceGroupPresentInfoMemory allocates memory for type C.VkDeviceGroupPresentInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceGroupPresentInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceGroupPresentInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDeviceGroupPresentInfoValue = unsafe.Sizeof([1]C.VkDeviceGroupPresentInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DeviceGroupPresentInfo) Ref() *C.VkDeviceGroupPresentInfoKHR {
	if x == nil {
		return nil
	}
	return x.reff6912d09
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DeviceGroupPresentInfo) Free() {
	if x != nil && x.allocsf6912d09 != nil {
		x.allocsf6912d09.(*cgoAllocMap).Free()
		x.reff6912d09 = nil
	}
}

// NewDeviceGroupPresentInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDeviceGroupPresentInfoRef(ref unsafe.Pointer) *DeviceGroupPresentInfo {
	if ref == nil {
		return nil
	}
	obj := new(DeviceGroupPresentInfo)
	obj.reff6912d09 = (*C.VkDeviceGroupPresentInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DeviceGroupPresentInfo) PassRef() (*C.VkDeviceGroupPresentInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff6912d09 != nil {
		return x.reff6912d09, nil
	}
	memf6912d09 := allocDeviceGroupPresentInfoMemory(1)
	reff6912d09 := (*C.VkDeviceGroupPresentInfoKHR)(memf6912d09)
	allocsf6912d09 := new(cgoAllocMap)
	allocsf6912d09.Add(memf6912d09)

	reff6912d09.sType = (C.VkStructureType)(x.SType)

	reff6912d09.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	reff6912d09.swapchainCount = (C.uint32_t)(x.SwapchainCount)

	if x.PDeviceMasks != nil {
		var cpDeviceMasks_allocs *cgoAllocMap
		reff6912d09.pDeviceMasks, cpDeviceMasks_allocs = copyPUint32_tBytes((*sliceHeader)(unsafe.Pointer(&x.PDeviceMasks)))
		allocsf6912d09.Borrow(cpDeviceMasks_allocs)
	}

	reff6912d09.mode = (C.VkDeviceGroupPresentModeFlagBitsKHR)(x.Mode)

	x.reff6912d09 = reff6912d09
	x.allocsf6912d09 = allocsf6912d09
	return reff6912d09, allocsf6912d09

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DeviceGroupPresentInfo) PassValue() (C.VkDeviceGroupPresentInfoKHR, *cgoAllocMap) {
	if x.reff6912d09 != nil {
		return *x.reff6912d09, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DeviceGroupPresentInfo) Deref() {
	if x.reff6912d09 == nil {
		return
	}
	x.SType = (StructureType)(x.reff6912d09.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.reff6912d09.pNext))
	x.SwapchainCount = (uint32)(x.reff6912d09.swapchainCount)
	hxf13e50a := (*sliceHeader)(unsafe.Pointer(&x.PDeviceMasks))
	hxf13e50a.Data = unsafe.Pointer(x.reff6912d09.pDeviceMasks)
	hxf13e50a.Cap = 0x7fffffff
	// hxf13e50a.Len = ? x.PDeviceMasks x.reff6912d09.pDeviceMasks

	x.Mode = (DeviceGroupPresentModeFlagBits)(x.reff6912d09.mode)
}

// allocDisplayModePropertiesMemory allocates memory for type C.VkDisplayModePropertiesKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDisplayModePropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDisplayModePropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDisplayModePropertiesValue = unsafe.Sizeof([1]C.VkDisplayModePropertiesKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DisplayModeProperties) Ref() *C.VkDisplayModePropertiesKHR {
	if x == nil {
		return nil
	}
	return x.ref5e3abaaa
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DisplayModeProperties) Free() {
	if x != nil && x.allocs5e3abaaa != nil {
		x.allocs5e3abaaa.(*cgoAllocMap).Free()
		x.ref5e3abaaa = nil
	}
}

// NewDisplayModePropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDisplayModePropertiesRef(ref unsafe.Pointer) *DisplayModeProperties {
	if ref == nil {
		return nil
	}
	obj := new(DisplayModeProperties)
	obj.ref5e3abaaa = (*C.VkDisplayModePropertiesKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DisplayModeProperties) PassRef() (*C.VkDisplayModePropertiesKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5e3abaaa != nil {
		return x.ref5e3abaaa, nil
	}
	mem5e3abaaa := allocDisplayModePropertiesMemory(1)
	ref5e3abaaa := (*C.VkDisplayModePropertiesKHR)(mem5e3abaaa)
	allocs5e3abaaa := new(cgoAllocMap)
	allocs5e3abaaa.Add(mem5e3abaaa)

	ref5e3abaaa.displayMode = *(*C.VkDisplayModeKHR)(unsafe.Pointer(&x.DisplayMode))

	ref5e3abaaa.parameters = *(*C.VkDisplayModeParametersKHR)(unsafe.Pointer(&x.Parameters))

	x.ref5e3abaaa = ref5e3abaaa
	x.allocs5e3abaaa = allocs5e3abaaa
	return ref5e3abaaa, allocs5e3abaaa

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DisplayModeProperties) PassValue() (C.VkDisplayModePropertiesKHR, *cgoAllocMap) {
	if x.ref5e3abaaa != nil {
		return *x.ref5e3abaaa, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DisplayModeProperties) Deref() {
	if x.ref5e3abaaa == nil {
		return
	}
	x.DisplayMode = *(*DisplayMode)(unsafe.Pointer(&x.ref5e3abaaa.displayMode))
	x.Parameters = *(*DisplayModeParameters)(unsafe.Pointer(&x.ref5e3abaaa.parameters))
}

// allocDisplayPlanePropertiesMemory allocates memory for type C.VkDisplayPlanePropertiesKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDisplayPlanePropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDisplayPlanePropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDisplayPlanePropertiesValue = unsafe.Sizeof([1]C.VkDisplayPlanePropertiesKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DisplayPlaneProperties) Ref() *C.VkDisplayPlanePropertiesKHR {
	if x == nil {
		return nil
	}
	return x.refce3db3f6
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DisplayPlaneProperties) Free() {
	if x != nil && x.allocsce3db3f6 != nil {
		x.allocsce3db3f6.(*cgoAllocMap).Free()
		x.refce3db3f6 = nil
	}
}

// NewDisplayPlanePropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDisplayPlanePropertiesRef(ref unsafe.Pointer) *DisplayPlaneProperties {
	if ref == nil {
		return nil
	}
	obj := new(DisplayPlaneProperties)
	obj.refce3db3f6 = (*C.VkDisplayPlanePropertiesKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DisplayPlaneProperties) PassRef() (*C.VkDisplayPlanePropertiesKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refce3db3f6 != nil {
		return x.refce3db3f6, nil
	}
	memce3db3f6 := allocDisplayPlanePropertiesMemory(1)
	refce3db3f6 := (*C.VkDisplayPlanePropertiesKHR)(memce3db3f6)
	allocsce3db3f6 := new(cgoAllocMap)
	allocsce3db3f6.Add(memce3db3f6)

	refce3db3f6.currentDisplay = *(*C.VkDisplayKHR)(unsafe.Pointer(&x.CurrentDisplay))

	refce3db3f6.currentStackIndex = (C.uint32_t)(x.CurrentStackIndex)

	x.refce3db3f6 = refce3db3f6
	x.allocsce3db3f6 = allocsce3db3f6
	return refce3db3f6, allocsce3db3f6

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DisplayPlaneProperties) PassValue() (C.VkDisplayPlanePropertiesKHR, *cgoAllocMap) {
	if x.refce3db3f6 != nil {
		return *x.refce3db3f6, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DisplayPlaneProperties) Deref() {
	if x.refce3db3f6 == nil {
		return
	}
	x.CurrentDisplay = *(*Display)(unsafe.Pointer(&x.refce3db3f6.currentDisplay))
	x.CurrentStackIndex = (uint32)(x.refce3db3f6.currentStackIndex)
}

// allocDisplayPropertiesMemory allocates memory for type C.VkDisplayPropertiesKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDisplayPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDisplayPropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDisplayPropertiesValue = unsafe.Sizeof([1]C.VkDisplayPropertiesKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DisplayProperties) Ref() *C.VkDisplayPropertiesKHR {
	if x == nil {
		return nil
	}
	return x.reffe2a7187
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DisplayProperties) Free() {
	if x != nil && x.allocsfe2a7187 != nil {
		x.allocsfe2a7187.(*cgoAllocMap).Free()
		x.reffe2a7187 = nil
	}
}

// NewDisplayPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDisplayPropertiesRef(ref unsafe.Pointer) *DisplayProperties {
	if ref == nil {
		return nil
	}
	obj := new(DisplayProperties)
	obj.reffe2a7187 = (*C.VkDisplayPropertiesKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DisplayProperties) PassRef() (*C.VkDisplayPropertiesKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reffe2a7187 != nil {
		return x.reffe2a7187, nil
	}
	memfe2a7187 := allocDisplayPropertiesMemory(1)
	reffe2a7187 := (*C.VkDisplayPropertiesKHR)(memfe2a7187)
	allocsfe2a7187 := new(cgoAllocMap)
	allocsfe2a7187.Add(memfe2a7187)

	reffe2a7187.display = *(*C.VkDisplayKHR)(unsafe.Pointer(&x.Display))

	var cdisplayName_allocs *cgoAllocMap
	reffe2a7187.displayName, cdisplayName_allocs = copyPCharBytes((*sliceHeader)(unsafe.Pointer(&x.DisplayName)))
	allocsfe2a7187.Borrow(cdisplayName_allocs)

	reffe2a7187.physicalDimensions = *(*C.VkExtent2D)(unsafe.Pointer(&x.PhysicalDimensions))

	reffe2a7187.physicalResolution = *(*C.VkExtent2D)(unsafe.Pointer(&x.PhysicalResolution))

	reffe2a7187.supportedTransforms = (C.VkSurfaceTransformFlagsKHR)(x.SupportedTransforms)

	reffe2a7187.planeReorderPossible = (C.VkBool32)(x.PlaneReorderPossible)

	reffe2a7187.persistentContent = (C.VkBool32)(x.PersistentContent)

	x.reffe2a7187 = reffe2a7187
	x.allocsfe2a7187 = allocsfe2a7187
	return reffe2a7187, allocsfe2a7187

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DisplayProperties) PassValue() (C.VkDisplayPropertiesKHR, *cgoAllocMap) {
	if x.reffe2a7187 != nil {
		return *x.reffe2a7187, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DisplayProperties) Deref() {
	if x.reffe2a7187 == nil {
		return
	}
	x.Display = *(*Display)(unsafe.Pointer(&x.reffe2a7187.display))
	hxf9227c2 := (*sliceHeader)(unsafe.Pointer(&x.DisplayName))
	hxf9227c2.Data = unsafe.Pointer(x.reffe2a7187.displayName)
	hxf9227c2.Cap = 0x7fffffff
	// hxf9227c2.Len = ? x.DisplayName x.reffe2a7187.displayName

	x.PhysicalDimensions = *(*Extent2D)(unsafe.Pointer(&x.reffe2a7187.physicalDimensions))
	x.PhysicalResolution = *(*Extent2D)(unsafe.Pointer(&x.reffe2a7187.physicalResolution))
	x.SupportedTransforms = (SurfaceTransformFlags)(x.reffe2a7187.supportedTransforms)
	x.PlaneReorderPossible = (Bool32)(x.reffe2a7187.planeReorderPossible)
	x.PersistentContent = (Bool32)(x.reffe2a7187.persistentContent)
}

// allocDisplaySurfaceCreateInfoMemory allocates memory for type C.VkDisplaySurfaceCreateInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDisplaySurfaceCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDisplaySurfaceCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDisplaySurfaceCreateInfoValue = unsafe.Sizeof([1]C.VkDisplaySurfaceCreateInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DisplaySurfaceCreateInfo) Ref() *C.VkDisplaySurfaceCreateInfoKHR {
	if x == nil {
		return nil
	}
	return x.ref58445c35
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DisplaySurfaceCreateInfo) Free() {
	if x != nil && x.allocs58445c35 != nil {
		x.allocs58445c35.(*cgoAllocMap).Free()
		x.ref58445c35 = nil
	}
}

// NewDisplaySurfaceCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDisplaySurfaceCreateInfoRef(ref unsafe.Pointer) *DisplaySurfaceCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(DisplaySurfaceCreateInfo)
	obj.ref58445c35 = (*C.VkDisplaySurfaceCreateInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DisplaySurfaceCreateInfo) PassRef() (*C.VkDisplaySurfaceCreateInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref58445c35 != nil {
		return x.ref58445c35, nil
	}
	mem58445c35 := allocDisplaySurfaceCreateInfoMemory(1)
	ref58445c35 := (*C.VkDisplaySurfaceCreateInfoKHR)(mem58445c35)
	allocs58445c35 := new(cgoAllocMap)
	allocs58445c35.Add(mem58445c35)

	ref58445c35.sType = (C.VkStructureType)(x.SType)

	ref58445c35.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref58445c35.flags = (C.VkDisplaySurfaceCreateFlagsKHR)(x.Flags)

	ref58445c35.displayMode = *(*C.VkDisplayModeKHR)(unsafe.Pointer(&x.DisplayMode))

	ref58445c35.planeIndex = (C.uint32_t)(x.PlaneIndex)

	ref58445c35.planeStackIndex = (C.uint32_t)(x.PlaneStackIndex)

	ref58445c35.transform = (C.VkSurfaceTransformFlagBitsKHR)(x.Transform)

	ref58445c35.globalAlpha = (C.float)(x.GlobalAlpha)

	ref58445c35.alphaMode = (C.VkDisplayPlaneAlphaFlagBitsKHR)(x.AlphaMode)

	ref58445c35.imageExtent = *(*C.VkExtent2D)(unsafe.Pointer(&x.ImageExtent))

	x.ref58445c35 = ref58445c35
	x.allocs58445c35 = allocs58445c35
	return ref58445c35, allocs58445c35

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DisplaySurfaceCreateInfo) PassValue() (C.VkDisplaySurfaceCreateInfoKHR, *cgoAllocMap) {
	if x.ref58445c35 != nil {
		return *x.ref58445c35, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DisplaySurfaceCreateInfo) Deref() {
	if x.ref58445c35 == nil {
		return
	}
	x.SType = (StructureType)(x.ref58445c35.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref58445c35.pNext))
	x.Flags = (DisplaySurfaceCreateFlags)(x.ref58445c35.flags)
	x.DisplayMode = *(*DisplayMode)(unsafe.Pointer(&x.ref58445c35.displayMode))
	x.PlaneIndex = (uint32)(x.ref58445c35.planeIndex)
	x.PlaneStackIndex = (uint32)(x.ref58445c35.planeStackIndex)
	x.Transform = (SurfaceTransformFlagBits)(x.ref58445c35.transform)
	x.GlobalAlpha = (float32)(x.ref58445c35.globalAlpha)
	x.AlphaMode = (DisplayPlaneAlphaFlagBits)(x.ref58445c35.alphaMode)
	x.ImageExtent = *(*Extent2D)(unsafe.Pointer(&x.ref58445c35.imageExtent))
}

// allocVideoProfileListInfoMemory allocates memory for type C.VkVideoProfileListInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVideoProfileListInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVideoProfileListInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfVideoProfileListInfoValue = unsafe.Sizeof([1]C.VkVideoProfileListInfoKHR{})

// copyPVideoProfileInfoBytes copies the data from Go slice as *C.VkVideoProfileInfoKHR.
func copyPVideoProfileInfoBytes(slice *sliceHeader) (*C.VkVideoProfileInfoKHR, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfVideoProfileInfoValue) * slice.Len,
		Cap:  int(sizeOfVideoProfileInfoValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkVideoProfileInfoKHR)(mem0), allocs
}

// allocVideoProfileInfoMemory allocates memory for type C.VkVideoProfileInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVideoProfileInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVideoProfileInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfVideoProfileInfoValue = unsafe.Sizeof([1]C.VkVideoProfileInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *VideoProfileListInfo) Ref() *C.VkVideoProfileListInfoKHR {
	if x == nil {
		return nil
	}
	return x.refd98c78d7
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *VideoProfileListInfo) Free() {
	if x != nil && x.allocsd98c78d7 != nil {
		x.allocsd98c78d7.(*cgoAllocMap).Free()
		x.refd98c78d7 = nil
	}
}

// NewVideoProfileListInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewVideoProfileListInfoRef(ref unsafe.Pointer) *VideoProfileListInfo {
	if ref == nil {
		return nil
	}
	obj := new(VideoProfileListInfo)
	obj.refd98c78d7 = (*C.VkVideoProfileListInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *VideoProfileListInfo) PassRef() (*C.VkVideoProfileListInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd98c78d7 != nil {
		return x.refd98c78d7, nil
	}
	memd98c78d7 := allocVideoProfileListInfoMemory(1)
	refd98c78d7 := (*C.VkVideoProfileListInfoKHR)(memd98c78d7)
	allocsd98c78d7 := new(cgoAllocMap)
	allocsd98c78d7.Add(memd98c78d7)

	refd98c78d7.sType = (C.VkStructureType)(x.SType)

	refd98c78d7.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	refd98c78d7.profileCount = (C.uint32_t)(x.ProfileCount)

	if x.PProfiles != nil {
		var cpProfiles_allocs *cgoAllocMap
		refd98c78d7.pProfiles, cpProfiles_allocs = copyPVideoProfileInfoBytes((*sliceHeader)(unsafe.Pointer(&x.PProfiles)))
		allocsd98c78d7.Borrow(cpProfiles_allocs)
	}

	x.refd98c78d7 = refd98c78d7
	x.allocsd98c78d7 = allocsd98c78d7
	return refd98c78d7, allocsd98c78d7

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x VideoProfileListInfo) PassValue() (C.VkVideoProfileListInfoKHR, *cgoAllocMap) {
	if x.refd98c78d7 != nil {
		return *x.refd98c78d7, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *VideoProfileListInfo) Deref() {
	if x.refd98c78d7 == nil {
		return
	}
	x.SType = (StructureType)(x.refd98c78d7.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refd98c78d7.pNext))
	x.ProfileCount = (uint32)(x.refd98c78d7.profileCount)
	hxfa7b2ab := (*sliceHeader)(unsafe.Pointer(&x.PProfiles))
	hxfa7b2ab.Data = unsafe.Pointer(x.refd98c78d7.pProfiles)
	hxfa7b2ab.Cap = 0x7fffffff
	// hxfa7b2ab.Len = ? x.PProfiles x.refd98c78d7.pProfiles

}

// allocVideoCapabilitiesMemory allocates memory for type C.VkVideoCapabilitiesKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVideoCapabilitiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVideoCapabilitiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfVideoCapabilitiesValue = unsafe.Sizeof([1]C.VkVideoCapabilitiesKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *VideoCapabilities) Ref() *C.VkVideoCapabilitiesKHR {
	if x == nil {
		return nil
	}
	return x.reff1959efe
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *VideoCapabilities) Free() {
	if x != nil && x.allocsf1959efe != nil {
		x.allocsf1959efe.(*cgoAllocMap).Free()
		x.reff1959efe = nil
	}
}

// NewVideoCapabilitiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewVideoCapabilitiesRef(ref unsafe.Pointer) *VideoCapabilities {
	if ref == nil {
		return nil
	}
	obj := new(VideoCapabilities)
	obj.reff1959efe = (*C.VkVideoCapabilitiesKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *VideoCapabilities) PassRef() (*C.VkVideoCapabilitiesKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff1959efe != nil {
		return x.reff1959efe, nil
	}
	memf1959efe := allocVideoCapabilitiesMemory(1)
	reff1959efe := (*C.VkVideoCapabilitiesKHR)(memf1959efe)
	allocsf1959efe := new(cgoAllocMap)
	allocsf1959efe.Add(memf1959efe)

	reff1959efe.sType = (C.VkStructureType)(x.SType)

	reff1959efe.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	reff1959efe.flags = (C.VkVideoCapabilityFlagsKHR)(x.Flags)

	reff1959efe.minBitstreamBufferOffsetAlignment = (C.VkDeviceSize)(x.MinBitstreamBufferOffsetAlignment)

	reff1959efe.minBitstreamBufferSizeAlignment = (C.VkDeviceSize)(x.MinBitstreamBufferSizeAlignment)

	reff1959efe.pictureAccessGranularity = *(*C.VkExtent2D)(unsafe.Pointer(&x.PictureAccessGranularity))

	reff1959efe.minCodedExtent = *(*C.VkExtent2D)(unsafe.Pointer(&x.MinCodedExtent))

	reff1959efe.maxCodedExtent = *(*C.VkExtent2D)(unsafe.Pointer(&x.MaxCodedExtent))

	reff1959efe.maxDpbSlots = (C.uint32_t)(x.MaxDpbSlots)

	reff1959efe.maxActiveReferencePictures = (C.uint32_t)(x.MaxActiveReferencePictures)

	var cstdHeaderVersion_allocs *cgoAllocMap
	reff1959efe.stdHeaderVersion, cstdHeaderVersion_allocs = x.StdHeaderVersion.PassValue()
	allocsf1959efe.Borrow(cstdHeaderVersion_allocs)

	x.reff1959efe = reff1959efe
	x.allocsf1959efe = allocsf1959efe
	return reff1959efe, allocsf1959efe

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x VideoCapabilities) PassValue() (C.VkVideoCapabilitiesKHR, *cgoAllocMap) {
	if x.reff1959efe != nil {
		return *x.reff1959efe, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *VideoCapabilities) Deref() {
	if x.reff1959efe == nil {
		return
	}
	x.SType = (StructureType)(x.reff1959efe.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.reff1959efe.pNext))
	x.Flags = (VideoCapabilityFlags)(x.reff1959efe.flags)
	x.MinBitstreamBufferOffsetAlignment = (DeviceSize)(x.reff1959efe.minBitstreamBufferOffsetAlignment)
	x.MinBitstreamBufferSizeAlignment = (DeviceSize)(x.reff1959efe.minBitstreamBufferSizeAlignment)
	x.PictureAccessGranularity = *(*Extent2D)(unsafe.Pointer(&x.reff1959efe.pictureAccessGranularity))
	x.MinCodedExtent = *(*Extent2D)(unsafe.Pointer(&x.reff1959efe.minCodedExtent))
	x.MaxCodedExtent = *(*Extent2D)(unsafe.Pointer(&x.reff1959efe.maxCodedExtent))
	x.MaxDpbSlots = (uint32)(x.reff1959efe.maxDpbSlots)
	x.MaxActiveReferencePictures = (uint32)(x.reff1959efe.maxActiveReferencePictures)
	x.StdHeaderVersion = *NewExtensionPropertiesRef(unsafe.Pointer(&x.reff1959efe.stdHeaderVersion))
}

// allocVideoPictureResourceInfoMemory allocates memory for type C.VkVideoPictureResourceInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVideoPictureResourceInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVideoPictureResourceInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfVideoPictureResourceInfoValue = unsafe.Sizeof([1]C.VkVideoPictureResourceInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *VideoPictureResourceInfo) Ref() *C.VkVideoPictureResourceInfoKHR {
	if x == nil {
		return nil
	}
	return x.refe7a42049
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *VideoPictureResourceInfo) Free() {
	if x != nil && x.allocse7a42049 != nil {
		x.allocse7a42049.(*cgoAllocMap).Free()
		x.refe7a42049 = nil
	}
}

// NewVideoPictureResourceInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewVideoPictureResourceInfoRef(ref unsafe.Pointer) *VideoPictureResourceInfo {
	if ref == nil {
		return nil
	}
	obj := new(VideoPictureResourceInfo)
	obj.refe7a42049 = (*C.VkVideoPictureResourceInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *VideoPictureResourceInfo) PassRef() (*C.VkVideoPictureResourceInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe7a42049 != nil {
		return x.refe7a42049, nil
	}
	meme7a42049 := allocVideoPictureResourceInfoMemory(1)
	refe7a42049 := (*C.VkVideoPictureResourceInfoKHR)(meme7a42049)
	allocse7a42049 := new(cgoAllocMap)
	allocse7a42049.Add(meme7a42049)

	refe7a42049.sType = (C.VkStructureType)(x.SType)

	refe7a42049.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	refe7a42049.codedOffset = *(*C.VkOffset2D)(unsafe.Pointer(&x.CodedOffset))

	refe7a42049.codedExtent = *(*C.VkExtent2D)(unsafe.Pointer(&x.CodedExtent))

	refe7a42049.baseArrayLayer = (C.uint32_t)(x.BaseArrayLayer)

	refe7a42049.imageViewBinding = *(*C.VkImageView)(unsafe.Pointer(&x.ImageViewBinding))

	x.refe7a42049 = refe7a42049
	x.allocse7a42049 = allocse7a42049
	return refe7a42049, allocse7a42049

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x VideoPictureResourceInfo) PassValue() (C.VkVideoPictureResourceInfoKHR, *cgoAllocMap) {
	if x.refe7a42049 != nil {
		return *x.refe7a42049, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *VideoPictureResourceInfo) Deref() {
	if x.refe7a42049 == nil {
		return
	}
	x.SType = (StructureType)(x.refe7a42049.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refe7a42049.pNext))
	x.CodedOffset = *(*Offset2D)(unsafe.Pointer(&x.refe7a42049.codedOffset))
	x.CodedExtent = *(*Extent2D)(unsafe.Pointer(&x.refe7a42049.codedExtent))
	x.BaseArrayLayer = (uint32)(x.refe7a42049.baseArrayLayer)
	x.ImageViewBinding = *(*ImageView)(unsafe.Pointer(&x.refe7a42049.imageViewBinding))
}

// allocVideoReferenceSlotInfoMemory allocates memory for type C.VkVideoReferenceSlotInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVideoReferenceSlotInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVideoReferenceSlotInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfVideoReferenceSlotInfoValue = unsafe.Sizeof([1]C.VkVideoReferenceSlotInfoKHR{})

// unpackSVideoPictureResourceInfo transforms a sliced Go data structure into plain C format.
func unpackSVideoPictureResourceInfo(x []VideoPictureResourceInfo) (unpacked *C.VkVideoPictureResourceInfoKHR, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocVideoPictureResourceInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkVideoPictureResourceInfoKHR)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkVideoPictureResourceInfoKHR)(h.Data)
	return
}

// packSVideoPictureResourceInfo reads sliced Go data structure out from plain C format.
func packSVideoPictureResourceInfo(v []VideoPictureResourceInfo, ptr0 *C.VkVideoPictureResourceInfoKHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfVideoPictureResourceInfoValue]C.VkVideoPictureResourceInfoKHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewVideoPictureResourceInfoRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *VideoReferenceSlotInfo) Ref() *C.VkVideoReferenceSlotInfoKHR {
	if x == nil {
		return nil
	}
	return x.refbbd1d28
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *VideoReferenceSlotInfo) Free() {
	if x != nil && x.allocsbbd1d28 != nil {
		x.allocsbbd1d28.(*cgoAllocMap).Free()
		x.refbbd1d28 = nil
	}
}

// NewVideoReferenceSlotInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewVideoReferenceSlotInfoRef(ref unsafe.Pointer) *VideoReferenceSlotInfo {
	if ref == nil {
		return nil
	}
	obj := new(VideoReferenceSlotInfo)
	obj.refbbd1d28 = (*C.VkVideoReferenceSlotInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *VideoReferenceSlotInfo) PassRef() (*C.VkVideoReferenceSlotInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refbbd1d28 != nil {
		return x.refbbd1d28, nil
	}
	membbd1d28 := allocVideoReferenceSlotInfoMemory(1)
	refbbd1d28 := (*C.VkVideoReferenceSlotInfoKHR)(membbd1d28)
	allocsbbd1d28 := new(cgoAllocMap)
	allocsbbd1d28.Add(membbd1d28)

	refbbd1d28.sType = (C.VkStructureType)(x.SType)

	refbbd1d28.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	refbbd1d28.slotIndex = (C.int32_t)(x.SlotIndex)

	var cpPictureResource_allocs *cgoAllocMap
	refbbd1d28.pPictureResource, cpPictureResource_allocs = unpackSVideoPictureResourceInfo(x.PPictureResource)
	allocsbbd1d28.Borrow(cpPictureResource_allocs)

	x.refbbd1d28 = refbbd1d28
	x.allocsbbd1d28 = allocsbbd1d28
	return refbbd1d28, allocsbbd1d28

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x VideoReferenceSlotInfo) PassValue() (C.VkVideoReferenceSlotInfoKHR, *cgoAllocMap) {
	if x.refbbd1d28 != nil {
		return *x.refbbd1d28, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *VideoReferenceSlotInfo) Deref() {
	if x.refbbd1d28 == nil {
		return
	}
	x.SType = (StructureType)(x.refbbd1d28.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refbbd1d28.pNext))
	x.SlotIndex = (int32)(x.refbbd1d28.slotIndex)
	packSVideoPictureResourceInfo(x.PPictureResource, x.refbbd1d28.pPictureResource)
}

// allocBindVideoSessionMemoryInfoMemory allocates memory for type C.VkBindVideoSessionMemoryInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBindVideoSessionMemoryInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBindVideoSessionMemoryInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBindVideoSessionMemoryInfoValue = unsafe.Sizeof([1]C.VkBindVideoSessionMemoryInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BindVideoSessionMemoryInfo) Ref() *C.VkBindVideoSessionMemoryInfoKHR {
	if x == nil {
		return nil
	}
	return x.refaa36fd7c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BindVideoSessionMemoryInfo) Free() {
	if x != nil && x.allocsaa36fd7c != nil {
		x.allocsaa36fd7c.(*cgoAllocMap).Free()
		x.refaa36fd7c = nil
	}
}

// NewBindVideoSessionMemoryInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBindVideoSessionMemoryInfoRef(ref unsafe.Pointer) *BindVideoSessionMemoryInfo {
	if ref == nil {
		return nil
	}
	obj := new(BindVideoSessionMemoryInfo)
	obj.refaa36fd7c = (*C.VkBindVideoSessionMemoryInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BindVideoSessionMemoryInfo) PassRef() (*C.VkBindVideoSessionMemoryInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refaa36fd7c != nil {
		return x.refaa36fd7c, nil
	}
	memaa36fd7c := allocBindVideoSessionMemoryInfoMemory(1)
	refaa36fd7c := (*C.VkBindVideoSessionMemoryInfoKHR)(memaa36fd7c)
	allocsaa36fd7c := new(cgoAllocMap)
	allocsaa36fd7c.Add(memaa36fd7c)

	refaa36fd7c.sType = (C.VkStructureType)(x.SType)

	refaa36fd7c.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	refaa36fd7c.memoryBindIndex = (C.uint32_t)(x.MemoryBindIndex)

	refaa36fd7c.memory = *(*C.VkDeviceMemory)(unsafe.Pointer(&x.Memory))

	refaa36fd7c.memoryOffset = (C.VkDeviceSize)(x.MemoryOffset)

	refaa36fd7c.memorySize = (C.VkDeviceSize)(x.MemorySize)

	x.refaa36fd7c = refaa36fd7c
	x.allocsaa36fd7c = allocsaa36fd7c
	return refaa36fd7c, allocsaa36fd7c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BindVideoSessionMemoryInfo) PassValue() (C.VkBindVideoSessionMemoryInfoKHR, *cgoAllocMap) {
	if x.refaa36fd7c != nil {
		return *x.refaa36fd7c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BindVideoSessionMemoryInfo) Deref() {
	if x.refaa36fd7c == nil {
		return
	}
	x.SType = (StructureType)(x.refaa36fd7c.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refaa36fd7c.pNext))
	x.MemoryBindIndex = (uint32)(x.refaa36fd7c.memoryBindIndex)
	x.Memory = *(*DeviceMemory)(unsafe.Pointer(&x.refaa36fd7c.memory))
	x.MemoryOffset = (DeviceSize)(x.refaa36fd7c.memoryOffset)
	x.MemorySize = (DeviceSize)(x.refaa36fd7c.memorySize)
}

// allocVideoSessionCreateInfoMemory allocates memory for type C.VkVideoSessionCreateInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVideoSessionCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVideoSessionCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfVideoSessionCreateInfoValue = unsafe.Sizeof([1]C.VkVideoSessionCreateInfoKHR{})

// unpackSExtensionProperties transforms a sliced Go data structure into plain C format.
func unpackSExtensionProperties(x []ExtensionProperties) (unpacked *C.VkExtensionProperties, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocExtensionPropertiesMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkExtensionProperties)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkExtensionProperties)(h.Data)
	return
}

// packSExtensionProperties reads sliced Go data structure out from plain C format.
func packSExtensionProperties(v []ExtensionProperties, ptr0 *C.VkExtensionProperties) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfExtensionPropertiesValue]C.VkExtensionProperties)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewExtensionPropertiesRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *VideoSessionCreateInfo) Ref() *C.VkVideoSessionCreateInfoKHR {
	if x == nil {
		return nil
	}
	return x.refaf4ef5a1
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *VideoSessionCreateInfo) Free() {
	if x != nil && x.allocsaf4ef5a1 != nil {
		x.allocsaf4ef5a1.(*cgoAllocMap).Free()
		x.refaf4ef5a1 = nil
	}
}

// NewVideoSessionCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewVideoSessionCreateInfoRef(ref unsafe.Pointer) *VideoSessionCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(VideoSessionCreateInfo)
	obj.refaf4ef5a1 = (*C.VkVideoSessionCreateInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *VideoSessionCreateInfo) PassRef() (*C.VkVideoSessionCreateInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refaf4ef5a1 != nil {
		return x.refaf4ef5a1, nil
	}
	memaf4ef5a1 := allocVideoSessionCreateInfoMemory(1)
	refaf4ef5a1 := (*C.VkVideoSessionCreateInfoKHR)(memaf4ef5a1)
	allocsaf4ef5a1 := new(cgoAllocMap)
	allocsaf4ef5a1.Add(memaf4ef5a1)

	refaf4ef5a1.sType = (C.VkStructureType)(x.SType)

	refaf4ef5a1.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	refaf4ef5a1.queueFamilyIndex = (C.uint32_t)(x.QueueFamilyIndex)

	refaf4ef5a1.flags = (C.VkVideoSessionCreateFlagsKHR)(x.Flags)

	if x.PVideoProfile != nil {
		var cpVideoProfile_allocs *cgoAllocMap
		refaf4ef5a1.pVideoProfile, cpVideoProfile_allocs = copyPVideoProfileInfoBytes((*sliceHeader)(unsafe.Pointer(&x.PVideoProfile)))
		allocsaf4ef5a1.Borrow(cpVideoProfile_allocs)
	}

	refaf4ef5a1.pictureFormat = (C.VkFormat)(x.PictureFormat)

	refaf4ef5a1.maxCodedExtent = *(*C.VkExtent2D)(unsafe.Pointer(&x.MaxCodedExtent))

	refaf4ef5a1.referencePictureFormat = (C.VkFormat)(x.ReferencePictureFormat)

	refaf4ef5a1.maxDpbSlots = (C.uint32_t)(x.MaxDpbSlots)

	refaf4ef5a1.maxActiveReferencePictures = (C.uint32_t)(x.MaxActiveReferencePictures)

	var cpStdHeaderVersion_allocs *cgoAllocMap
	refaf4ef5a1.pStdHeaderVersion, cpStdHeaderVersion_allocs = unpackSExtensionProperties(x.PStdHeaderVersion)
	allocsaf4ef5a1.Borrow(cpStdHeaderVersion_allocs)

	x.refaf4ef5a1 = refaf4ef5a1
	x.allocsaf4ef5a1 = allocsaf4ef5a1
	return refaf4ef5a1, allocsaf4ef5a1

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x VideoSessionCreateInfo) PassValue() (C.VkVideoSessionCreateInfoKHR, *cgoAllocMap) {
	if x.refaf4ef5a1 != nil {
		return *x.refaf4ef5a1, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *VideoSessionCreateInfo) Deref() {
	if x.refaf4ef5a1 == nil {
		return
	}
	x.SType = (StructureType)(x.refaf4ef5a1.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refaf4ef5a1.pNext))
	x.QueueFamilyIndex = (uint32)(x.refaf4ef5a1.queueFamilyIndex)
	x.Flags = (VideoSessionCreateFlags)(x.refaf4ef5a1.flags)
	hxfa34053 := (*sliceHeader)(unsafe.Pointer(&x.PVideoProfile))
	hxfa34053.Data = unsafe.Pointer(x.refaf4ef5a1.pVideoProfile)
	hxfa34053.Cap = 0x7fffffff
	// hxfa34053.Len = ? x.PVideoProfile x.refaf4ef5a1.pVideoProfile

	x.PictureFormat = (Format)(x.refaf4ef5a1.pictureFormat)
	x.MaxCodedExtent = *(*Extent2D)(unsafe.Pointer(&x.refaf4ef5a1.maxCodedExtent))
	x.ReferencePictureFormat = (Format)(x.refaf4ef5a1.referencePictureFormat)
	x.MaxDpbSlots = (uint32)(x.refaf4ef5a1.maxDpbSlots)
	x.MaxActiveReferencePictures = (uint32)(x.refaf4ef5a1.maxActiveReferencePictures)
	packSExtensionProperties(x.PStdHeaderVersion, x.refaf4ef5a1.pStdHeaderVersion)
}

// allocVideoSessionParametersCreateInfoMemory allocates memory for type C.VkVideoSessionParametersCreateInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVideoSessionParametersCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVideoSessionParametersCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfVideoSessionParametersCreateInfoValue = unsafe.Sizeof([1]C.VkVideoSessionParametersCreateInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *VideoSessionParametersCreateInfo) Ref() *C.VkVideoSessionParametersCreateInfoKHR {
	if x == nil {
		return nil
	}
	return x.reff62c4e51
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *VideoSessionParametersCreateInfo) Free() {
	if x != nil && x.allocsf62c4e51 != nil {
		x.allocsf62c4e51.(*cgoAllocMap).Free()
		x.reff62c4e51 = nil
	}
}

// NewVideoSessionParametersCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewVideoSessionParametersCreateInfoRef(ref unsafe.Pointer) *VideoSessionParametersCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(VideoSessionParametersCreateInfo)
	obj.reff62c4e51 = (*C.VkVideoSessionParametersCreateInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *VideoSessionParametersCreateInfo) PassRef() (*C.VkVideoSessionParametersCreateInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff62c4e51 != nil {
		return x.reff62c4e51, nil
	}
	memf62c4e51 := allocVideoSessionParametersCreateInfoMemory(1)
	reff62c4e51 := (*C.VkVideoSessionParametersCreateInfoKHR)(memf62c4e51)
	allocsf62c4e51 := new(cgoAllocMap)
	allocsf62c4e51.Add(memf62c4e51)

	reff62c4e51.sType = (C.VkStructureType)(x.SType)

	reff62c4e51.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	reff62c4e51.flags = (C.VkVideoSessionParametersCreateFlagsKHR)(x.Flags)

	reff62c4e51.videoSessionParametersTemplate = *(*C.VkVideoSessionParametersKHR)(unsafe.Pointer(&x.VideoSessionParametersTemplate))

	reff62c4e51.videoSession = *(*C.VkVideoSessionKHR)(unsafe.Pointer(&x.VideoSession))

	x.reff62c4e51 = reff62c4e51
	x.allocsf62c4e51 = allocsf62c4e51
	return reff62c4e51, allocsf62c4e51

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x VideoSessionParametersCreateInfo) PassValue() (C.VkVideoSessionParametersCreateInfoKHR, *cgoAllocMap) {
	if x.reff62c4e51 != nil {
		return *x.reff62c4e51, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *VideoSessionParametersCreateInfo) Deref() {
	if x.reff62c4e51 == nil {
		return
	}
	x.SType = (StructureType)(x.reff62c4e51.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.reff62c4e51.pNext))
	x.Flags = (VideoSessionParametersCreateFlags)(x.reff62c4e51.flags)
	x.VideoSessionParametersTemplate = *(*VideoSessionParameters)(unsafe.Pointer(&x.reff62c4e51.videoSessionParametersTemplate))
	x.VideoSession = *(*VideoSession)(unsafe.Pointer(&x.reff62c4e51.videoSession))
}

// allocVideoBeginCodingInfoMemory allocates memory for type C.VkVideoBeginCodingInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVideoBeginCodingInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVideoBeginCodingInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfVideoBeginCodingInfoValue = unsafe.Sizeof([1]C.VkVideoBeginCodingInfoKHR{})

// unpackSVideoReferenceSlotInfo transforms a sliced Go data structure into plain C format.
func unpackSVideoReferenceSlotInfo(x []VideoReferenceSlotInfo) (unpacked *C.VkVideoReferenceSlotInfoKHR, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocVideoReferenceSlotInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkVideoReferenceSlotInfoKHR)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkVideoReferenceSlotInfoKHR)(h.Data)
	return
}

// packSVideoReferenceSlotInfo reads sliced Go data structure out from plain C format.
func packSVideoReferenceSlotInfo(v []VideoReferenceSlotInfo, ptr0 *C.VkVideoReferenceSlotInfoKHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfVideoReferenceSlotInfoValue]C.VkVideoReferenceSlotInfoKHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewVideoReferenceSlotInfoRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *VideoBeginCodingInfo) Ref() *C.VkVideoBeginCodingInfoKHR {
	if x == nil {
		return nil
	}
	return x.ref6ab3d7b5
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *VideoBeginCodingInfo) Free() {
	if x != nil && x.allocs6ab3d7b5 != nil {
		x.allocs6ab3d7b5.(*cgoAllocMap).Free()
		x.ref6ab3d7b5 = nil
	}
}

// NewVideoBeginCodingInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewVideoBeginCodingInfoRef(ref unsafe.Pointer) *VideoBeginCodingInfo {
	if ref == nil {
		return nil
	}
	obj := new(VideoBeginCodingInfo)
	obj.ref6ab3d7b5 = (*C.VkVideoBeginCodingInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *VideoBeginCodingInfo) PassRef() (*C.VkVideoBeginCodingInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6ab3d7b5 != nil {
		return x.ref6ab3d7b5, nil
	}
	mem6ab3d7b5 := allocVideoBeginCodingInfoMemory(1)
	ref6ab3d7b5 := (*C.VkVideoBeginCodingInfoKHR)(mem6ab3d7b5)
	allocs6ab3d7b5 := new(cgoAllocMap)
	allocs6ab3d7b5.Add(mem6ab3d7b5)

	ref6ab3d7b5.sType = (C.VkStructureType)(x.SType)

	ref6ab3d7b5.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref6ab3d7b5.flags = (C.VkVideoBeginCodingFlagsKHR)(x.Flags)

	ref6ab3d7b5.videoSession = *(*C.VkVideoSessionKHR)(unsafe.Pointer(&x.VideoSession))

	ref6ab3d7b5.videoSessionParameters = *(*C.VkVideoSessionParametersKHR)(unsafe.Pointer(&x.VideoSessionParameters))

	ref6ab3d7b5.referenceSlotCount = (C.uint32_t)(x.ReferenceSlotCount)

	var cpReferenceSlots_allocs *cgoAllocMap
	ref6ab3d7b5.pReferenceSlots, cpReferenceSlots_allocs = unpackSVideoReferenceSlotInfo(x.PReferenceSlots)
	allocs6ab3d7b5.Borrow(cpReferenceSlots_allocs)

	x.ref6ab3d7b5 = ref6ab3d7b5
	x.allocs6ab3d7b5 = allocs6ab3d7b5
	return ref6ab3d7b5, allocs6ab3d7b5

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x VideoBeginCodingInfo) PassValue() (C.VkVideoBeginCodingInfoKHR, *cgoAllocMap) {
	if x.ref6ab3d7b5 != nil {
		return *x.ref6ab3d7b5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *VideoBeginCodingInfo) Deref() {
	if x.ref6ab3d7b5 == nil {
		return
	}
	x.SType = (StructureType)(x.ref6ab3d7b5.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref6ab3d7b5.pNext))
	x.Flags = (VideoBeginCodingFlags)(x.ref6ab3d7b5.flags)
	x.VideoSession = *(*VideoSession)(unsafe.Pointer(&x.ref6ab3d7b5.videoSession))
	x.VideoSessionParameters = *(*VideoSessionParameters)(unsafe.Pointer(&x.ref6ab3d7b5.videoSessionParameters))
	x.ReferenceSlotCount = (uint32)(x.ref6ab3d7b5.referenceSlotCount)
	packSVideoReferenceSlotInfo(x.PReferenceSlots, x.ref6ab3d7b5.pReferenceSlots)
}

// allocVideoDecodeInfoMemory allocates memory for type C.VkVideoDecodeInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVideoDecodeInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVideoDecodeInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfVideoDecodeInfoValue = unsafe.Sizeof([1]C.VkVideoDecodeInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *VideoDecodeInfo) Ref() *C.VkVideoDecodeInfoKHR {
	if x == nil {
		return nil
	}
	return x.refbbf9d3b8
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *VideoDecodeInfo) Free() {
	if x != nil && x.allocsbbf9d3b8 != nil {
		x.allocsbbf9d3b8.(*cgoAllocMap).Free()
		x.refbbf9d3b8 = nil
	}
}

// NewVideoDecodeInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewVideoDecodeInfoRef(ref unsafe.Pointer) *VideoDecodeInfo {
	if ref == nil {
		return nil
	}
	obj := new(VideoDecodeInfo)
	obj.refbbf9d3b8 = (*C.VkVideoDecodeInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *VideoDecodeInfo) PassRef() (*C.VkVideoDecodeInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refbbf9d3b8 != nil {
		return x.refbbf9d3b8, nil
	}
	membbf9d3b8 := allocVideoDecodeInfoMemory(1)
	refbbf9d3b8 := (*C.VkVideoDecodeInfoKHR)(membbf9d3b8)
	allocsbbf9d3b8 := new(cgoAllocMap)
	allocsbbf9d3b8.Add(membbf9d3b8)

	refbbf9d3b8.sType = (C.VkStructureType)(x.SType)

	refbbf9d3b8.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	refbbf9d3b8.flags = (C.VkVideoDecodeFlagsKHR)(x.Flags)

	refbbf9d3b8.srcBuffer = *(*C.VkBuffer)(unsafe.Pointer(&x.SrcBuffer))

	refbbf9d3b8.srcBufferOffset = (C.VkDeviceSize)(x.SrcBufferOffset)

	refbbf9d3b8.srcBufferRange = (C.VkDeviceSize)(x.SrcBufferRange)

	var cdstPictureResource_allocs *cgoAllocMap
	refbbf9d3b8.dstPictureResource, cdstPictureResource_allocs = x.DstPictureResource.PassValue()
	allocsbbf9d3b8.Borrow(cdstPictureResource_allocs)

	var cpSetupReferenceSlot_allocs *cgoAllocMap
	refbbf9d3b8.pSetupReferenceSlot, cpSetupReferenceSlot_allocs = unpackSVideoReferenceSlotInfo(x.PSetupReferenceSlot)
	allocsbbf9d3b8.Borrow(cpSetupReferenceSlot_allocs)

	refbbf9d3b8.referenceSlotCount = (C.uint32_t)(x.ReferenceSlotCount)

	var cpReferenceSlots_allocs *cgoAllocMap
	refbbf9d3b8.pReferenceSlots, cpReferenceSlots_allocs = unpackSVideoReferenceSlotInfo(x.PReferenceSlots)
	allocsbbf9d3b8.Borrow(cpReferenceSlots_allocs)

	x.refbbf9d3b8 = refbbf9d3b8
	x.allocsbbf9d3b8 = allocsbbf9d3b8
	return refbbf9d3b8, allocsbbf9d3b8

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x VideoDecodeInfo) PassValue() (C.VkVideoDecodeInfoKHR, *cgoAllocMap) {
	if x.refbbf9d3b8 != nil {
		return *x.refbbf9d3b8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *VideoDecodeInfo) Deref() {
	if x.refbbf9d3b8 == nil {
		return
	}
	x.SType = (StructureType)(x.refbbf9d3b8.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refbbf9d3b8.pNext))
	x.Flags = (VideoDecodeFlags)(x.refbbf9d3b8.flags)
	x.SrcBuffer = *(*Buffer)(unsafe.Pointer(&x.refbbf9d3b8.srcBuffer))
	x.SrcBufferOffset = (DeviceSize)(x.refbbf9d3b8.srcBufferOffset)
	x.SrcBufferRange = (DeviceSize)(x.refbbf9d3b8.srcBufferRange)
	x.DstPictureResource = *NewVideoPictureResourceInfoRef(unsafe.Pointer(&x.refbbf9d3b8.dstPictureResource))
	packSVideoReferenceSlotInfo(x.PSetupReferenceSlot, x.refbbf9d3b8.pSetupReferenceSlot)
	x.ReferenceSlotCount = (uint32)(x.refbbf9d3b8.referenceSlotCount)
	packSVideoReferenceSlotInfo(x.PReferenceSlots, x.refbbf9d3b8.pReferenceSlots)
}

// allocRenderingFragmentShadingRateAttachmentInfoMemory allocates memory for type C.VkRenderingFragmentShadingRateAttachmentInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRenderingFragmentShadingRateAttachmentInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRenderingFragmentShadingRateAttachmentInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfRenderingFragmentShadingRateAttachmentInfoValue = unsafe.Sizeof([1]C.VkRenderingFragmentShadingRateAttachmentInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RenderingFragmentShadingRateAttachmentInfo) Ref() *C.VkRenderingFragmentShadingRateAttachmentInfoKHR {
	if x == nil {
		return nil
	}
	return x.ref4d98d68f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RenderingFragmentShadingRateAttachmentInfo) Free() {
	if x != nil && x.allocs4d98d68f != nil {
		x.allocs4d98d68f.(*cgoAllocMap).Free()
		x.ref4d98d68f = nil
	}
}

// NewRenderingFragmentShadingRateAttachmentInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRenderingFragmentShadingRateAttachmentInfoRef(ref unsafe.Pointer) *RenderingFragmentShadingRateAttachmentInfo {
	if ref == nil {
		return nil
	}
	obj := new(RenderingFragmentShadingRateAttachmentInfo)
	obj.ref4d98d68f = (*C.VkRenderingFragmentShadingRateAttachmentInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RenderingFragmentShadingRateAttachmentInfo) PassRef() (*C.VkRenderingFragmentShadingRateAttachmentInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4d98d68f != nil {
		return x.ref4d98d68f, nil
	}
	mem4d98d68f := allocRenderingFragmentShadingRateAttachmentInfoMemory(1)
	ref4d98d68f := (*C.VkRenderingFragmentShadingRateAttachmentInfoKHR)(mem4d98d68f)
	allocs4d98d68f := new(cgoAllocMap)
	allocs4d98d68f.Add(mem4d98d68f)

	ref4d98d68f.sType = (C.VkStructureType)(x.SType)

	ref4d98d68f.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref4d98d68f.imageView = *(*C.VkImageView)(unsafe.Pointer(&x.ImageView))

	ref4d98d68f.imageLayout = (C.VkImageLayout)(x.ImageLayout)

	ref4d98d68f.shadingRateAttachmentTexelSize = *(*C.VkExtent2D)(unsafe.Pointer(&x.ShadingRateAttachmentTexelSize))

	x.ref4d98d68f = ref4d98d68f
	x.allocs4d98d68f = allocs4d98d68f
	return ref4d98d68f, allocs4d98d68f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RenderingFragmentShadingRateAttachmentInfo) PassValue() (C.VkRenderingFragmentShadingRateAttachmentInfoKHR, *cgoAllocMap) {
	if x.ref4d98d68f != nil {
		return *x.ref4d98d68f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *RenderingFragmentShadingRateAttachmentInfo) Deref() {
	if x.ref4d98d68f == nil {
		return
	}
	x.SType = (StructureType)(x.ref4d98d68f.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref4d98d68f.pNext))
	x.ImageView = *(*ImageView)(unsafe.Pointer(&x.ref4d98d68f.imageView))
	x.ImageLayout = (ImageLayout)(x.ref4d98d68f.imageLayout)
	x.ShadingRateAttachmentTexelSize = *(*Extent2D)(unsafe.Pointer(&x.ref4d98d68f.shadingRateAttachmentTexelSize))
}

// allocRenderingFragmentDensityMapAttachmentInfoMemory allocates memory for type C.VkRenderingFragmentDensityMapAttachmentInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRenderingFragmentDensityMapAttachmentInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRenderingFragmentDensityMapAttachmentInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfRenderingFragmentDensityMapAttachmentInfoValue = unsafe.Sizeof([1]C.VkRenderingFragmentDensityMapAttachmentInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RenderingFragmentDensityMapAttachmentInfo) Ref() *C.VkRenderingFragmentDensityMapAttachmentInfoEXT {
	if x == nil {
		return nil
	}
	return x.ref5a007d48
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RenderingFragmentDensityMapAttachmentInfo) Free() {
	if x != nil && x.allocs5a007d48 != nil {
		x.allocs5a007d48.(*cgoAllocMap).Free()
		x.ref5a007d48 = nil
	}
}

// NewRenderingFragmentDensityMapAttachmentInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRenderingFragmentDensityMapAttachmentInfoRef(ref unsafe.Pointer) *RenderingFragmentDensityMapAttachmentInfo {
	if ref == nil {
		return nil
	}
	obj := new(RenderingFragmentDensityMapAttachmentInfo)
	obj.ref5a007d48 = (*C.VkRenderingFragmentDensityMapAttachmentInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RenderingFragmentDensityMapAttachmentInfo) PassRef() (*C.VkRenderingFragmentDensityMapAttachmentInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5a007d48 != nil {
		return x.ref5a007d48, nil
	}
	mem5a007d48 := allocRenderingFragmentDensityMapAttachmentInfoMemory(1)
	ref5a007d48 := (*C.VkRenderingFragmentDensityMapAttachmentInfoEXT)(mem5a007d48)
	allocs5a007d48 := new(cgoAllocMap)
	allocs5a007d48.Add(mem5a007d48)

	ref5a007d48.sType = (C.VkStructureType)(x.SType)

	ref5a007d48.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref5a007d48.imageView = *(*C.VkImageView)(unsafe.Pointer(&x.ImageView))

	ref5a007d48.imageLayout = (C.VkImageLayout)(x.ImageLayout)

	x.ref5a007d48 = ref5a007d48
	x.allocs5a007d48 = allocs5a007d48
	return ref5a007d48, allocs5a007d48

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RenderingFragmentDensityMapAttachmentInfo) PassValue() (C.VkRenderingFragmentDensityMapAttachmentInfoEXT, *cgoAllocMap) {
	if x.ref5a007d48 != nil {
		return *x.ref5a007d48, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *RenderingFragmentDensityMapAttachmentInfo) Deref() {
	if x.ref5a007d48 == nil {
		return
	}
	x.SType = (StructureType)(x.ref5a007d48.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref5a007d48.pNext))
	x.ImageView = *(*ImageView)(unsafe.Pointer(&x.ref5a007d48.imageView))
	x.ImageLayout = (ImageLayout)(x.ref5a007d48.imageLayout)
}

// allocAttachmentSampleCountInfoAMDMemory allocates memory for type C.VkAttachmentSampleCountInfoAMD in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAttachmentSampleCountInfoAMDMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAttachmentSampleCountInfoAMDValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfAttachmentSampleCountInfoAMDValue = unsafe.Sizeof([1]C.VkAttachmentSampleCountInfoAMD{})

// copyPSampleCountFlagBitsBytes copies the data from Go slice as *C.VkSampleCountFlagBits.
func copyPSampleCountFlagBitsBytes(slice *sliceHeader) (*C.VkSampleCountFlagBits, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfSampleCountFlagBitsValue) * slice.Len,
		Cap:  int(sizeOfSampleCountFlagBitsValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkSampleCountFlagBits)(mem0), allocs
}

// allocSampleCountFlagBitsMemory allocates memory for type C.VkSampleCountFlagBits in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSampleCountFlagBitsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSampleCountFlagBitsValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSampleCountFlagBitsValue = unsafe.Sizeof([1]C.VkSampleCountFlagBits{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *AttachmentSampleCountInfoAMD) Ref() *C.VkAttachmentSampleCountInfoAMD {
	if x == nil {
		return nil
	}
	return x.refeef56262
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *AttachmentSampleCountInfoAMD) Free() {
	if x != nil && x.allocseef56262 != nil {
		x.allocseef56262.(*cgoAllocMap).Free()
		x.refeef56262 = nil
	}
}

// NewAttachmentSampleCountInfoAMDRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewAttachmentSampleCountInfoAMDRef(ref unsafe.Pointer) *AttachmentSampleCountInfoAMD {
	if ref == nil {
		return nil
	}
	obj := new(AttachmentSampleCountInfoAMD)
	obj.refeef56262 = (*C.VkAttachmentSampleCountInfoAMD)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *AttachmentSampleCountInfoAMD) PassRef() (*C.VkAttachmentSampleCountInfoAMD, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refeef56262 != nil {
		return x.refeef56262, nil
	}
	memeef56262 := allocAttachmentSampleCountInfoAMDMemory(1)
	refeef56262 := (*C.VkAttachmentSampleCountInfoAMD)(memeef56262)
	allocseef56262 := new(cgoAllocMap)
	allocseef56262.Add(memeef56262)

	refeef56262.sType = (C.VkStructureType)(x.SType)

	refeef56262.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	refeef56262.colorAttachmentCount = (C.uint32_t)(x.ColorAttachmentCount)

	if x.PColorAttachmentSamples != nil {
		var cpColorAttachmentSamples_allocs *cgoAllocMap
		refeef56262.pColorAttachmentSamples, cpColorAttachmentSamples_allocs = copyPSampleCountFlagBitsBytes((*sliceHeader)(unsafe.Pointer(&x.PColorAttachmentSamples)))
		allocseef56262.Borrow(cpColorAttachmentSamples_allocs)
	}

	refeef56262.depthStencilAttachmentSamples = (C.VkSampleCountFlagBits)(x.DepthStencilAttachmentSamples)

	x.refeef56262 = refeef56262
	x.allocseef56262 = allocseef56262
	return refeef56262, allocseef56262

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x AttachmentSampleCountInfoAMD) PassValue() (C.VkAttachmentSampleCountInfoAMD, *cgoAllocMap) {
	if x.refeef56262 != nil {
		return *x.refeef56262, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *AttachmentSampleCountInfoAMD) Deref() {
	if x.refeef56262 == nil {
		return
	}
	x.SType = (StructureType)(x.refeef56262.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refeef56262.pNext))
	x.ColorAttachmentCount = (uint32)(x.refeef56262.colorAttachmentCount)
	hxfe3c193 := (*sliceHeader)(unsafe.Pointer(&x.PColorAttachmentSamples))
	hxfe3c193.Data = unsafe.Pointer(x.refeef56262.pColorAttachmentSamples)
	hxfe3c193.Cap = 0x7fffffff
	// hxfe3c193.Len = ? x.PColorAttachmentSamples x.refeef56262.pColorAttachmentSamples

	x.DepthStencilAttachmentSamples = (SampleCountFlagBits)(x.refeef56262.depthStencilAttachmentSamples)
}

// allocAttachmentSampleCountInfoNVMemory allocates memory for type C.VkAttachmentSampleCountInfoNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAttachmentSampleCountInfoNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAttachmentSampleCountInfoNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfAttachmentSampleCountInfoNVValue = unsafe.Sizeof([1]C.VkAttachmentSampleCountInfoNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *AttachmentSampleCountInfoNV) Ref() *C.VkAttachmentSampleCountInfoNV {
	if x == nil {
		return nil
	}
	return x.reff994eb43
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *AttachmentSampleCountInfoNV) Free() {
	if x != nil && x.allocsf994eb43 != nil {
		x.allocsf994eb43.(*cgoAllocMap).Free()
		x.reff994eb43 = nil
	}
}

// NewAttachmentSampleCountInfoNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewAttachmentSampleCountInfoNVRef(ref unsafe.Pointer) *AttachmentSampleCountInfoNV {
	if ref == nil {
		return nil
	}
	obj := new(AttachmentSampleCountInfoNV)
	obj.reff994eb43 = (*C.VkAttachmentSampleCountInfoNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *AttachmentSampleCountInfoNV) PassRef() (*C.VkAttachmentSampleCountInfoNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff994eb43 != nil {
		return x.reff994eb43, nil
	}
	memf994eb43 := allocAttachmentSampleCountInfoNVMemory(1)
	reff994eb43 := (*C.VkAttachmentSampleCountInfoNV)(memf994eb43)
	allocsf994eb43 := new(cgoAllocMap)
	allocsf994eb43.Add(memf994eb43)

	reff994eb43.sType = (C.VkStructureType)(x.SType)

	reff994eb43.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	reff994eb43.colorAttachmentCount = (C.uint32_t)(x.ColorAttachmentCount)

	if x.PColorAttachmentSamples != nil {
		var cpColorAttachmentSamples_allocs *cgoAllocMap
		reff994eb43.pColorAttachmentSamples, cpColorAttachmentSamples_allocs = copyPSampleCountFlagBitsBytes((*sliceHeader)(unsafe.Pointer(&x.PColorAttachmentSamples)))
		allocsf994eb43.Borrow(cpColorAttachmentSamples_allocs)
	}

	reff994eb43.depthStencilAttachmentSamples = (C.VkSampleCountFlagBits)(x.DepthStencilAttachmentSamples)

	x.reff994eb43 = reff994eb43
	x.allocsf994eb43 = allocsf994eb43
	return reff994eb43, allocsf994eb43

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x AttachmentSampleCountInfoNV) PassValue() (C.VkAttachmentSampleCountInfoNV, *cgoAllocMap) {
	if x.reff994eb43 != nil {
		return *x.reff994eb43, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *AttachmentSampleCountInfoNV) Deref() {
	if x.reff994eb43 == nil {
		return
	}
	x.SType = (StructureType)(x.reff994eb43.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.reff994eb43.pNext))
	x.ColorAttachmentCount = (uint32)(x.reff994eb43.colorAttachmentCount)
	hxfe8267c := (*sliceHeader)(unsafe.Pointer(&x.PColorAttachmentSamples))
	hxfe8267c.Data = unsafe.Pointer(x.reff994eb43.pColorAttachmentSamples)
	hxfe8267c.Cap = 0x7fffffff
	// hxfe8267c.Len = ? x.PColorAttachmentSamples x.reff994eb43.pColorAttachmentSamples

	x.DepthStencilAttachmentSamples = (SampleCountFlagBits)(x.reff994eb43.depthStencilAttachmentSamples)
}

// allocMemoryGetFdInfoMemory allocates memory for type C.VkMemoryGetFdInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMemoryGetFdInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMemoryGetFdInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfMemoryGetFdInfoValue = unsafe.Sizeof([1]C.VkMemoryGetFdInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *MemoryGetFdInfo) Ref() *C.VkMemoryGetFdInfoKHR {
	if x == nil {
		return nil
	}
	return x.ref75a079b1
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *MemoryGetFdInfo) Free() {
	if x != nil && x.allocs75a079b1 != nil {
		x.allocs75a079b1.(*cgoAllocMap).Free()
		x.ref75a079b1 = nil
	}
}

// NewMemoryGetFdInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMemoryGetFdInfoRef(ref unsafe.Pointer) *MemoryGetFdInfo {
	if ref == nil {
		return nil
	}
	obj := new(MemoryGetFdInfo)
	obj.ref75a079b1 = (*C.VkMemoryGetFdInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *MemoryGetFdInfo) PassRef() (*C.VkMemoryGetFdInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref75a079b1 != nil {
		return x.ref75a079b1, nil
	}
	mem75a079b1 := allocMemoryGetFdInfoMemory(1)
	ref75a079b1 := (*C.VkMemoryGetFdInfoKHR)(mem75a079b1)
	allocs75a079b1 := new(cgoAllocMap)
	allocs75a079b1.Add(mem75a079b1)

	ref75a079b1.sType = (C.VkStructureType)(x.SType)

	ref75a079b1.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref75a079b1.memory = *(*C.VkDeviceMemory)(unsafe.Pointer(&x.Memory))

	ref75a079b1.handleType = (C.VkExternalMemoryHandleTypeFlagBits)(x.HandleType)

	x.ref75a079b1 = ref75a079b1
	x.allocs75a079b1 = allocs75a079b1
	return ref75a079b1, allocs75a079b1

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x MemoryGetFdInfo) PassValue() (C.VkMemoryGetFdInfoKHR, *cgoAllocMap) {
	if x.ref75a079b1 != nil {
		return *x.ref75a079b1, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *MemoryGetFdInfo) Deref() {
	if x.ref75a079b1 == nil {
		return
	}
	x.SType = (StructureType)(x.ref75a079b1.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref75a079b1.pNext))
	x.Memory = *(*DeviceMemory)(unsafe.Pointer(&x.ref75a079b1.memory))
	x.HandleType = (ExternalMemoryHandleTypeFlagBits)(x.ref75a079b1.handleType)
}

// allocImportSemaphoreFdInfoMemory allocates memory for type C.VkImportSemaphoreFdInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImportSemaphoreFdInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImportSemaphoreFdInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfImportSemaphoreFdInfoValue = unsafe.Sizeof([1]C.VkImportSemaphoreFdInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImportSemaphoreFdInfo) Ref() *C.VkImportSemaphoreFdInfoKHR {
	if x == nil {
		return nil
	}
	return x.refbc2f829a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImportSemaphoreFdInfo) Free() {
	if x != nil && x.allocsbc2f829a != nil {
		x.allocsbc2f829a.(*cgoAllocMap).Free()
		x.refbc2f829a = nil
	}
}

// NewImportSemaphoreFdInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImportSemaphoreFdInfoRef(ref unsafe.Pointer) *ImportSemaphoreFdInfo {
	if ref == nil {
		return nil
	}
	obj := new(ImportSemaphoreFdInfo)
	obj.refbc2f829a = (*C.VkImportSemaphoreFdInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImportSemaphoreFdInfo) PassRef() (*C.VkImportSemaphoreFdInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refbc2f829a != nil {
		return x.refbc2f829a, nil
	}
	membc2f829a := allocImportSemaphoreFdInfoMemory(1)
	refbc2f829a := (*C.VkImportSemaphoreFdInfoKHR)(membc2f829a)
	allocsbc2f829a := new(cgoAllocMap)
	allocsbc2f829a.Add(membc2f829a)

	refbc2f829a.sType = (C.VkStructureType)(x.SType)

	refbc2f829a.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	refbc2f829a.semaphore = *(*C.VkSemaphore)(unsafe.Pointer(&x.Semaphore))

	refbc2f829a.flags = (C.VkSemaphoreImportFlags)(x.Flags)

	refbc2f829a.handleType = (C.VkExternalSemaphoreHandleTypeFlagBits)(x.HandleType)

	refbc2f829a.fd = (C.int)(x.Fd)

	x.refbc2f829a = refbc2f829a
	x.allocsbc2f829a = allocsbc2f829a
	return refbc2f829a, allocsbc2f829a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImportSemaphoreFdInfo) PassValue() (C.VkImportSemaphoreFdInfoKHR, *cgoAllocMap) {
	if x.refbc2f829a != nil {
		return *x.refbc2f829a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImportSemaphoreFdInfo) Deref() {
	if x.refbc2f829a == nil {
		return
	}
	x.SType = (StructureType)(x.refbc2f829a.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refbc2f829a.pNext))
	x.Semaphore = *(*Semaphore)(unsafe.Pointer(&x.refbc2f829a.semaphore))
	x.Flags = (SemaphoreImportFlags)(x.refbc2f829a.flags)
	x.HandleType = (ExternalSemaphoreHandleTypeFlagBits)(x.refbc2f829a.handleType)
	x.Fd = (int32)(x.refbc2f829a.fd)
}

// allocSemaphoreGetFdInfoMemory allocates memory for type C.VkSemaphoreGetFdInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSemaphoreGetFdInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSemaphoreGetFdInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSemaphoreGetFdInfoValue = unsafe.Sizeof([1]C.VkSemaphoreGetFdInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SemaphoreGetFdInfo) Ref() *C.VkSemaphoreGetFdInfoKHR {
	if x == nil {
		return nil
	}
	return x.refd9bd07cf
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SemaphoreGetFdInfo) Free() {
	if x != nil && x.allocsd9bd07cf != nil {
		x.allocsd9bd07cf.(*cgoAllocMap).Free()
		x.refd9bd07cf = nil
	}
}

// NewSemaphoreGetFdInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSemaphoreGetFdInfoRef(ref unsafe.Pointer) *SemaphoreGetFdInfo {
	if ref == nil {
		return nil
	}
	obj := new(SemaphoreGetFdInfo)
	obj.refd9bd07cf = (*C.VkSemaphoreGetFdInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SemaphoreGetFdInfo) PassRef() (*C.VkSemaphoreGetFdInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd9bd07cf != nil {
		return x.refd9bd07cf, nil
	}
	memd9bd07cf := allocSemaphoreGetFdInfoMemory(1)
	refd9bd07cf := (*C.VkSemaphoreGetFdInfoKHR)(memd9bd07cf)
	allocsd9bd07cf := new(cgoAllocMap)
	allocsd9bd07cf.Add(memd9bd07cf)

	refd9bd07cf.sType = (C.VkStructureType)(x.SType)

	refd9bd07cf.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	refd9bd07cf.semaphore = *(*C.VkSemaphore)(unsafe.Pointer(&x.Semaphore))

	refd9bd07cf.handleType = (C.VkExternalSemaphoreHandleTypeFlagBits)(x.HandleType)

	x.refd9bd07cf = refd9bd07cf
	x.allocsd9bd07cf = allocsd9bd07cf
	return refd9bd07cf, allocsd9bd07cf

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SemaphoreGetFdInfo) PassValue() (C.VkSemaphoreGetFdInfoKHR, *cgoAllocMap) {
	if x.refd9bd07cf != nil {
		return *x.refd9bd07cf, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SemaphoreGetFdInfo) Deref() {
	if x.refd9bd07cf == nil {
		return
	}
	x.SType = (StructureType)(x.refd9bd07cf.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refd9bd07cf.pNext))
	x.Semaphore = *(*Semaphore)(unsafe.Pointer(&x.refd9bd07cf.semaphore))
	x.HandleType = (ExternalSemaphoreHandleTypeFlagBits)(x.refd9bd07cf.handleType)
}

// allocPresentRegionMemory allocates memory for type C.VkPresentRegionKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPresentRegionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPresentRegionValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPresentRegionValue = unsafe.Sizeof([1]C.VkPresentRegionKHR{})

// copyPRectLayerBytes copies the data from Go slice as *C.VkRectLayerKHR.
func copyPRectLayerBytes(slice *sliceHeader) (*C.VkRectLayerKHR, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfRectLayerValue) * slice.Len,
		Cap:  int(sizeOfRectLayerValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkRectLayerKHR)(mem0), allocs
}

// allocRectLayerMemory allocates memory for type C.VkRectLayerKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRectLayerMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRectLayerValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfRectLayerValue = unsafe.Sizeof([1]C.VkRectLayerKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PresentRegion) Ref() *C.VkPresentRegionKHR {
	if x == nil {
		return nil
	}
	return x.refbbc0d1b9
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PresentRegion) Free() {
	if x != nil && x.allocsbbc0d1b9 != nil {
		x.allocsbbc0d1b9.(*cgoAllocMap).Free()
		x.refbbc0d1b9 = nil
	}
}

// NewPresentRegionRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPresentRegionRef(ref unsafe.Pointer) *PresentRegion {
	if ref == nil {
		return nil
	}
	obj := new(PresentRegion)
	obj.refbbc0d1b9 = (*C.VkPresentRegionKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PresentRegion) PassRef() (*C.VkPresentRegionKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refbbc0d1b9 != nil {
		return x.refbbc0d1b9, nil
	}
	membbc0d1b9 := allocPresentRegionMemory(1)
	refbbc0d1b9 := (*C.VkPresentRegionKHR)(membbc0d1b9)
	allocsbbc0d1b9 := new(cgoAllocMap)
	allocsbbc0d1b9.Add(membbc0d1b9)

	refbbc0d1b9.rectangleCount = (C.uint32_t)(x.RectangleCount)

	if x.PRectangles != nil {
		var cpRectangles_allocs *cgoAllocMap
		refbbc0d1b9.pRectangles, cpRectangles_allocs = copyPRectLayerBytes((*sliceHeader)(unsafe.Pointer(&x.PRectangles)))
		allocsbbc0d1b9.Borrow(cpRectangles_allocs)
	}

	x.refbbc0d1b9 = refbbc0d1b9
	x.allocsbbc0d1b9 = allocsbbc0d1b9
	return refbbc0d1b9, allocsbbc0d1b9

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PresentRegion) PassValue() (C.VkPresentRegionKHR, *cgoAllocMap) {
	if x.refbbc0d1b9 != nil {
		return *x.refbbc0d1b9, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PresentRegion) Deref() {
	if x.refbbc0d1b9 == nil {
		return
	}
	x.RectangleCount = (uint32)(x.refbbc0d1b9.rectangleCount)
	hxf9143ee := (*sliceHeader)(unsafe.Pointer(&x.PRectangles))
	hxf9143ee.Data = unsafe.Pointer(x.refbbc0d1b9.pRectangles)
	hxf9143ee.Cap = 0x7fffffff
	// hxf9143ee.Len = ? x.PRectangles x.refbbc0d1b9.pRectangles

}

// allocPresentRegionsMemory allocates memory for type C.VkPresentRegionsKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPresentRegionsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPresentRegionsValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPresentRegionsValue = unsafe.Sizeof([1]C.VkPresentRegionsKHR{})

// unpackSPresentRegion transforms a sliced Go data structure into plain C format.
func unpackSPresentRegion(x []PresentRegion) (unpacked *C.VkPresentRegionKHR, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPresentRegionMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkPresentRegionKHR)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkPresentRegionKHR)(h.Data)
	return
}

// packSPresentRegion reads sliced Go data structure out from plain C format.
func packSPresentRegion(v []PresentRegion, ptr0 *C.VkPresentRegionKHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPresentRegionValue]C.VkPresentRegionKHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPresentRegionRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PresentRegions) Ref() *C.VkPresentRegionsKHR {
	if x == nil {
		return nil
	}
	return x.ref62958060
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PresentRegions) Free() {
	if x != nil && x.allocs62958060 != nil {
		x.allocs62958060.(*cgoAllocMap).Free()
		x.ref62958060 = nil
	}
}

// NewPresentRegionsRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPresentRegionsRef(ref unsafe.Pointer) *PresentRegions {
	if ref == nil {
		return nil
	}
	obj := new(PresentRegions)
	obj.ref62958060 = (*C.VkPresentRegionsKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PresentRegions) PassRef() (*C.VkPresentRegionsKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref62958060 != nil {
		return x.ref62958060, nil
	}
	mem62958060 := allocPresentRegionsMemory(1)
	ref62958060 := (*C.VkPresentRegionsKHR)(mem62958060)
	allocs62958060 := new(cgoAllocMap)
	allocs62958060.Add(mem62958060)

	ref62958060.sType = (C.VkStructureType)(x.SType)

	ref62958060.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref62958060.swapchainCount = (C.uint32_t)(x.SwapchainCount)

	var cpRegions_allocs *cgoAllocMap
	ref62958060.pRegions, cpRegions_allocs = unpackSPresentRegion(x.PRegions)
	allocs62958060.Borrow(cpRegions_allocs)

	x.ref62958060 = ref62958060
	x.allocs62958060 = allocs62958060
	return ref62958060, allocs62958060

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PresentRegions) PassValue() (C.VkPresentRegionsKHR, *cgoAllocMap) {
	if x.ref62958060 != nil {
		return *x.ref62958060, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PresentRegions) Deref() {
	if x.ref62958060 == nil {
		return
	}
	x.SType = (StructureType)(x.ref62958060.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref62958060.pNext))
	x.SwapchainCount = (uint32)(x.ref62958060.swapchainCount)
	packSPresentRegion(x.PRegions, x.ref62958060.pRegions)
}

// allocImportFenceFdInfoMemory allocates memory for type C.VkImportFenceFdInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImportFenceFdInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImportFenceFdInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfImportFenceFdInfoValue = unsafe.Sizeof([1]C.VkImportFenceFdInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImportFenceFdInfo) Ref() *C.VkImportFenceFdInfoKHR {
	if x == nil {
		return nil
	}
	return x.ref86ebd28c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImportFenceFdInfo) Free() {
	if x != nil && x.allocs86ebd28c != nil {
		x.allocs86ebd28c.(*cgoAllocMap).Free()
		x.ref86ebd28c = nil
	}
}

// NewImportFenceFdInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImportFenceFdInfoRef(ref unsafe.Pointer) *ImportFenceFdInfo {
	if ref == nil {
		return nil
	}
	obj := new(ImportFenceFdInfo)
	obj.ref86ebd28c = (*C.VkImportFenceFdInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImportFenceFdInfo) PassRef() (*C.VkImportFenceFdInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref86ebd28c != nil {
		return x.ref86ebd28c, nil
	}
	mem86ebd28c := allocImportFenceFdInfoMemory(1)
	ref86ebd28c := (*C.VkImportFenceFdInfoKHR)(mem86ebd28c)
	allocs86ebd28c := new(cgoAllocMap)
	allocs86ebd28c.Add(mem86ebd28c)

	ref86ebd28c.sType = (C.VkStructureType)(x.SType)

	ref86ebd28c.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref86ebd28c.fence = *(*C.VkFence)(unsafe.Pointer(&x.Fence))

	ref86ebd28c.flags = (C.VkFenceImportFlags)(x.Flags)

	ref86ebd28c.handleType = (C.VkExternalFenceHandleTypeFlagBits)(x.HandleType)

	ref86ebd28c.fd = (C.int)(x.Fd)

	x.ref86ebd28c = ref86ebd28c
	x.allocs86ebd28c = allocs86ebd28c
	return ref86ebd28c, allocs86ebd28c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImportFenceFdInfo) PassValue() (C.VkImportFenceFdInfoKHR, *cgoAllocMap) {
	if x.ref86ebd28c != nil {
		return *x.ref86ebd28c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImportFenceFdInfo) Deref() {
	if x.ref86ebd28c == nil {
		return
	}
	x.SType = (StructureType)(x.ref86ebd28c.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref86ebd28c.pNext))
	x.Fence = *(*Fence)(unsafe.Pointer(&x.ref86ebd28c.fence))
	x.Flags = (FenceImportFlags)(x.ref86ebd28c.flags)
	x.HandleType = (ExternalFenceHandleTypeFlagBits)(x.ref86ebd28c.handleType)
	x.Fd = (int32)(x.ref86ebd28c.fd)
}

// allocFenceGetFdInfoMemory allocates memory for type C.VkFenceGetFdInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFenceGetFdInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFenceGetFdInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFenceGetFdInfoValue = unsafe.Sizeof([1]C.VkFenceGetFdInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FenceGetFdInfo) Ref() *C.VkFenceGetFdInfoKHR {
	if x == nil {
		return nil
	}
	return x.refc2668bc3
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FenceGetFdInfo) Free() {
	if x != nil && x.allocsc2668bc3 != nil {
		x.allocsc2668bc3.(*cgoAllocMap).Free()
		x.refc2668bc3 = nil
	}
}

// NewFenceGetFdInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFenceGetFdInfoRef(ref unsafe.Pointer) *FenceGetFdInfo {
	if ref == nil {
		return nil
	}
	obj := new(FenceGetFdInfo)
	obj.refc2668bc3 = (*C.VkFenceGetFdInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FenceGetFdInfo) PassRef() (*C.VkFenceGetFdInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc2668bc3 != nil {
		return x.refc2668bc3, nil
	}
	memc2668bc3 := allocFenceGetFdInfoMemory(1)
	refc2668bc3 := (*C.VkFenceGetFdInfoKHR)(memc2668bc3)
	allocsc2668bc3 := new(cgoAllocMap)
	allocsc2668bc3.Add(memc2668bc3)

	refc2668bc3.sType = (C.VkStructureType)(x.SType)

	refc2668bc3.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	refc2668bc3.fence = *(*C.VkFence)(unsafe.Pointer(&x.Fence))

	refc2668bc3.handleType = (C.VkExternalFenceHandleTypeFlagBits)(x.HandleType)

	x.refc2668bc3 = refc2668bc3
	x.allocsc2668bc3 = allocsc2668bc3
	return refc2668bc3, allocsc2668bc3

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FenceGetFdInfo) PassValue() (C.VkFenceGetFdInfoKHR, *cgoAllocMap) {
	if x.refc2668bc3 != nil {
		return *x.refc2668bc3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FenceGetFdInfo) Deref() {
	if x.refc2668bc3 == nil {
		return
	}
	x.SType = (StructureType)(x.refc2668bc3.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refc2668bc3.pNext))
	x.Fence = *(*Fence)(unsafe.Pointer(&x.refc2668bc3.fence))
	x.HandleType = (ExternalFenceHandleTypeFlagBits)(x.refc2668bc3.handleType)
}

// allocPerformanceCounterMemory allocates memory for type C.VkPerformanceCounterKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPerformanceCounterMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPerformanceCounterValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPerformanceCounterValue = unsafe.Sizeof([1]C.VkPerformanceCounterKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PerformanceCounter) Ref() *C.VkPerformanceCounterKHR {
	if x == nil {
		return nil
	}
	return x.refc754b4e5
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PerformanceCounter) Free() {
	if x != nil && x.allocsc754b4e5 != nil {
		x.allocsc754b4e5.(*cgoAllocMap).Free()
		x.refc754b4e5 = nil
	}
}

// NewPerformanceCounterRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPerformanceCounterRef(ref unsafe.Pointer) *PerformanceCounter {
	if ref == nil {
		return nil
	}
	obj := new(PerformanceCounter)
	obj.refc754b4e5 = (*C.VkPerformanceCounterKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PerformanceCounter) PassRef() (*C.VkPerformanceCounterKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc754b4e5 != nil {
		return x.refc754b4e5, nil
	}
	memc754b4e5 := allocPerformanceCounterMemory(1)
	refc754b4e5 := (*C.VkPerformanceCounterKHR)(memc754b4e5)
	allocsc754b4e5 := new(cgoAllocMap)
	allocsc754b4e5.Add(memc754b4e5)

	refc754b4e5.sType = (C.VkStructureType)(x.SType)

	refc754b4e5.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	refc754b4e5.unit = (C.VkPerformanceCounterUnitKHR)(x.Unit)

	refc754b4e5.scope = (C.VkPerformanceCounterScopeKHR)(x.Scope)

	refc754b4e5.storage = (C.VkPerformanceCounterStorageKHR)(x.Storage)

	refc754b4e5.uuid = *(*[16]C.uint8_t)(unsafe.Pointer(&x.Uuid))

	x.refc754b4e5 = refc754b4e5
	x.allocsc754b4e5 = allocsc754b4e5
	return refc754b4e5, allocsc754b4e5

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PerformanceCounter) PassValue() (C.VkPerformanceCounterKHR, *cgoAllocMap) {
	if x.refc754b4e5 != nil {
		return *x.refc754b4e5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PerformanceCounter) Deref() {
	if x.refc754b4e5 == nil {
		return
	}
	x.SType = (StructureType)(x.refc754b4e5.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refc754b4e5.pNext))
	x.Unit = (PerformanceCounterUnit)(x.refc754b4e5.unit)
	x.Scope = (PerformanceCounterScope)(x.refc754b4e5.scope)
	x.Storage = (PerformanceCounterStorage)(x.refc754b4e5.storage)
	x.Uuid = *(*[16]byte)(unsafe.Pointer(&x.refc754b4e5.uuid))
}

// allocPerformanceCounterDescriptionMemory allocates memory for type C.VkPerformanceCounterDescriptionKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPerformanceCounterDescriptionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPerformanceCounterDescriptionValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPerformanceCounterDescriptionValue = unsafe.Sizeof([1]C.VkPerformanceCounterDescriptionKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PerformanceCounterDescription) Ref() *C.VkPerformanceCounterDescriptionKHR {
	if x == nil {
		return nil
	}
	return x.ref95209df5
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PerformanceCounterDescription) Free() {
	if x != nil && x.allocs95209df5 != nil {
		x.allocs95209df5.(*cgoAllocMap).Free()
		x.ref95209df5 = nil
	}
}

// NewPerformanceCounterDescriptionRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPerformanceCounterDescriptionRef(ref unsafe.Pointer) *PerformanceCounterDescription {
	if ref == nil {
		return nil
	}
	obj := new(PerformanceCounterDescription)
	obj.ref95209df5 = (*C.VkPerformanceCounterDescriptionKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PerformanceCounterDescription) PassRef() (*C.VkPerformanceCounterDescriptionKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref95209df5 != nil {
		return x.ref95209df5, nil
	}
	mem95209df5 := allocPerformanceCounterDescriptionMemory(1)
	ref95209df5 := (*C.VkPerformanceCounterDescriptionKHR)(mem95209df5)
	allocs95209df5 := new(cgoAllocMap)
	allocs95209df5.Add(mem95209df5)

	ref95209df5.sType = (C.VkStructureType)(x.SType)

	ref95209df5.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref95209df5.flags = (C.VkPerformanceCounterDescriptionFlagsKHR)(x.Flags)

	ref95209df5.name = *(*[256]C.char)(unsafe.Pointer(&x.Name))

	ref95209df5.category = *(*[256]C.char)(unsafe.Pointer(&x.Category))

	ref95209df5.description = *(*[256]C.char)(unsafe.Pointer(&x.Description))

	x.ref95209df5 = ref95209df5
	x.allocs95209df5 = allocs95209df5
	return ref95209df5, allocs95209df5

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PerformanceCounterDescription) PassValue() (C.VkPerformanceCounterDescriptionKHR, *cgoAllocMap) {
	if x.ref95209df5 != nil {
		return *x.ref95209df5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PerformanceCounterDescription) Deref() {
	if x.ref95209df5 == nil {
		return
	}
	x.SType = (StructureType)(x.ref95209df5.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref95209df5.pNext))
	x.Flags = (PerformanceCounterDescriptionFlags)(x.ref95209df5.flags)
	x.Name = *(*[256]byte)(unsafe.Pointer(&x.ref95209df5.name))
	x.Category = *(*[256]byte)(unsafe.Pointer(&x.ref95209df5.category))
	x.Description = *(*[256]byte)(unsafe.Pointer(&x.ref95209df5.description))
}

// allocQueryPoolPerformanceCreateInfoMemory allocates memory for type C.VkQueryPoolPerformanceCreateInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocQueryPoolPerformanceCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfQueryPoolPerformanceCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfQueryPoolPerformanceCreateInfoValue = unsafe.Sizeof([1]C.VkQueryPoolPerformanceCreateInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *QueryPoolPerformanceCreateInfo) Ref() *C.VkQueryPoolPerformanceCreateInfoKHR {
	if x == nil {
		return nil
	}
	return x.ref55afa561
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *QueryPoolPerformanceCreateInfo) Free() {
	if x != nil && x.allocs55afa561 != nil {
		x.allocs55afa561.(*cgoAllocMap).Free()
		x.ref55afa561 = nil
	}
}

// NewQueryPoolPerformanceCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewQueryPoolPerformanceCreateInfoRef(ref unsafe.Pointer) *QueryPoolPerformanceCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(QueryPoolPerformanceCreateInfo)
	obj.ref55afa561 = (*C.VkQueryPoolPerformanceCreateInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *QueryPoolPerformanceCreateInfo) PassRef() (*C.VkQueryPoolPerformanceCreateInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref55afa561 != nil {
		return x.ref55afa561, nil
	}
	mem55afa561 := allocQueryPoolPerformanceCreateInfoMemory(1)
	ref55afa561 := (*C.VkQueryPoolPerformanceCreateInfoKHR)(mem55afa561)
	allocs55afa561 := new(cgoAllocMap)
	allocs55afa561.Add(mem55afa561)

	ref55afa561.sType = (C.VkStructureType)(x.SType)

	ref55afa561.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref55afa561.queueFamilyIndex = (C.uint32_t)(x.QueueFamilyIndex)

	ref55afa561.counterIndexCount = (C.uint32_t)(x.CounterIndexCount)

	if x.PCounterIndices != nil {
		var cpCounterIndices_allocs *cgoAllocMap
		ref55afa561.pCounterIndices, cpCounterIndices_allocs = copyPUint32_tBytes((*sliceHeader)(unsafe.Pointer(&x.PCounterIndices)))
		allocs55afa561.Borrow(cpCounterIndices_allocs)
	}

	x.ref55afa561 = ref55afa561
	x.allocs55afa561 = allocs55afa561
	return ref55afa561, allocs55afa561

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x QueryPoolPerformanceCreateInfo) PassValue() (C.VkQueryPoolPerformanceCreateInfoKHR, *cgoAllocMap) {
	if x.ref55afa561 != nil {
		return *x.ref55afa561, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *QueryPoolPerformanceCreateInfo) Deref() {
	if x.ref55afa561 == nil {
		return
	}
	x.SType = (StructureType)(x.ref55afa561.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref55afa561.pNext))
	x.QueueFamilyIndex = (uint32)(x.ref55afa561.queueFamilyIndex)
	x.CounterIndexCount = (uint32)(x.ref55afa561.counterIndexCount)
	hxf27a8c5 := (*sliceHeader)(unsafe.Pointer(&x.PCounterIndices))
	hxf27a8c5.Data = unsafe.Pointer(x.ref55afa561.pCounterIndices)
	hxf27a8c5.Cap = 0x7fffffff
	// hxf27a8c5.Len = ? x.PCounterIndices x.ref55afa561.pCounterIndices

}

// allocPhysicalDeviceSurfaceInfo2Memory allocates memory for type C.VkPhysicalDeviceSurfaceInfo2KHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceSurfaceInfo2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceSurfaceInfo2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceSurfaceInfo2Value = unsafe.Sizeof([1]C.VkPhysicalDeviceSurfaceInfo2KHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceSurfaceInfo2) Ref() *C.VkPhysicalDeviceSurfaceInfo2KHR {
	if x == nil {
		return nil
	}
	return x.refd22370ae
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceSurfaceInfo2) Free() {
	if x != nil && x.allocsd22370ae != nil {
		x.allocsd22370ae.(*cgoAllocMap).Free()
		x.refd22370ae = nil
	}
}

// NewPhysicalDeviceSurfaceInfo2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceSurfaceInfo2Ref(ref unsafe.Pointer) *PhysicalDeviceSurfaceInfo2 {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceSurfaceInfo2)
	obj.refd22370ae = (*C.VkPhysicalDeviceSurfaceInfo2KHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceSurfaceInfo2) PassRef() (*C.VkPhysicalDeviceSurfaceInfo2KHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd22370ae != nil {
		return x.refd22370ae, nil
	}
	memd22370ae := allocPhysicalDeviceSurfaceInfo2Memory(1)
	refd22370ae := (*C.VkPhysicalDeviceSurfaceInfo2KHR)(memd22370ae)
	allocsd22370ae := new(cgoAllocMap)
	allocsd22370ae.Add(memd22370ae)

	refd22370ae.sType = (C.VkStructureType)(x.SType)

	refd22370ae.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	refd22370ae.surface = *(*C.VkSurfaceKHR)(unsafe.Pointer(&x.Surface))

	x.refd22370ae = refd22370ae
	x.allocsd22370ae = allocsd22370ae
	return refd22370ae, allocsd22370ae

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceSurfaceInfo2) PassValue() (C.VkPhysicalDeviceSurfaceInfo2KHR, *cgoAllocMap) {
	if x.refd22370ae != nil {
		return *x.refd22370ae, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceSurfaceInfo2) Deref() {
	if x.refd22370ae == nil {
		return
	}
	x.SType = (StructureType)(x.refd22370ae.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refd22370ae.pNext))
	x.Surface = *(*Surface)(unsafe.Pointer(&x.refd22370ae.surface))
}

// allocDisplayProperties2Memory allocates memory for type C.VkDisplayProperties2KHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDisplayProperties2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDisplayProperties2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDisplayProperties2Value = unsafe.Sizeof([1]C.VkDisplayProperties2KHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DisplayProperties2) Ref() *C.VkDisplayProperties2KHR {
	if x == nil {
		return nil
	}
	return x.ref80194833
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DisplayProperties2) Free() {
	if x != nil && x.allocs80194833 != nil {
		x.allocs80194833.(*cgoAllocMap).Free()
		x.ref80194833 = nil
	}
}

// NewDisplayProperties2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDisplayProperties2Ref(ref unsafe.Pointer) *DisplayProperties2 {
	if ref == nil {
		return nil
	}
	obj := new(DisplayProperties2)
	obj.ref80194833 = (*C.VkDisplayProperties2KHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DisplayProperties2) PassRef() (*C.VkDisplayProperties2KHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref80194833 != nil {
		return x.ref80194833, nil
	}
	mem80194833 := allocDisplayProperties2Memory(1)
	ref80194833 := (*C.VkDisplayProperties2KHR)(mem80194833)
	allocs80194833 := new(cgoAllocMap)
	allocs80194833.Add(mem80194833)

	ref80194833.sType = (C.VkStructureType)(x.SType)

	ref80194833.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	var cdisplayProperties_allocs *cgoAllocMap
	ref80194833.displayProperties, cdisplayProperties_allocs = x.DisplayProperties.PassValue()
	allocs80194833.Borrow(cdisplayProperties_allocs)

	x.ref80194833 = ref80194833
	x.allocs80194833 = allocs80194833
	return ref80194833, allocs80194833

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DisplayProperties2) PassValue() (C.VkDisplayProperties2KHR, *cgoAllocMap) {
	if x.ref80194833 != nil {
		return *x.ref80194833, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DisplayProperties2) Deref() {
	if x.ref80194833 == nil {
		return
	}
	x.SType = (StructureType)(x.ref80194833.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref80194833.pNext))
	x.DisplayProperties = *NewDisplayPropertiesRef(unsafe.Pointer(&x.ref80194833.displayProperties))
}

// allocDisplayPlaneProperties2Memory allocates memory for type C.VkDisplayPlaneProperties2KHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDisplayPlaneProperties2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDisplayPlaneProperties2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDisplayPlaneProperties2Value = unsafe.Sizeof([1]C.VkDisplayPlaneProperties2KHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DisplayPlaneProperties2) Ref() *C.VkDisplayPlaneProperties2KHR {
	if x == nil {
		return nil
	}
	return x.refa72b1e5b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DisplayPlaneProperties2) Free() {
	if x != nil && x.allocsa72b1e5b != nil {
		x.allocsa72b1e5b.(*cgoAllocMap).Free()
		x.refa72b1e5b = nil
	}
}

// NewDisplayPlaneProperties2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDisplayPlaneProperties2Ref(ref unsafe.Pointer) *DisplayPlaneProperties2 {
	if ref == nil {
		return nil
	}
	obj := new(DisplayPlaneProperties2)
	obj.refa72b1e5b = (*C.VkDisplayPlaneProperties2KHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DisplayPlaneProperties2) PassRef() (*C.VkDisplayPlaneProperties2KHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa72b1e5b != nil {
		return x.refa72b1e5b, nil
	}
	mema72b1e5b := allocDisplayPlaneProperties2Memory(1)
	refa72b1e5b := (*C.VkDisplayPlaneProperties2KHR)(mema72b1e5b)
	allocsa72b1e5b := new(cgoAllocMap)
	allocsa72b1e5b.Add(mema72b1e5b)

	refa72b1e5b.sType = (C.VkStructureType)(x.SType)

	refa72b1e5b.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	var cdisplayPlaneProperties_allocs *cgoAllocMap
	refa72b1e5b.displayPlaneProperties, cdisplayPlaneProperties_allocs = x.DisplayPlaneProperties.PassValue()
	allocsa72b1e5b.Borrow(cdisplayPlaneProperties_allocs)

	x.refa72b1e5b = refa72b1e5b
	x.allocsa72b1e5b = allocsa72b1e5b
	return refa72b1e5b, allocsa72b1e5b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DisplayPlaneProperties2) PassValue() (C.VkDisplayPlaneProperties2KHR, *cgoAllocMap) {
	if x.refa72b1e5b != nil {
		return *x.refa72b1e5b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DisplayPlaneProperties2) Deref() {
	if x.refa72b1e5b == nil {
		return
	}
	x.SType = (StructureType)(x.refa72b1e5b.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refa72b1e5b.pNext))
	x.DisplayPlaneProperties = *NewDisplayPlanePropertiesRef(unsafe.Pointer(&x.refa72b1e5b.displayPlaneProperties))
}

// allocDisplayModeProperties2Memory allocates memory for type C.VkDisplayModeProperties2KHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDisplayModeProperties2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDisplayModeProperties2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDisplayModeProperties2Value = unsafe.Sizeof([1]C.VkDisplayModeProperties2KHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DisplayModeProperties2) Ref() *C.VkDisplayModeProperties2KHR {
	if x == nil {
		return nil
	}
	return x.refc566048d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DisplayModeProperties2) Free() {
	if x != nil && x.allocsc566048d != nil {
		x.allocsc566048d.(*cgoAllocMap).Free()
		x.refc566048d = nil
	}
}

// NewDisplayModeProperties2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDisplayModeProperties2Ref(ref unsafe.Pointer) *DisplayModeProperties2 {
	if ref == nil {
		return nil
	}
	obj := new(DisplayModeProperties2)
	obj.refc566048d = (*C.VkDisplayModeProperties2KHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DisplayModeProperties2) PassRef() (*C.VkDisplayModeProperties2KHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc566048d != nil {
		return x.refc566048d, nil
	}
	memc566048d := allocDisplayModeProperties2Memory(1)
	refc566048d := (*C.VkDisplayModeProperties2KHR)(memc566048d)
	allocsc566048d := new(cgoAllocMap)
	allocsc566048d.Add(memc566048d)

	refc566048d.sType = (C.VkStructureType)(x.SType)

	refc566048d.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	var cdisplayModeProperties_allocs *cgoAllocMap
	refc566048d.displayModeProperties, cdisplayModeProperties_allocs = x.DisplayModeProperties.PassValue()
	allocsc566048d.Borrow(cdisplayModeProperties_allocs)

	x.refc566048d = refc566048d
	x.allocsc566048d = allocsc566048d
	return refc566048d, allocsc566048d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DisplayModeProperties2) PassValue() (C.VkDisplayModeProperties2KHR, *cgoAllocMap) {
	if x.refc566048d != nil {
		return *x.refc566048d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DisplayModeProperties2) Deref() {
	if x.refc566048d == nil {
		return
	}
	x.SType = (StructureType)(x.refc566048d.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refc566048d.pNext))
	x.DisplayModeProperties = *NewDisplayModePropertiesRef(unsafe.Pointer(&x.refc566048d.displayModeProperties))
}

// allocDisplayPlaneInfo2Memory allocates memory for type C.VkDisplayPlaneInfo2KHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDisplayPlaneInfo2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDisplayPlaneInfo2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDisplayPlaneInfo2Value = unsafe.Sizeof([1]C.VkDisplayPlaneInfo2KHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DisplayPlaneInfo2) Ref() *C.VkDisplayPlaneInfo2KHR {
	if x == nil {
		return nil
	}
	return x.reff355ccbf
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DisplayPlaneInfo2) Free() {
	if x != nil && x.allocsf355ccbf != nil {
		x.allocsf355ccbf.(*cgoAllocMap).Free()
		x.reff355ccbf = nil
	}
}

// NewDisplayPlaneInfo2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDisplayPlaneInfo2Ref(ref unsafe.Pointer) *DisplayPlaneInfo2 {
	if ref == nil {
		return nil
	}
	obj := new(DisplayPlaneInfo2)
	obj.reff355ccbf = (*C.VkDisplayPlaneInfo2KHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DisplayPlaneInfo2) PassRef() (*C.VkDisplayPlaneInfo2KHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff355ccbf != nil {
		return x.reff355ccbf, nil
	}
	memf355ccbf := allocDisplayPlaneInfo2Memory(1)
	reff355ccbf := (*C.VkDisplayPlaneInfo2KHR)(memf355ccbf)
	allocsf355ccbf := new(cgoAllocMap)
	allocsf355ccbf.Add(memf355ccbf)

	reff355ccbf.sType = (C.VkStructureType)(x.SType)

	reff355ccbf.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	reff355ccbf.mode = *(*C.VkDisplayModeKHR)(unsafe.Pointer(&x.Mode))

	reff355ccbf.planeIndex = (C.uint32_t)(x.PlaneIndex)

	x.reff355ccbf = reff355ccbf
	x.allocsf355ccbf = allocsf355ccbf
	return reff355ccbf, allocsf355ccbf

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DisplayPlaneInfo2) PassValue() (C.VkDisplayPlaneInfo2KHR, *cgoAllocMap) {
	if x.reff355ccbf != nil {
		return *x.reff355ccbf, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DisplayPlaneInfo2) Deref() {
	if x.reff355ccbf == nil {
		return
	}
	x.SType = (StructureType)(x.reff355ccbf.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.reff355ccbf.pNext))
	x.Mode = *(*DisplayMode)(unsafe.Pointer(&x.reff355ccbf.mode))
	x.PlaneIndex = (uint32)(x.reff355ccbf.planeIndex)
}

// allocFragmentShadingRateAttachmentInfoMemory allocates memory for type C.VkFragmentShadingRateAttachmentInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFragmentShadingRateAttachmentInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFragmentShadingRateAttachmentInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFragmentShadingRateAttachmentInfoValue = unsafe.Sizeof([1]C.VkFragmentShadingRateAttachmentInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FragmentShadingRateAttachmentInfo) Ref() *C.VkFragmentShadingRateAttachmentInfoKHR {
	if x == nil {
		return nil
	}
	return x.refd9f9d390
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FragmentShadingRateAttachmentInfo) Free() {
	if x != nil && x.allocsd9f9d390 != nil {
		x.allocsd9f9d390.(*cgoAllocMap).Free()
		x.refd9f9d390 = nil
	}
}

// NewFragmentShadingRateAttachmentInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFragmentShadingRateAttachmentInfoRef(ref unsafe.Pointer) *FragmentShadingRateAttachmentInfo {
	if ref == nil {
		return nil
	}
	obj := new(FragmentShadingRateAttachmentInfo)
	obj.refd9f9d390 = (*C.VkFragmentShadingRateAttachmentInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FragmentShadingRateAttachmentInfo) PassRef() (*C.VkFragmentShadingRateAttachmentInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd9f9d390 != nil {
		return x.refd9f9d390, nil
	}
	memd9f9d390 := allocFragmentShadingRateAttachmentInfoMemory(1)
	refd9f9d390 := (*C.VkFragmentShadingRateAttachmentInfoKHR)(memd9f9d390)
	allocsd9f9d390 := new(cgoAllocMap)
	allocsd9f9d390.Add(memd9f9d390)

	refd9f9d390.sType = (C.VkStructureType)(x.SType)

	refd9f9d390.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	if x.PFragmentShadingRateAttachment != nil {
		var cpFragmentShadingRateAttachment_allocs *cgoAllocMap
		refd9f9d390.pFragmentShadingRateAttachment, cpFragmentShadingRateAttachment_allocs = copyPAttachmentReference2Bytes((*sliceHeader)(unsafe.Pointer(&x.PFragmentShadingRateAttachment)))
		allocsd9f9d390.Borrow(cpFragmentShadingRateAttachment_allocs)
	}

	refd9f9d390.shadingRateAttachmentTexelSize = *(*C.VkExtent2D)(unsafe.Pointer(&x.ShadingRateAttachmentTexelSize))

	x.refd9f9d390 = refd9f9d390
	x.allocsd9f9d390 = allocsd9f9d390
	return refd9f9d390, allocsd9f9d390

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FragmentShadingRateAttachmentInfo) PassValue() (C.VkFragmentShadingRateAttachmentInfoKHR, *cgoAllocMap) {
	if x.refd9f9d390 != nil {
		return *x.refd9f9d390, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FragmentShadingRateAttachmentInfo) Deref() {
	if x.refd9f9d390 == nil {
		return
	}
	x.SType = (StructureType)(x.refd9f9d390.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refd9f9d390.pNext))
	hxf349858 := (*sliceHeader)(unsafe.Pointer(&x.PFragmentShadingRateAttachment))
	hxf349858.Data = unsafe.Pointer(x.refd9f9d390.pFragmentShadingRateAttachment)
	hxf349858.Cap = 0x7fffffff
	// hxf349858.Len = ? x.PFragmentShadingRateAttachment x.refd9f9d390.pFragmentShadingRateAttachment

	x.ShadingRateAttachmentTexelSize = *(*Extent2D)(unsafe.Pointer(&x.refd9f9d390.shadingRateAttachmentTexelSize))
}

// allocPipelineInfoMemory allocates memory for type C.VkPipelineInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPipelineInfoValue = unsafe.Sizeof([1]C.VkPipelineInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineInfo) Ref() *C.VkPipelineInfoKHR {
	if x == nil {
		return nil
	}
	return x.refcd879ca1
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineInfo) Free() {
	if x != nil && x.allocscd879ca1 != nil {
		x.allocscd879ca1.(*cgoAllocMap).Free()
		x.refcd879ca1 = nil
	}
}

// NewPipelineInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineInfoRef(ref unsafe.Pointer) *PipelineInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineInfo)
	obj.refcd879ca1 = (*C.VkPipelineInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineInfo) PassRef() (*C.VkPipelineInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refcd879ca1 != nil {
		return x.refcd879ca1, nil
	}
	memcd879ca1 := allocPipelineInfoMemory(1)
	refcd879ca1 := (*C.VkPipelineInfoKHR)(memcd879ca1)
	allocscd879ca1 := new(cgoAllocMap)
	allocscd879ca1.Add(memcd879ca1)

	refcd879ca1.sType = (C.VkStructureType)(x.SType)

	refcd879ca1.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	refcd879ca1.pipeline = *(*C.VkPipeline)(unsafe.Pointer(&x.Pipeline))

	x.refcd879ca1 = refcd879ca1
	x.allocscd879ca1 = allocscd879ca1
	return refcd879ca1, allocscd879ca1

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineInfo) PassValue() (C.VkPipelineInfoKHR, *cgoAllocMap) {
	if x.refcd879ca1 != nil {
		return *x.refcd879ca1, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineInfo) Deref() {
	if x.refcd879ca1 == nil {
		return
	}
	x.SType = (StructureType)(x.refcd879ca1.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refcd879ca1.pNext))
	x.Pipeline = *(*Pipeline)(unsafe.Pointer(&x.refcd879ca1.pipeline))
}

// allocPipelineExecutablePropertiesMemory allocates memory for type C.VkPipelineExecutablePropertiesKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineExecutablePropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineExecutablePropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPipelineExecutablePropertiesValue = unsafe.Sizeof([1]C.VkPipelineExecutablePropertiesKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineExecutableProperties) Ref() *C.VkPipelineExecutablePropertiesKHR {
	if x == nil {
		return nil
	}
	return x.ref4eb592a4
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineExecutableProperties) Free() {
	if x != nil && x.allocs4eb592a4 != nil {
		x.allocs4eb592a4.(*cgoAllocMap).Free()
		x.ref4eb592a4 = nil
	}
}

// NewPipelineExecutablePropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineExecutablePropertiesRef(ref unsafe.Pointer) *PipelineExecutableProperties {
	if ref == nil {
		return nil
	}
	obj := new(PipelineExecutableProperties)
	obj.ref4eb592a4 = (*C.VkPipelineExecutablePropertiesKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineExecutableProperties) PassRef() (*C.VkPipelineExecutablePropertiesKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4eb592a4 != nil {
		return x.ref4eb592a4, nil
	}
	mem4eb592a4 := allocPipelineExecutablePropertiesMemory(1)
	ref4eb592a4 := (*C.VkPipelineExecutablePropertiesKHR)(mem4eb592a4)
	allocs4eb592a4 := new(cgoAllocMap)
	allocs4eb592a4.Add(mem4eb592a4)

	ref4eb592a4.sType = (C.VkStructureType)(x.SType)

	ref4eb592a4.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref4eb592a4.stages = (C.VkShaderStageFlags)(x.Stages)

	ref4eb592a4.name = *(*[256]C.char)(unsafe.Pointer(&x.Name))

	ref4eb592a4.description = *(*[256]C.char)(unsafe.Pointer(&x.Description))

	ref4eb592a4.subgroupSize = (C.uint32_t)(x.SubgroupSize)

	x.ref4eb592a4 = ref4eb592a4
	x.allocs4eb592a4 = allocs4eb592a4
	return ref4eb592a4, allocs4eb592a4

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineExecutableProperties) PassValue() (C.VkPipelineExecutablePropertiesKHR, *cgoAllocMap) {
	if x.ref4eb592a4 != nil {
		return *x.ref4eb592a4, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineExecutableProperties) Deref() {
	if x.ref4eb592a4 == nil {
		return
	}
	x.SType = (StructureType)(x.ref4eb592a4.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref4eb592a4.pNext))
	x.Stages = (ShaderStageFlags)(x.ref4eb592a4.stages)
	x.Name = *(*[256]byte)(unsafe.Pointer(&x.ref4eb592a4.name))
	x.Description = *(*[256]byte)(unsafe.Pointer(&x.ref4eb592a4.description))
	x.SubgroupSize = (uint32)(x.ref4eb592a4.subgroupSize)
}

// allocPipelineExecutableInfoMemory allocates memory for type C.VkPipelineExecutableInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineExecutableInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineExecutableInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPipelineExecutableInfoValue = unsafe.Sizeof([1]C.VkPipelineExecutableInfoKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineExecutableInfo) Ref() *C.VkPipelineExecutableInfoKHR {
	if x == nil {
		return nil
	}
	return x.ref9b891dad
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineExecutableInfo) Free() {
	if x != nil && x.allocs9b891dad != nil {
		x.allocs9b891dad.(*cgoAllocMap).Free()
		x.ref9b891dad = nil
	}
}

// NewPipelineExecutableInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineExecutableInfoRef(ref unsafe.Pointer) *PipelineExecutableInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineExecutableInfo)
	obj.ref9b891dad = (*C.VkPipelineExecutableInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineExecutableInfo) PassRef() (*C.VkPipelineExecutableInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9b891dad != nil {
		return x.ref9b891dad, nil
	}
	mem9b891dad := allocPipelineExecutableInfoMemory(1)
	ref9b891dad := (*C.VkPipelineExecutableInfoKHR)(mem9b891dad)
	allocs9b891dad := new(cgoAllocMap)
	allocs9b891dad.Add(mem9b891dad)

	ref9b891dad.sType = (C.VkStructureType)(x.SType)

	ref9b891dad.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref9b891dad.pipeline = *(*C.VkPipeline)(unsafe.Pointer(&x.Pipeline))

	ref9b891dad.executableIndex = (C.uint32_t)(x.ExecutableIndex)

	x.ref9b891dad = ref9b891dad
	x.allocs9b891dad = allocs9b891dad
	return ref9b891dad, allocs9b891dad

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineExecutableInfo) PassValue() (C.VkPipelineExecutableInfoKHR, *cgoAllocMap) {
	if x.ref9b891dad != nil {
		return *x.ref9b891dad, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineExecutableInfo) Deref() {
	if x.ref9b891dad == nil {
		return
	}
	x.SType = (StructureType)(x.ref9b891dad.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref9b891dad.pNext))
	x.Pipeline = *(*Pipeline)(unsafe.Pointer(&x.ref9b891dad.pipeline))
	x.ExecutableIndex = (uint32)(x.ref9b891dad.executableIndex)
}

// allocPipelineExecutableStatisticMemory allocates memory for type C.VkPipelineExecutableStatisticKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineExecutableStatisticMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineExecutableStatisticValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPipelineExecutableStatisticValue = unsafe.Sizeof([1]C.VkPipelineExecutableStatisticKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineExecutableStatistic) Ref() *C.VkPipelineExecutableStatisticKHR {
	if x == nil {
		return nil
	}
	return x.ref4af1a62c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineExecutableStatistic) Free() {
	if x != nil && x.allocs4af1a62c != nil {
		x.allocs4af1a62c.(*cgoAllocMap).Free()
		x.ref4af1a62c = nil
	}
}

// NewPipelineExecutableStatisticRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineExecutableStatisticRef(ref unsafe.Pointer) *PipelineExecutableStatistic {
	if ref == nil {
		return nil
	}
	obj := new(PipelineExecutableStatistic)
	obj.ref4af1a62c = (*C.VkPipelineExecutableStatisticKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineExecutableStatistic) PassRef() (*C.VkPipelineExecutableStatisticKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4af1a62c != nil {
		return x.ref4af1a62c, nil
	}
	mem4af1a62c := allocPipelineExecutableStatisticMemory(1)
	ref4af1a62c := (*C.VkPipelineExecutableStatisticKHR)(mem4af1a62c)
	allocs4af1a62c := new(cgoAllocMap)
	allocs4af1a62c.Add(mem4af1a62c)

	ref4af1a62c.sType = (C.VkStructureType)(x.SType)

	ref4af1a62c.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref4af1a62c.name = *(*[256]C.char)(unsafe.Pointer(&x.Name))

	ref4af1a62c.description = *(*[256]C.char)(unsafe.Pointer(&x.Description))

	ref4af1a62c.format = (C.VkPipelineExecutableStatisticFormatKHR)(x.Format)

	ref4af1a62c.value = *(*C.VkPipelineExecutableStatisticValueKHR)(unsafe.Pointer(&x.Value))

	x.ref4af1a62c = ref4af1a62c
	x.allocs4af1a62c = allocs4af1a62c
	return ref4af1a62c, allocs4af1a62c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineExecutableStatistic) PassValue() (C.VkPipelineExecutableStatisticKHR, *cgoAllocMap) {
	if x.ref4af1a62c != nil {
		return *x.ref4af1a62c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineExecutableStatistic) Deref() {
	if x.ref4af1a62c == nil {
		return
	}
	x.SType = (StructureType)(x.ref4af1a62c.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref4af1a62c.pNext))
	x.Name = *(*[256]byte)(unsafe.Pointer(&x.ref4af1a62c.name))
	x.Description = *(*[256]byte)(unsafe.Pointer(&x.ref4af1a62c.description))
	x.Format = (PipelineExecutableStatisticFormat)(x.ref4af1a62c.format)
	x.Value = *(*PipelineExecutableStatisticValue)(unsafe.Pointer(&x.ref4af1a62c.value))
}

// allocPipelineExecutableInternalRepresentationMemory allocates memory for type C.VkPipelineExecutableInternalRepresentationKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineExecutableInternalRepresentationMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineExecutableInternalRepresentationValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPipelineExecutableInternalRepresentationValue = unsafe.Sizeof([1]C.VkPipelineExecutableInternalRepresentationKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineExecutableInternalRepresentation) Ref() *C.VkPipelineExecutableInternalRepresentationKHR {
	if x == nil {
		return nil
	}
	return x.ref20e334f7
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineExecutableInternalRepresentation) Free() {
	if x != nil && x.allocs20e334f7 != nil {
		x.allocs20e334f7.(*cgoAllocMap).Free()
		x.ref20e334f7 = nil
	}
}

// NewPipelineExecutableInternalRepresentationRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineExecutableInternalRepresentationRef(ref unsafe.Pointer) *PipelineExecutableInternalRepresentation {
	if ref == nil {
		return nil
	}
	obj := new(PipelineExecutableInternalRepresentation)
	obj.ref20e334f7 = (*C.VkPipelineExecutableInternalRepresentationKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineExecutableInternalRepresentation) PassRef() (*C.VkPipelineExecutableInternalRepresentationKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref20e334f7 != nil {
		return x.ref20e334f7, nil
	}
	mem20e334f7 := allocPipelineExecutableInternalRepresentationMemory(1)
	ref20e334f7 := (*C.VkPipelineExecutableInternalRepresentationKHR)(mem20e334f7)
	allocs20e334f7 := new(cgoAllocMap)
	allocs20e334f7.Add(mem20e334f7)

	ref20e334f7.sType = (C.VkStructureType)(x.SType)

	ref20e334f7.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref20e334f7.name = *(*[256]C.char)(unsafe.Pointer(&x.Name))

	ref20e334f7.description = *(*[256]C.char)(unsafe.Pointer(&x.Description))

	ref20e334f7.isText = (C.VkBool32)(x.IsText)

	ref20e334f7.dataSize = (C.size_t)(x.DataSize)

	ref20e334f7.pData = *(*unsafe.Pointer)(unsafe.Pointer(&x.PData))

	x.ref20e334f7 = ref20e334f7
	x.allocs20e334f7 = allocs20e334f7
	return ref20e334f7, allocs20e334f7

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineExecutableInternalRepresentation) PassValue() (C.VkPipelineExecutableInternalRepresentationKHR, *cgoAllocMap) {
	if x.ref20e334f7 != nil {
		return *x.ref20e334f7, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineExecutableInternalRepresentation) Deref() {
	if x.ref20e334f7 == nil {
		return
	}
	x.SType = (StructureType)(x.ref20e334f7.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref20e334f7.pNext))
	x.Name = *(*[256]byte)(unsafe.Pointer(&x.ref20e334f7.name))
	x.Description = *(*[256]byte)(unsafe.Pointer(&x.ref20e334f7.description))
	x.IsText = (Bool32)(x.ref20e334f7.isText)
	x.DataSize = (uint64)(x.ref20e334f7.dataSize)
	x.PData = (unsafe.Pointer)(unsafe.Pointer(x.ref20e334f7.pData))
}

// allocPipelineLibraryCreateInfoMemory allocates memory for type C.VkPipelineLibraryCreateInfoKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineLibraryCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineLibraryCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPipelineLibraryCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineLibraryCreateInfoKHR{})

// copyPPipelineBytes copies the data from Go slice as *C.VkPipeline.
func copyPPipelineBytes(slice *sliceHeader) (*C.VkPipeline, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfPipelineValue) * slice.Len,
		Cap:  int(sizeOfPipelineValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkPipeline)(mem0), allocs
}

// allocPipelineMemory allocates memory for type C.VkPipeline in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPipelineValue = unsafe.Sizeof([1]C.VkPipeline{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineLibraryCreateInfo) Ref() *C.VkPipelineLibraryCreateInfoKHR {
	if x == nil {
		return nil
	}
	return x.ref6bb7541b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineLibraryCreateInfo) Free() {
	if x != nil && x.allocs6bb7541b != nil {
		x.allocs6bb7541b.(*cgoAllocMap).Free()
		x.ref6bb7541b = nil
	}
}

// NewPipelineLibraryCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineLibraryCreateInfoRef(ref unsafe.Pointer) *PipelineLibraryCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineLibraryCreateInfo)
	obj.ref6bb7541b = (*C.VkPipelineLibraryCreateInfoKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineLibraryCreateInfo) PassRef() (*C.VkPipelineLibraryCreateInfoKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6bb7541b != nil {
		return x.ref6bb7541b, nil
	}
	mem6bb7541b := allocPipelineLibraryCreateInfoMemory(1)
	ref6bb7541b := (*C.VkPipelineLibraryCreateInfoKHR)(mem6bb7541b)
	allocs6bb7541b := new(cgoAllocMap)
	allocs6bb7541b.Add(mem6bb7541b)

	ref6bb7541b.sType = (C.VkStructureType)(x.SType)

	ref6bb7541b.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref6bb7541b.libraryCount = (C.uint32_t)(x.LibraryCount)

	if x.PLibraries != nil {
		var cpLibraries_allocs *cgoAllocMap
		ref6bb7541b.pLibraries, cpLibraries_allocs = copyPPipelineBytes((*sliceHeader)(unsafe.Pointer(&x.PLibraries)))
		allocs6bb7541b.Borrow(cpLibraries_allocs)
	}

	x.ref6bb7541b = ref6bb7541b
	x.allocs6bb7541b = allocs6bb7541b
	return ref6bb7541b, allocs6bb7541b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineLibraryCreateInfo) PassValue() (C.VkPipelineLibraryCreateInfoKHR, *cgoAllocMap) {
	if x.ref6bb7541b != nil {
		return *x.ref6bb7541b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineLibraryCreateInfo) Deref() {
	if x.ref6bb7541b == nil {
		return
	}
	x.SType = (StructureType)(x.ref6bb7541b.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref6bb7541b.pNext))
	x.LibraryCount = (uint32)(x.ref6bb7541b.libraryCount)
	hxf7c2645 := (*sliceHeader)(unsafe.Pointer(&x.PLibraries))
	hxf7c2645.Data = unsafe.Pointer(x.ref6bb7541b.pLibraries)
	hxf7c2645.Cap = 0x7fffffff
	// hxf7c2645.Len = ? x.PLibraries x.ref6bb7541b.pLibraries

}

// allocPresentIdMemory allocates memory for type C.VkPresentIdKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPresentIdMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPresentIdValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPresentIdValue = unsafe.Sizeof([1]C.VkPresentIdKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PresentId) Ref() *C.VkPresentIdKHR {
	if x == nil {
		return nil
	}
	return x.ref70010623
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PresentId) Free() {
	if x != nil && x.allocs70010623 != nil {
		x.allocs70010623.(*cgoAllocMap).Free()
		x.ref70010623 = nil
	}
}

// NewPresentIdRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPresentIdRef(ref unsafe.Pointer) *PresentId {
	if ref == nil {
		return nil
	}
	obj := new(PresentId)
	obj.ref70010623 = (*C.VkPresentIdKHR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PresentId) PassRef() (*C.VkPresentIdKHR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref70010623 != nil {
		return x.ref70010623, nil
	}
	mem70010623 := allocPresentIdMemory(1)
	ref70010623 := (*C.VkPresentIdKHR)(mem70010623)
	allocs70010623 := new(cgoAllocMap)
	allocs70010623.Add(mem70010623)

	ref70010623.sType = (C.VkStructureType)(x.SType)

	ref70010623.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref70010623.swapchainCount = (C.uint32_t)(x.SwapchainCount)

	if x.PPresentIds != nil {
		var cpPresentIds_allocs *cgoAllocMap
		ref70010623.pPresentIds, cpPresentIds_allocs = copyPUint64_tBytes((*sliceHeader)(unsafe.Pointer(&x.PPresentIds)))
		allocs70010623.Borrow(cpPresentIds_allocs)
	}

	x.ref70010623 = ref70010623
	x.allocs70010623 = allocs70010623
	return ref70010623, allocs70010623

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PresentId) PassValue() (C.VkPresentIdKHR, *cgoAllocMap) {
	if x.ref70010623 != nil {
		return *x.ref70010623, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PresentId) Deref() {
	if x.ref70010623 == nil {
		return
	}
	x.SType = (StructureType)(x.ref70010623.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref70010623.pNext))
	x.SwapchainCount = (uint32)(x.ref70010623.swapchainCount)
	hxfc83749 := (*sliceHeader)(unsafe.Pointer(&x.PPresentIds))
	hxfc83749.Data = unsafe.Pointer(x.ref70010623.pPresentIds)
	hxfc83749.Cap = 0x7fffffff
	// hxfc83749.Len = ? x.PPresentIds x.ref70010623.pPresentIds

}

func (x DebugReportCallbackFunc) PassRef() (ref *C.PFN_vkDebugReportCallbackEXT, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if debugReportCallbackFuncC918AAC4Func == nil {
		debugReportCallbackFuncC918AAC4Func = x
	}
	return (*C.PFN_vkDebugReportCallbackEXT)(C.PFN_vkDebugReportCallbackEXT_c918aac4), nil
}

func (x DebugReportCallbackFunc) PassValue() (ref C.PFN_vkDebugReportCallbackEXT, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if debugReportCallbackFuncC918AAC4Func == nil {
		debugReportCallbackFuncC918AAC4Func = x
	}
	return (C.PFN_vkDebugReportCallbackEXT)(C.PFN_vkDebugReportCallbackEXT_c918aac4), nil
}

func NewDebugReportCallbackFuncRef(ref unsafe.Pointer) *DebugReportCallbackFunc {
	return (*DebugReportCallbackFunc)(ref)
}

//export debugReportCallbackFuncC918AAC4
func debugReportCallbackFuncC918AAC4(cflags C.VkDebugReportFlagsEXT, cobjectType C.VkDebugReportObjectTypeEXT, cobject C.uint64_t, clocation C.size_t, cmessageCode C.int32_t, cpLayerPrefix *C.char, cpMessage *C.char, cpUserData unsafe.Pointer) C.VkBool32 {
	if debugReportCallbackFuncC918AAC4Func != nil {
		flagsc918aac4 := (DebugReportFlags)(cflags)
		objectTypec918aac4 := (DebugReportObjectType)(cobjectType)
		objectc918aac4 := (uint64)(cobject)
		locationc918aac4 := (uint64)(clocation)
		messageCodec918aac4 := (int32)(cmessageCode)
		pLayerPrefixc918aac4 := packPCharString(cpLayerPrefix)
		pMessagec918aac4 := packPCharString(cpMessage)
		pUserDatac918aac4 := (unsafe.Pointer)(unsafe.Pointer(cpUserData))
		retc918aac4 := debugReportCallbackFuncC918AAC4Func(flagsc918aac4, objectTypec918aac4, objectc918aac4, locationc918aac4, messageCodec918aac4, pLayerPrefixc918aac4, pMessagec918aac4, pUserDatac918aac4)
		ret, _ := (C.VkBool32)(retc918aac4), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var debugReportCallbackFuncC918AAC4Func DebugReportCallbackFunc

// allocDebugReportCallbackCreateInfoMemory allocates memory for type C.VkDebugReportCallbackCreateInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDebugReportCallbackCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDebugReportCallbackCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDebugReportCallbackCreateInfoValue = unsafe.Sizeof([1]C.VkDebugReportCallbackCreateInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DebugReportCallbackCreateInfo) Ref() *C.VkDebugReportCallbackCreateInfoEXT {
	if x == nil {
		return nil
	}
	return x.refc8238563
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DebugReportCallbackCreateInfo) Free() {
	if x != nil && x.allocsc8238563 != nil {
		x.allocsc8238563.(*cgoAllocMap).Free()
		x.refc8238563 = nil
	}
}

// NewDebugReportCallbackCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDebugReportCallbackCreateInfoRef(ref unsafe.Pointer) *DebugReportCallbackCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(DebugReportCallbackCreateInfo)
	obj.refc8238563 = (*C.VkDebugReportCallbackCreateInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DebugReportCallbackCreateInfo) PassRef() (*C.VkDebugReportCallbackCreateInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc8238563 != nil {
		return x.refc8238563, nil
	}
	memc8238563 := allocDebugReportCallbackCreateInfoMemory(1)
	refc8238563 := (*C.VkDebugReportCallbackCreateInfoEXT)(memc8238563)
	allocsc8238563 := new(cgoAllocMap)
	allocsc8238563.Add(memc8238563)

	refc8238563.sType = (C.VkStructureType)(x.SType)

	refc8238563.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	refc8238563.flags = (C.VkDebugReportFlagsEXT)(x.Flags)

	var cpfnCallback_allocs *cgoAllocMap
	refc8238563.pfnCallback, cpfnCallback_allocs = x.PfnCallback.PassValue()
	allocsc8238563.Borrow(cpfnCallback_allocs)

	refc8238563.pUserData = *(*unsafe.Pointer)(unsafe.Pointer(&x.PUserData))

	x.refc8238563 = refc8238563
	x.allocsc8238563 = allocsc8238563
	return refc8238563, allocsc8238563

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DebugReportCallbackCreateInfo) PassValue() (C.VkDebugReportCallbackCreateInfoEXT, *cgoAllocMap) {
	if x.refc8238563 != nil {
		return *x.refc8238563, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DebugReportCallbackCreateInfo) Deref() {
	if x.refc8238563 == nil {
		return
	}
	x.SType = (StructureType)(x.refc8238563.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refc8238563.pNext))
	x.Flags = (DebugReportFlags)(x.refc8238563.flags)
	x.PfnCallback = *NewDebugReportCallbackFuncRef(unsafe.Pointer(&x.refc8238563.pfnCallback))
	x.PUserData = (unsafe.Pointer)(unsafe.Pointer(x.refc8238563.pUserData))
}

// allocDebugMarkerObjectNameInfoMemory allocates memory for type C.VkDebugMarkerObjectNameInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDebugMarkerObjectNameInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDebugMarkerObjectNameInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDebugMarkerObjectNameInfoValue = unsafe.Sizeof([1]C.VkDebugMarkerObjectNameInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DebugMarkerObjectNameInfo) Ref() *C.VkDebugMarkerObjectNameInfoEXT {
	if x == nil {
		return nil
	}
	return x.refe4983fab
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DebugMarkerObjectNameInfo) Free() {
	if x != nil && x.allocse4983fab != nil {
		x.allocse4983fab.(*cgoAllocMap).Free()
		x.refe4983fab = nil
	}
}

// NewDebugMarkerObjectNameInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDebugMarkerObjectNameInfoRef(ref unsafe.Pointer) *DebugMarkerObjectNameInfo {
	if ref == nil {
		return nil
	}
	obj := new(DebugMarkerObjectNameInfo)
	obj.refe4983fab = (*C.VkDebugMarkerObjectNameInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DebugMarkerObjectNameInfo) PassRef() (*C.VkDebugMarkerObjectNameInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe4983fab != nil {
		return x.refe4983fab, nil
	}
	meme4983fab := allocDebugMarkerObjectNameInfoMemory(1)
	refe4983fab := (*C.VkDebugMarkerObjectNameInfoEXT)(meme4983fab)
	allocse4983fab := new(cgoAllocMap)
	allocse4983fab.Add(meme4983fab)

	refe4983fab.sType = (C.VkStructureType)(x.SType)

	refe4983fab.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	refe4983fab.objectType = (C.VkDebugReportObjectTypeEXT)(x.ObjectType)

	refe4983fab.object = (C.uint64_t)(x.Object)

	var cpObjectName_allocs *cgoAllocMap
	refe4983fab.pObjectName, cpObjectName_allocs = copyPCharBytes((*sliceHeader)(unsafe.Pointer(&x.PObjectName)))
	allocse4983fab.Borrow(cpObjectName_allocs)

	x.refe4983fab = refe4983fab
	x.allocse4983fab = allocse4983fab
	return refe4983fab, allocse4983fab

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DebugMarkerObjectNameInfo) PassValue() (C.VkDebugMarkerObjectNameInfoEXT, *cgoAllocMap) {
	if x.refe4983fab != nil {
		return *x.refe4983fab, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DebugMarkerObjectNameInfo) Deref() {
	if x.refe4983fab == nil {
		return
	}
	x.SType = (StructureType)(x.refe4983fab.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refe4983fab.pNext))
	x.ObjectType = (DebugReportObjectType)(x.refe4983fab.objectType)
	x.Object = (uint64)(x.refe4983fab.object)
	hxfa45f91 := (*sliceHeader)(unsafe.Pointer(&x.PObjectName))
	hxfa45f91.Data = unsafe.Pointer(x.refe4983fab.pObjectName)
	hxfa45f91.Cap = 0x7fffffff
	// hxfa45f91.Len = ? x.PObjectName x.refe4983fab.pObjectName

}

// allocDebugMarkerMarkerInfoMemory allocates memory for type C.VkDebugMarkerMarkerInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDebugMarkerMarkerInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDebugMarkerMarkerInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDebugMarkerMarkerInfoValue = unsafe.Sizeof([1]C.VkDebugMarkerMarkerInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DebugMarkerMarkerInfo) Ref() *C.VkDebugMarkerMarkerInfoEXT {
	if x == nil {
		return nil
	}
	return x.ref234b91fd
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DebugMarkerMarkerInfo) Free() {
	if x != nil && x.allocs234b91fd != nil {
		x.allocs234b91fd.(*cgoAllocMap).Free()
		x.ref234b91fd = nil
	}
}

// NewDebugMarkerMarkerInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDebugMarkerMarkerInfoRef(ref unsafe.Pointer) *DebugMarkerMarkerInfo {
	if ref == nil {
		return nil
	}
	obj := new(DebugMarkerMarkerInfo)
	obj.ref234b91fd = (*C.VkDebugMarkerMarkerInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DebugMarkerMarkerInfo) PassRef() (*C.VkDebugMarkerMarkerInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref234b91fd != nil {
		return x.ref234b91fd, nil
	}
	mem234b91fd := allocDebugMarkerMarkerInfoMemory(1)
	ref234b91fd := (*C.VkDebugMarkerMarkerInfoEXT)(mem234b91fd)
	allocs234b91fd := new(cgoAllocMap)
	allocs234b91fd.Add(mem234b91fd)

	ref234b91fd.sType = (C.VkStructureType)(x.SType)

	ref234b91fd.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	var cpMarkerName_allocs *cgoAllocMap
	ref234b91fd.pMarkerName, cpMarkerName_allocs = copyPCharBytes((*sliceHeader)(unsafe.Pointer(&x.PMarkerName)))
	allocs234b91fd.Borrow(cpMarkerName_allocs)

	ref234b91fd.color = *(*[4]C.float)(unsafe.Pointer(&x.Color))

	x.ref234b91fd = ref234b91fd
	x.allocs234b91fd = allocs234b91fd
	return ref234b91fd, allocs234b91fd

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DebugMarkerMarkerInfo) PassValue() (C.VkDebugMarkerMarkerInfoEXT, *cgoAllocMap) {
	if x.ref234b91fd != nil {
		return *x.ref234b91fd, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DebugMarkerMarkerInfo) Deref() {
	if x.ref234b91fd == nil {
		return
	}
	x.SType = (StructureType)(x.ref234b91fd.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref234b91fd.pNext))
	hxf59053c := (*sliceHeader)(unsafe.Pointer(&x.PMarkerName))
	hxf59053c.Data = unsafe.Pointer(x.ref234b91fd.pMarkerName)
	hxf59053c.Cap = 0x7fffffff
	// hxf59053c.Len = ? x.PMarkerName x.ref234b91fd.pMarkerName

	x.Color = *(*[4]float32)(unsafe.Pointer(&x.ref234b91fd.color))
}

// allocDedicatedAllocationMemoryAllocateInfoNVMemory allocates memory for type C.VkDedicatedAllocationMemoryAllocateInfoNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDedicatedAllocationMemoryAllocateInfoNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDedicatedAllocationMemoryAllocateInfoNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDedicatedAllocationMemoryAllocateInfoNVValue = unsafe.Sizeof([1]C.VkDedicatedAllocationMemoryAllocateInfoNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DedicatedAllocationMemoryAllocateInfoNV) Ref() *C.VkDedicatedAllocationMemoryAllocateInfoNV {
	if x == nil {
		return nil
	}
	return x.ref9a72b107
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DedicatedAllocationMemoryAllocateInfoNV) Free() {
	if x != nil && x.allocs9a72b107 != nil {
		x.allocs9a72b107.(*cgoAllocMap).Free()
		x.ref9a72b107 = nil
	}
}

// NewDedicatedAllocationMemoryAllocateInfoNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDedicatedAllocationMemoryAllocateInfoNVRef(ref unsafe.Pointer) *DedicatedAllocationMemoryAllocateInfoNV {
	if ref == nil {
		return nil
	}
	obj := new(DedicatedAllocationMemoryAllocateInfoNV)
	obj.ref9a72b107 = (*C.VkDedicatedAllocationMemoryAllocateInfoNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DedicatedAllocationMemoryAllocateInfoNV) PassRef() (*C.VkDedicatedAllocationMemoryAllocateInfoNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9a72b107 != nil {
		return x.ref9a72b107, nil
	}
	mem9a72b107 := allocDedicatedAllocationMemoryAllocateInfoNVMemory(1)
	ref9a72b107 := (*C.VkDedicatedAllocationMemoryAllocateInfoNV)(mem9a72b107)
	allocs9a72b107 := new(cgoAllocMap)
	allocs9a72b107.Add(mem9a72b107)

	ref9a72b107.sType = (C.VkStructureType)(x.SType)

	ref9a72b107.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref9a72b107.image = *(*C.VkImage)(unsafe.Pointer(&x.Image))

	ref9a72b107.buffer = *(*C.VkBuffer)(unsafe.Pointer(&x.Buffer))

	x.ref9a72b107 = ref9a72b107
	x.allocs9a72b107 = allocs9a72b107
	return ref9a72b107, allocs9a72b107

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DedicatedAllocationMemoryAllocateInfoNV) PassValue() (C.VkDedicatedAllocationMemoryAllocateInfoNV, *cgoAllocMap) {
	if x.ref9a72b107 != nil {
		return *x.ref9a72b107, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DedicatedAllocationMemoryAllocateInfoNV) Deref() {
	if x.ref9a72b107 == nil {
		return
	}
	x.SType = (StructureType)(x.ref9a72b107.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref9a72b107.pNext))
	x.Image = *(*Image)(unsafe.Pointer(&x.ref9a72b107.image))
	x.Buffer = *(*Buffer)(unsafe.Pointer(&x.ref9a72b107.buffer))
}

// allocImageViewHandleInfoNVXMemory allocates memory for type C.VkImageViewHandleInfoNVX in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageViewHandleInfoNVXMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageViewHandleInfoNVXValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfImageViewHandleInfoNVXValue = unsafe.Sizeof([1]C.VkImageViewHandleInfoNVX{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImageViewHandleInfoNVX) Ref() *C.VkImageViewHandleInfoNVX {
	if x == nil {
		return nil
	}
	return x.refc283b384
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImageViewHandleInfoNVX) Free() {
	if x != nil && x.allocsc283b384 != nil {
		x.allocsc283b384.(*cgoAllocMap).Free()
		x.refc283b384 = nil
	}
}

// NewImageViewHandleInfoNVXRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageViewHandleInfoNVXRef(ref unsafe.Pointer) *ImageViewHandleInfoNVX {
	if ref == nil {
		return nil
	}
	obj := new(ImageViewHandleInfoNVX)
	obj.refc283b384 = (*C.VkImageViewHandleInfoNVX)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImageViewHandleInfoNVX) PassRef() (*C.VkImageViewHandleInfoNVX, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc283b384 != nil {
		return x.refc283b384, nil
	}
	memc283b384 := allocImageViewHandleInfoNVXMemory(1)
	refc283b384 := (*C.VkImageViewHandleInfoNVX)(memc283b384)
	allocsc283b384 := new(cgoAllocMap)
	allocsc283b384.Add(memc283b384)

	refc283b384.sType = (C.VkStructureType)(x.SType)

	refc283b384.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	refc283b384.imageView = *(*C.VkImageView)(unsafe.Pointer(&x.ImageView))

	refc283b384.descriptorType = (C.VkDescriptorType)(x.DescriptorType)

	refc283b384.sampler = *(*C.VkSampler)(unsafe.Pointer(&x.Sampler))

	x.refc283b384 = refc283b384
	x.allocsc283b384 = allocsc283b384
	return refc283b384, allocsc283b384

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImageViewHandleInfoNVX) PassValue() (C.VkImageViewHandleInfoNVX, *cgoAllocMap) {
	if x.refc283b384 != nil {
		return *x.refc283b384, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImageViewHandleInfoNVX) Deref() {
	if x.refc283b384 == nil {
		return
	}
	x.SType = (StructureType)(x.refc283b384.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refc283b384.pNext))
	x.ImageView = *(*ImageView)(unsafe.Pointer(&x.refc283b384.imageView))
	x.DescriptorType = (DescriptorType)(x.refc283b384.descriptorType)
	x.Sampler = *(*Sampler)(unsafe.Pointer(&x.refc283b384.sampler))
}

// allocValidationFlagsMemory allocates memory for type C.VkValidationFlagsEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocValidationFlagsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfValidationFlagsValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfValidationFlagsValue = unsafe.Sizeof([1]C.VkValidationFlagsEXT{})

// copyPValidationCheckBytes copies the data from Go slice as *C.VkValidationCheckEXT.
func copyPValidationCheckBytes(slice *sliceHeader) (*C.VkValidationCheckEXT, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfValidationCheckValue) * slice.Len,
		Cap:  int(sizeOfValidationCheckValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkValidationCheckEXT)(mem0), allocs
}

// allocValidationCheckMemory allocates memory for type C.VkValidationCheckEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocValidationCheckMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfValidationCheckValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfValidationCheckValue = unsafe.Sizeof([1]C.VkValidationCheckEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ValidationFlags) Ref() *C.VkValidationFlagsEXT {
	if x == nil {
		return nil
	}
	return x.refffe080ad
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ValidationFlags) Free() {
	if x != nil && x.allocsffe080ad != nil {
		x.allocsffe080ad.(*cgoAllocMap).Free()
		x.refffe080ad = nil
	}
}

// NewValidationFlagsRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewValidationFlagsRef(ref unsafe.Pointer) *ValidationFlags {
	if ref == nil {
		return nil
	}
	obj := new(ValidationFlags)
	obj.refffe080ad = (*C.VkValidationFlagsEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ValidationFlags) PassRef() (*C.VkValidationFlagsEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refffe080ad != nil {
		return x.refffe080ad, nil
	}
	memffe080ad := allocValidationFlagsMemory(1)
	refffe080ad := (*C.VkValidationFlagsEXT)(memffe080ad)
	allocsffe080ad := new(cgoAllocMap)
	allocsffe080ad.Add(memffe080ad)

	refffe080ad.sType = (C.VkStructureType)(x.SType)

	refffe080ad.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	refffe080ad.disabledValidationCheckCount = (C.uint32_t)(x.DisabledValidationCheckCount)

	if x.PDisabledValidationChecks != nil {
		var cpDisabledValidationChecks_allocs *cgoAllocMap
		refffe080ad.pDisabledValidationChecks, cpDisabledValidationChecks_allocs = copyPValidationCheckBytes((*sliceHeader)(unsafe.Pointer(&x.PDisabledValidationChecks)))
		allocsffe080ad.Borrow(cpDisabledValidationChecks_allocs)
	}

	x.refffe080ad = refffe080ad
	x.allocsffe080ad = allocsffe080ad
	return refffe080ad, allocsffe080ad

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ValidationFlags) PassValue() (C.VkValidationFlagsEXT, *cgoAllocMap) {
	if x.refffe080ad != nil {
		return *x.refffe080ad, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ValidationFlags) Deref() {
	if x.refffe080ad == nil {
		return
	}
	x.SType = (StructureType)(x.refffe080ad.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refffe080ad.pNext))
	x.DisabledValidationCheckCount = (uint32)(x.refffe080ad.disabledValidationCheckCount)
	hxf6301b1 := (*sliceHeader)(unsafe.Pointer(&x.PDisabledValidationChecks))
	hxf6301b1.Data = unsafe.Pointer(x.refffe080ad.pDisabledValidationChecks)
	hxf6301b1.Cap = 0x7fffffff
	// hxf6301b1.Len = ? x.PDisabledValidationChecks x.refffe080ad.pDisabledValidationChecks

}

// allocConditionalRenderingBeginInfoMemory allocates memory for type C.VkConditionalRenderingBeginInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocConditionalRenderingBeginInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfConditionalRenderingBeginInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfConditionalRenderingBeginInfoValue = unsafe.Sizeof([1]C.VkConditionalRenderingBeginInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ConditionalRenderingBeginInfo) Ref() *C.VkConditionalRenderingBeginInfoEXT {
	if x == nil {
		return nil
	}
	return x.ref82da87c9
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ConditionalRenderingBeginInfo) Free() {
	if x != nil && x.allocs82da87c9 != nil {
		x.allocs82da87c9.(*cgoAllocMap).Free()
		x.ref82da87c9 = nil
	}
}

// NewConditionalRenderingBeginInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewConditionalRenderingBeginInfoRef(ref unsafe.Pointer) *ConditionalRenderingBeginInfo {
	if ref == nil {
		return nil
	}
	obj := new(ConditionalRenderingBeginInfo)
	obj.ref82da87c9 = (*C.VkConditionalRenderingBeginInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ConditionalRenderingBeginInfo) PassRef() (*C.VkConditionalRenderingBeginInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref82da87c9 != nil {
		return x.ref82da87c9, nil
	}
	mem82da87c9 := allocConditionalRenderingBeginInfoMemory(1)
	ref82da87c9 := (*C.VkConditionalRenderingBeginInfoEXT)(mem82da87c9)
	allocs82da87c9 := new(cgoAllocMap)
	allocs82da87c9.Add(mem82da87c9)

	ref82da87c9.sType = (C.VkStructureType)(x.SType)

	ref82da87c9.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref82da87c9.buffer = *(*C.VkBuffer)(unsafe.Pointer(&x.Buffer))

	ref82da87c9.offset = (C.VkDeviceSize)(x.Offset)

	ref82da87c9.flags = (C.VkConditionalRenderingFlagsEXT)(x.Flags)

	x.ref82da87c9 = ref82da87c9
	x.allocs82da87c9 = allocs82da87c9
	return ref82da87c9, allocs82da87c9

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ConditionalRenderingBeginInfo) PassValue() (C.VkConditionalRenderingBeginInfoEXT, *cgoAllocMap) {
	if x.ref82da87c9 != nil {
		return *x.ref82da87c9, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ConditionalRenderingBeginInfo) Deref() {
	if x.ref82da87c9 == nil {
		return
	}
	x.SType = (StructureType)(x.ref82da87c9.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref82da87c9.pNext))
	x.Buffer = *(*Buffer)(unsafe.Pointer(&x.ref82da87c9.buffer))
	x.Offset = (DeviceSize)(x.ref82da87c9.offset)
	x.Flags = (ConditionalRenderingFlags)(x.ref82da87c9.flags)
}

// allocPipelineViewportWScalingStateCreateInfoNVMemory allocates memory for type C.VkPipelineViewportWScalingStateCreateInfoNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineViewportWScalingStateCreateInfoNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineViewportWScalingStateCreateInfoNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPipelineViewportWScalingStateCreateInfoNVValue = unsafe.Sizeof([1]C.VkPipelineViewportWScalingStateCreateInfoNV{})

// copyPViewportWScalingNVBytes copies the data from Go slice as *C.VkViewportWScalingNV.
func copyPViewportWScalingNVBytes(slice *sliceHeader) (*C.VkViewportWScalingNV, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfViewportWScalingNVValue) * slice.Len,
		Cap:  int(sizeOfViewportWScalingNVValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkViewportWScalingNV)(mem0), allocs
}

// allocViewportWScalingNVMemory allocates memory for type C.VkViewportWScalingNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocViewportWScalingNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfViewportWScalingNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfViewportWScalingNVValue = unsafe.Sizeof([1]C.VkViewportWScalingNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineViewportWScalingStateCreateInfoNV) Ref() *C.VkPipelineViewportWScalingStateCreateInfoNV {
	if x == nil {
		return nil
	}
	return x.ref3e532c0b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineViewportWScalingStateCreateInfoNV) Free() {
	if x != nil && x.allocs3e532c0b != nil {
		x.allocs3e532c0b.(*cgoAllocMap).Free()
		x.ref3e532c0b = nil
	}
}

// NewPipelineViewportWScalingStateCreateInfoNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineViewportWScalingStateCreateInfoNVRef(ref unsafe.Pointer) *PipelineViewportWScalingStateCreateInfoNV {
	if ref == nil {
		return nil
	}
	obj := new(PipelineViewportWScalingStateCreateInfoNV)
	obj.ref3e532c0b = (*C.VkPipelineViewportWScalingStateCreateInfoNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineViewportWScalingStateCreateInfoNV) PassRef() (*C.VkPipelineViewportWScalingStateCreateInfoNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3e532c0b != nil {
		return x.ref3e532c0b, nil
	}
	mem3e532c0b := allocPipelineViewportWScalingStateCreateInfoNVMemory(1)
	ref3e532c0b := (*C.VkPipelineViewportWScalingStateCreateInfoNV)(mem3e532c0b)
	allocs3e532c0b := new(cgoAllocMap)
	allocs3e532c0b.Add(mem3e532c0b)

	ref3e532c0b.sType = (C.VkStructureType)(x.SType)

	ref3e532c0b.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref3e532c0b.viewportWScalingEnable = (C.VkBool32)(x.ViewportWScalingEnable)

	ref3e532c0b.viewportCount = (C.uint32_t)(x.ViewportCount)

	if x.PViewportWScalings != nil {
		var cpViewportWScalings_allocs *cgoAllocMap
		ref3e532c0b.pViewportWScalings, cpViewportWScalings_allocs = copyPViewportWScalingNVBytes((*sliceHeader)(unsafe.Pointer(&x.PViewportWScalings)))
		allocs3e532c0b.Borrow(cpViewportWScalings_allocs)
	}

	x.ref3e532c0b = ref3e532c0b
	x.allocs3e532c0b = allocs3e532c0b
	return ref3e532c0b, allocs3e532c0b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineViewportWScalingStateCreateInfoNV) PassValue() (C.VkPipelineViewportWScalingStateCreateInfoNV, *cgoAllocMap) {
	if x.ref3e532c0b != nil {
		return *x.ref3e532c0b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineViewportWScalingStateCreateInfoNV) Deref() {
	if x.ref3e532c0b == nil {
		return
	}
	x.SType = (StructureType)(x.ref3e532c0b.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref3e532c0b.pNext))
	x.ViewportWScalingEnable = (Bool32)(x.ref3e532c0b.viewportWScalingEnable)
	x.ViewportCount = (uint32)(x.ref3e532c0b.viewportCount)
	hxfb2b86e := (*sliceHeader)(unsafe.Pointer(&x.PViewportWScalings))
	hxfb2b86e.Data = unsafe.Pointer(x.ref3e532c0b.pViewportWScalings)
	hxfb2b86e.Cap = 0x7fffffff
	// hxfb2b86e.Len = ? x.PViewportWScalings x.ref3e532c0b.pViewportWScalings

}

// allocPresentTimesInfoGOOGLEMemory allocates memory for type C.VkPresentTimesInfoGOOGLE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPresentTimesInfoGOOGLEMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPresentTimesInfoGOOGLEValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPresentTimesInfoGOOGLEValue = unsafe.Sizeof([1]C.VkPresentTimesInfoGOOGLE{})

// copyPPresentTimeGOOGLEBytes copies the data from Go slice as *C.VkPresentTimeGOOGLE.
func copyPPresentTimeGOOGLEBytes(slice *sliceHeader) (*C.VkPresentTimeGOOGLE, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfPresentTimeGOOGLEValue) * slice.Len,
		Cap:  int(sizeOfPresentTimeGOOGLEValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkPresentTimeGOOGLE)(mem0), allocs
}

// allocPresentTimeGOOGLEMemory allocates memory for type C.VkPresentTimeGOOGLE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPresentTimeGOOGLEMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPresentTimeGOOGLEValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPresentTimeGOOGLEValue = unsafe.Sizeof([1]C.VkPresentTimeGOOGLE{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PresentTimesInfoGOOGLE) Ref() *C.VkPresentTimesInfoGOOGLE {
	if x == nil {
		return nil
	}
	return x.ref70eb8ab3
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PresentTimesInfoGOOGLE) Free() {
	if x != nil && x.allocs70eb8ab3 != nil {
		x.allocs70eb8ab3.(*cgoAllocMap).Free()
		x.ref70eb8ab3 = nil
	}
}

// NewPresentTimesInfoGOOGLERef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPresentTimesInfoGOOGLERef(ref unsafe.Pointer) *PresentTimesInfoGOOGLE {
	if ref == nil {
		return nil
	}
	obj := new(PresentTimesInfoGOOGLE)
	obj.ref70eb8ab3 = (*C.VkPresentTimesInfoGOOGLE)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PresentTimesInfoGOOGLE) PassRef() (*C.VkPresentTimesInfoGOOGLE, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref70eb8ab3 != nil {
		return x.ref70eb8ab3, nil
	}
	mem70eb8ab3 := allocPresentTimesInfoGOOGLEMemory(1)
	ref70eb8ab3 := (*C.VkPresentTimesInfoGOOGLE)(mem70eb8ab3)
	allocs70eb8ab3 := new(cgoAllocMap)
	allocs70eb8ab3.Add(mem70eb8ab3)

	ref70eb8ab3.sType = (C.VkStructureType)(x.SType)

	ref70eb8ab3.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref70eb8ab3.swapchainCount = (C.uint32_t)(x.SwapchainCount)

	if x.PTimes != nil {
		var cpTimes_allocs *cgoAllocMap
		ref70eb8ab3.pTimes, cpTimes_allocs = copyPPresentTimeGOOGLEBytes((*sliceHeader)(unsafe.Pointer(&x.PTimes)))
		allocs70eb8ab3.Borrow(cpTimes_allocs)
	}

	x.ref70eb8ab3 = ref70eb8ab3
	x.allocs70eb8ab3 = allocs70eb8ab3
	return ref70eb8ab3, allocs70eb8ab3

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PresentTimesInfoGOOGLE) PassValue() (C.VkPresentTimesInfoGOOGLE, *cgoAllocMap) {
	if x.ref70eb8ab3 != nil {
		return *x.ref70eb8ab3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PresentTimesInfoGOOGLE) Deref() {
	if x.ref70eb8ab3 == nil {
		return
	}
	x.SType = (StructureType)(x.ref70eb8ab3.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref70eb8ab3.pNext))
	x.SwapchainCount = (uint32)(x.ref70eb8ab3.swapchainCount)
	hxfe8254a := (*sliceHeader)(unsafe.Pointer(&x.PTimes))
	hxfe8254a.Data = unsafe.Pointer(x.ref70eb8ab3.pTimes)
	hxfe8254a.Cap = 0x7fffffff
	// hxfe8254a.Len = ? x.PTimes x.ref70eb8ab3.pTimes

}

// allocPipelineViewportSwizzleStateCreateInfoNVMemory allocates memory for type C.VkPipelineViewportSwizzleStateCreateInfoNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineViewportSwizzleStateCreateInfoNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineViewportSwizzleStateCreateInfoNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPipelineViewportSwizzleStateCreateInfoNVValue = unsafe.Sizeof([1]C.VkPipelineViewportSwizzleStateCreateInfoNV{})

// copyPViewportSwizzleNVBytes copies the data from Go slice as *C.VkViewportSwizzleNV.
func copyPViewportSwizzleNVBytes(slice *sliceHeader) (*C.VkViewportSwizzleNV, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfViewportSwizzleNVValue) * slice.Len,
		Cap:  int(sizeOfViewportSwizzleNVValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkViewportSwizzleNV)(mem0), allocs
}

// allocViewportSwizzleNVMemory allocates memory for type C.VkViewportSwizzleNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocViewportSwizzleNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfViewportSwizzleNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfViewportSwizzleNVValue = unsafe.Sizeof([1]C.VkViewportSwizzleNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineViewportSwizzleStateCreateInfoNV) Ref() *C.VkPipelineViewportSwizzleStateCreateInfoNV {
	if x == nil {
		return nil
	}
	return x.ref5e90f24
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineViewportSwizzleStateCreateInfoNV) Free() {
	if x != nil && x.allocs5e90f24 != nil {
		x.allocs5e90f24.(*cgoAllocMap).Free()
		x.ref5e90f24 = nil
	}
}

// NewPipelineViewportSwizzleStateCreateInfoNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineViewportSwizzleStateCreateInfoNVRef(ref unsafe.Pointer) *PipelineViewportSwizzleStateCreateInfoNV {
	if ref == nil {
		return nil
	}
	obj := new(PipelineViewportSwizzleStateCreateInfoNV)
	obj.ref5e90f24 = (*C.VkPipelineViewportSwizzleStateCreateInfoNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineViewportSwizzleStateCreateInfoNV) PassRef() (*C.VkPipelineViewportSwizzleStateCreateInfoNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5e90f24 != nil {
		return x.ref5e90f24, nil
	}
	mem5e90f24 := allocPipelineViewportSwizzleStateCreateInfoNVMemory(1)
	ref5e90f24 := (*C.VkPipelineViewportSwizzleStateCreateInfoNV)(mem5e90f24)
	allocs5e90f24 := new(cgoAllocMap)
	allocs5e90f24.Add(mem5e90f24)

	ref5e90f24.sType = (C.VkStructureType)(x.SType)

	ref5e90f24.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref5e90f24.flags = (C.VkPipelineViewportSwizzleStateCreateFlagsNV)(x.Flags)

	ref5e90f24.viewportCount = (C.uint32_t)(x.ViewportCount)

	if x.PViewportSwizzles != nil {
		var cpViewportSwizzles_allocs *cgoAllocMap
		ref5e90f24.pViewportSwizzles, cpViewportSwizzles_allocs = copyPViewportSwizzleNVBytes((*sliceHeader)(unsafe.Pointer(&x.PViewportSwizzles)))
		allocs5e90f24.Borrow(cpViewportSwizzles_allocs)
	}

	x.ref5e90f24 = ref5e90f24
	x.allocs5e90f24 = allocs5e90f24
	return ref5e90f24, allocs5e90f24

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineViewportSwizzleStateCreateInfoNV) PassValue() (C.VkPipelineViewportSwizzleStateCreateInfoNV, *cgoAllocMap) {
	if x.ref5e90f24 != nil {
		return *x.ref5e90f24, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineViewportSwizzleStateCreateInfoNV) Deref() {
	if x.ref5e90f24 == nil {
		return
	}
	x.SType = (StructureType)(x.ref5e90f24.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref5e90f24.pNext))
	x.Flags = (PipelineViewportSwizzleStateCreateFlagsNV)(x.ref5e90f24.flags)
	x.ViewportCount = (uint32)(x.ref5e90f24.viewportCount)
	hxf1c615c := (*sliceHeader)(unsafe.Pointer(&x.PViewportSwizzles))
	hxf1c615c.Data = unsafe.Pointer(x.ref5e90f24.pViewportSwizzles)
	hxf1c615c.Cap = 0x7fffffff
	// hxf1c615c.Len = ? x.PViewportSwizzles x.ref5e90f24.pViewportSwizzles

}

// allocPipelineDiscardRectangleStateCreateInfoMemory allocates memory for type C.VkPipelineDiscardRectangleStateCreateInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineDiscardRectangleStateCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineDiscardRectangleStateCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPipelineDiscardRectangleStateCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineDiscardRectangleStateCreateInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineDiscardRectangleStateCreateInfo) Ref() *C.VkPipelineDiscardRectangleStateCreateInfoEXT {
	if x == nil {
		return nil
	}
	return x.refcdbb125e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineDiscardRectangleStateCreateInfo) Free() {
	if x != nil && x.allocscdbb125e != nil {
		x.allocscdbb125e.(*cgoAllocMap).Free()
		x.refcdbb125e = nil
	}
}

// NewPipelineDiscardRectangleStateCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineDiscardRectangleStateCreateInfoRef(ref unsafe.Pointer) *PipelineDiscardRectangleStateCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineDiscardRectangleStateCreateInfo)
	obj.refcdbb125e = (*C.VkPipelineDiscardRectangleStateCreateInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineDiscardRectangleStateCreateInfo) PassRef() (*C.VkPipelineDiscardRectangleStateCreateInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refcdbb125e != nil {
		return x.refcdbb125e, nil
	}
	memcdbb125e := allocPipelineDiscardRectangleStateCreateInfoMemory(1)
	refcdbb125e := (*C.VkPipelineDiscardRectangleStateCreateInfoEXT)(memcdbb125e)
	allocscdbb125e := new(cgoAllocMap)
	allocscdbb125e.Add(memcdbb125e)

	refcdbb125e.sType = (C.VkStructureType)(x.SType)

	refcdbb125e.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	refcdbb125e.flags = (C.VkPipelineDiscardRectangleStateCreateFlagsEXT)(x.Flags)

	refcdbb125e.discardRectangleMode = (C.VkDiscardRectangleModeEXT)(x.DiscardRectangleMode)

	refcdbb125e.discardRectangleCount = (C.uint32_t)(x.DiscardRectangleCount)

	if x.PDiscardRectangles != nil {
		var cpDiscardRectangles_allocs *cgoAllocMap
		refcdbb125e.pDiscardRectangles, cpDiscardRectangles_allocs = copyPRect2DBytes((*sliceHeader)(unsafe.Pointer(&x.PDiscardRectangles)))
		allocscdbb125e.Borrow(cpDiscardRectangles_allocs)
	}

	x.refcdbb125e = refcdbb125e
	x.allocscdbb125e = allocscdbb125e
	return refcdbb125e, allocscdbb125e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineDiscardRectangleStateCreateInfo) PassValue() (C.VkPipelineDiscardRectangleStateCreateInfoEXT, *cgoAllocMap) {
	if x.refcdbb125e != nil {
		return *x.refcdbb125e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineDiscardRectangleStateCreateInfo) Deref() {
	if x.refcdbb125e == nil {
		return
	}
	x.SType = (StructureType)(x.refcdbb125e.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refcdbb125e.pNext))
	x.Flags = (PipelineDiscardRectangleStateCreateFlags)(x.refcdbb125e.flags)
	x.DiscardRectangleMode = (DiscardRectangleMode)(x.refcdbb125e.discardRectangleMode)
	x.DiscardRectangleCount = (uint32)(x.refcdbb125e.discardRectangleCount)
	hxf1ab1b2 := (*sliceHeader)(unsafe.Pointer(&x.PDiscardRectangles))
	hxf1ab1b2.Data = unsafe.Pointer(x.refcdbb125e.pDiscardRectangles)
	hxf1ab1b2.Cap = 0x7fffffff
	// hxf1ab1b2.Len = ? x.PDiscardRectangles x.refcdbb125e.pDiscardRectangles

}

// allocDebugUtilsLabelMemory allocates memory for type C.VkDebugUtilsLabelEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDebugUtilsLabelMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDebugUtilsLabelValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDebugUtilsLabelValue = unsafe.Sizeof([1]C.VkDebugUtilsLabelEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DebugUtilsLabel) Ref() *C.VkDebugUtilsLabelEXT {
	if x == nil {
		return nil
	}
	return x.ref8faaf7b1
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DebugUtilsLabel) Free() {
	if x != nil && x.allocs8faaf7b1 != nil {
		x.allocs8faaf7b1.(*cgoAllocMap).Free()
		x.ref8faaf7b1 = nil
	}
}

// NewDebugUtilsLabelRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDebugUtilsLabelRef(ref unsafe.Pointer) *DebugUtilsLabel {
	if ref == nil {
		return nil
	}
	obj := new(DebugUtilsLabel)
	obj.ref8faaf7b1 = (*C.VkDebugUtilsLabelEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DebugUtilsLabel) PassRef() (*C.VkDebugUtilsLabelEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref8faaf7b1 != nil {
		return x.ref8faaf7b1, nil
	}
	mem8faaf7b1 := allocDebugUtilsLabelMemory(1)
	ref8faaf7b1 := (*C.VkDebugUtilsLabelEXT)(mem8faaf7b1)
	allocs8faaf7b1 := new(cgoAllocMap)
	allocs8faaf7b1.Add(mem8faaf7b1)

	ref8faaf7b1.sType = (C.VkStructureType)(x.SType)

	ref8faaf7b1.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	var cpLabelName_allocs *cgoAllocMap
	ref8faaf7b1.pLabelName, cpLabelName_allocs = copyPCharBytes((*sliceHeader)(unsafe.Pointer(&x.PLabelName)))
	allocs8faaf7b1.Borrow(cpLabelName_allocs)

	ref8faaf7b1.color = *(*[4]C.float)(unsafe.Pointer(&x.Color))

	x.ref8faaf7b1 = ref8faaf7b1
	x.allocs8faaf7b1 = allocs8faaf7b1
	return ref8faaf7b1, allocs8faaf7b1

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DebugUtilsLabel) PassValue() (C.VkDebugUtilsLabelEXT, *cgoAllocMap) {
	if x.ref8faaf7b1 != nil {
		return *x.ref8faaf7b1, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DebugUtilsLabel) Deref() {
	if x.ref8faaf7b1 == nil {
		return
	}
	x.SType = (StructureType)(x.ref8faaf7b1.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref8faaf7b1.pNext))
	hxfbbed48 := (*sliceHeader)(unsafe.Pointer(&x.PLabelName))
	hxfbbed48.Data = unsafe.Pointer(x.ref8faaf7b1.pLabelName)
	hxfbbed48.Cap = 0x7fffffff
	// hxfbbed48.Len = ? x.PLabelName x.ref8faaf7b1.pLabelName

	x.Color = *(*[4]float32)(unsafe.Pointer(&x.ref8faaf7b1.color))
}

// allocDebugUtilsObjectNameInfoMemory allocates memory for type C.VkDebugUtilsObjectNameInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDebugUtilsObjectNameInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDebugUtilsObjectNameInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDebugUtilsObjectNameInfoValue = unsafe.Sizeof([1]C.VkDebugUtilsObjectNameInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DebugUtilsObjectNameInfo) Ref() *C.VkDebugUtilsObjectNameInfoEXT {
	if x == nil {
		return nil
	}
	return x.ref5e73c2db
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DebugUtilsObjectNameInfo) Free() {
	if x != nil && x.allocs5e73c2db != nil {
		x.allocs5e73c2db.(*cgoAllocMap).Free()
		x.ref5e73c2db = nil
	}
}

// NewDebugUtilsObjectNameInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDebugUtilsObjectNameInfoRef(ref unsafe.Pointer) *DebugUtilsObjectNameInfo {
	if ref == nil {
		return nil
	}
	obj := new(DebugUtilsObjectNameInfo)
	obj.ref5e73c2db = (*C.VkDebugUtilsObjectNameInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DebugUtilsObjectNameInfo) PassRef() (*C.VkDebugUtilsObjectNameInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5e73c2db != nil {
		return x.ref5e73c2db, nil
	}
	mem5e73c2db := allocDebugUtilsObjectNameInfoMemory(1)
	ref5e73c2db := (*C.VkDebugUtilsObjectNameInfoEXT)(mem5e73c2db)
	allocs5e73c2db := new(cgoAllocMap)
	allocs5e73c2db.Add(mem5e73c2db)

	ref5e73c2db.sType = (C.VkStructureType)(x.SType)

	ref5e73c2db.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref5e73c2db.objectType = (C.VkObjectType)(x.ObjectType)

	ref5e73c2db.objectHandle = (C.uint64_t)(x.ObjectHandle)

	var cpObjectName_allocs *cgoAllocMap
	ref5e73c2db.pObjectName, cpObjectName_allocs = copyPCharBytes((*sliceHeader)(unsafe.Pointer(&x.PObjectName)))
	allocs5e73c2db.Borrow(cpObjectName_allocs)

	x.ref5e73c2db = ref5e73c2db
	x.allocs5e73c2db = allocs5e73c2db
	return ref5e73c2db, allocs5e73c2db

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DebugUtilsObjectNameInfo) PassValue() (C.VkDebugUtilsObjectNameInfoEXT, *cgoAllocMap) {
	if x.ref5e73c2db != nil {
		return *x.ref5e73c2db, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DebugUtilsObjectNameInfo) Deref() {
	if x.ref5e73c2db == nil {
		return
	}
	x.SType = (StructureType)(x.ref5e73c2db.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref5e73c2db.pNext))
	x.ObjectType = (ObjectType)(x.ref5e73c2db.objectType)
	x.ObjectHandle = (uint64)(x.ref5e73c2db.objectHandle)
	hxf9cdd70 := (*sliceHeader)(unsafe.Pointer(&x.PObjectName))
	hxf9cdd70.Data = unsafe.Pointer(x.ref5e73c2db.pObjectName)
	hxf9cdd70.Cap = 0x7fffffff
	// hxf9cdd70.Len = ? x.PObjectName x.ref5e73c2db.pObjectName

}

// allocSampleLocationsInfoMemory allocates memory for type C.VkSampleLocationsInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSampleLocationsInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSampleLocationsInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSampleLocationsInfoValue = unsafe.Sizeof([1]C.VkSampleLocationsInfoEXT{})

// copyPSampleLocationBytes copies the data from Go slice as *C.VkSampleLocationEXT.
func copyPSampleLocationBytes(slice *sliceHeader) (*C.VkSampleLocationEXT, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfSampleLocationValue) * slice.Len,
		Cap:  int(sizeOfSampleLocationValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkSampleLocationEXT)(mem0), allocs
}

// allocSampleLocationMemory allocates memory for type C.VkSampleLocationEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSampleLocationMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSampleLocationValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSampleLocationValue = unsafe.Sizeof([1]C.VkSampleLocationEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SampleLocationsInfo) Ref() *C.VkSampleLocationsInfoEXT {
	if x == nil {
		return nil
	}
	return x.refd8f3bd2d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SampleLocationsInfo) Free() {
	if x != nil && x.allocsd8f3bd2d != nil {
		x.allocsd8f3bd2d.(*cgoAllocMap).Free()
		x.refd8f3bd2d = nil
	}
}

// NewSampleLocationsInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSampleLocationsInfoRef(ref unsafe.Pointer) *SampleLocationsInfo {
	if ref == nil {
		return nil
	}
	obj := new(SampleLocationsInfo)
	obj.refd8f3bd2d = (*C.VkSampleLocationsInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SampleLocationsInfo) PassRef() (*C.VkSampleLocationsInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd8f3bd2d != nil {
		return x.refd8f3bd2d, nil
	}
	memd8f3bd2d := allocSampleLocationsInfoMemory(1)
	refd8f3bd2d := (*C.VkSampleLocationsInfoEXT)(memd8f3bd2d)
	allocsd8f3bd2d := new(cgoAllocMap)
	allocsd8f3bd2d.Add(memd8f3bd2d)

	refd8f3bd2d.sType = (C.VkStructureType)(x.SType)

	refd8f3bd2d.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	refd8f3bd2d.sampleLocationsPerPixel = (C.VkSampleCountFlagBits)(x.SampleLocationsPerPixel)

	refd8f3bd2d.sampleLocationGridSize = *(*C.VkExtent2D)(unsafe.Pointer(&x.SampleLocationGridSize))

	refd8f3bd2d.sampleLocationsCount = (C.uint32_t)(x.SampleLocationsCount)

	if x.PSampleLocations != nil {
		var cpSampleLocations_allocs *cgoAllocMap
		refd8f3bd2d.pSampleLocations, cpSampleLocations_allocs = copyPSampleLocationBytes((*sliceHeader)(unsafe.Pointer(&x.PSampleLocations)))
		allocsd8f3bd2d.Borrow(cpSampleLocations_allocs)
	}

	x.refd8f3bd2d = refd8f3bd2d
	x.allocsd8f3bd2d = allocsd8f3bd2d
	return refd8f3bd2d, allocsd8f3bd2d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SampleLocationsInfo) PassValue() (C.VkSampleLocationsInfoEXT, *cgoAllocMap) {
	if x.refd8f3bd2d != nil {
		return *x.refd8f3bd2d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SampleLocationsInfo) Deref() {
	if x.refd8f3bd2d == nil {
		return
	}
	x.SType = (StructureType)(x.refd8f3bd2d.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refd8f3bd2d.pNext))
	x.SampleLocationsPerPixel = (SampleCountFlagBits)(x.refd8f3bd2d.sampleLocationsPerPixel)
	x.SampleLocationGridSize = *(*Extent2D)(unsafe.Pointer(&x.refd8f3bd2d.sampleLocationGridSize))
	x.SampleLocationsCount = (uint32)(x.refd8f3bd2d.sampleLocationsCount)
	hxf84a54f := (*sliceHeader)(unsafe.Pointer(&x.PSampleLocations))
	hxf84a54f.Data = unsafe.Pointer(x.refd8f3bd2d.pSampleLocations)
	hxf84a54f.Cap = 0x7fffffff
	// hxf84a54f.Len = ? x.PSampleLocations x.refd8f3bd2d.pSampleLocations

}

// allocAttachmentSampleLocationsMemory allocates memory for type C.VkAttachmentSampleLocationsEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAttachmentSampleLocationsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAttachmentSampleLocationsValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfAttachmentSampleLocationsValue = unsafe.Sizeof([1]C.VkAttachmentSampleLocationsEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *AttachmentSampleLocations) Ref() *C.VkAttachmentSampleLocationsEXT {
	if x == nil {
		return nil
	}
	return x.ref6a3dd41e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *AttachmentSampleLocations) Free() {
	if x != nil && x.allocs6a3dd41e != nil {
		x.allocs6a3dd41e.(*cgoAllocMap).Free()
		x.ref6a3dd41e = nil
	}
}

// NewAttachmentSampleLocationsRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewAttachmentSampleLocationsRef(ref unsafe.Pointer) *AttachmentSampleLocations {
	if ref == nil {
		return nil
	}
	obj := new(AttachmentSampleLocations)
	obj.ref6a3dd41e = (*C.VkAttachmentSampleLocationsEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *AttachmentSampleLocations) PassRef() (*C.VkAttachmentSampleLocationsEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6a3dd41e != nil {
		return x.ref6a3dd41e, nil
	}
	mem6a3dd41e := allocAttachmentSampleLocationsMemory(1)
	ref6a3dd41e := (*C.VkAttachmentSampleLocationsEXT)(mem6a3dd41e)
	allocs6a3dd41e := new(cgoAllocMap)
	allocs6a3dd41e.Add(mem6a3dd41e)

	ref6a3dd41e.attachmentIndex = (C.uint32_t)(x.AttachmentIndex)

	var csampleLocationsInfo_allocs *cgoAllocMap
	ref6a3dd41e.sampleLocationsInfo, csampleLocationsInfo_allocs = x.SampleLocationsInfo.PassValue()
	allocs6a3dd41e.Borrow(csampleLocationsInfo_allocs)

	x.ref6a3dd41e = ref6a3dd41e
	x.allocs6a3dd41e = allocs6a3dd41e
	return ref6a3dd41e, allocs6a3dd41e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x AttachmentSampleLocations) PassValue() (C.VkAttachmentSampleLocationsEXT, *cgoAllocMap) {
	if x.ref6a3dd41e != nil {
		return *x.ref6a3dd41e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *AttachmentSampleLocations) Deref() {
	if x.ref6a3dd41e == nil {
		return
	}
	x.AttachmentIndex = (uint32)(x.ref6a3dd41e.attachmentIndex)
	x.SampleLocationsInfo = *NewSampleLocationsInfoRef(unsafe.Pointer(&x.ref6a3dd41e.sampleLocationsInfo))
}

// allocSubpassSampleLocationsMemory allocates memory for type C.VkSubpassSampleLocationsEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSubpassSampleLocationsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSubpassSampleLocationsValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSubpassSampleLocationsValue = unsafe.Sizeof([1]C.VkSubpassSampleLocationsEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SubpassSampleLocations) Ref() *C.VkSubpassSampleLocationsEXT {
	if x == nil {
		return nil
	}
	return x.ref1f612812
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SubpassSampleLocations) Free() {
	if x != nil && x.allocs1f612812 != nil {
		x.allocs1f612812.(*cgoAllocMap).Free()
		x.ref1f612812 = nil
	}
}

// NewSubpassSampleLocationsRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSubpassSampleLocationsRef(ref unsafe.Pointer) *SubpassSampleLocations {
	if ref == nil {
		return nil
	}
	obj := new(SubpassSampleLocations)
	obj.ref1f612812 = (*C.VkSubpassSampleLocationsEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SubpassSampleLocations) PassRef() (*C.VkSubpassSampleLocationsEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1f612812 != nil {
		return x.ref1f612812, nil
	}
	mem1f612812 := allocSubpassSampleLocationsMemory(1)
	ref1f612812 := (*C.VkSubpassSampleLocationsEXT)(mem1f612812)
	allocs1f612812 := new(cgoAllocMap)
	allocs1f612812.Add(mem1f612812)

	ref1f612812.subpassIndex = (C.uint32_t)(x.SubpassIndex)

	var csampleLocationsInfo_allocs *cgoAllocMap
	ref1f612812.sampleLocationsInfo, csampleLocationsInfo_allocs = x.SampleLocationsInfo.PassValue()
	allocs1f612812.Borrow(csampleLocationsInfo_allocs)

	x.ref1f612812 = ref1f612812
	x.allocs1f612812 = allocs1f612812
	return ref1f612812, allocs1f612812

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SubpassSampleLocations) PassValue() (C.VkSubpassSampleLocationsEXT, *cgoAllocMap) {
	if x.ref1f612812 != nil {
		return *x.ref1f612812, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SubpassSampleLocations) Deref() {
	if x.ref1f612812 == nil {
		return
	}
	x.SubpassIndex = (uint32)(x.ref1f612812.subpassIndex)
	x.SampleLocationsInfo = *NewSampleLocationsInfoRef(unsafe.Pointer(&x.ref1f612812.sampleLocationsInfo))
}

// allocRenderPassSampleLocationsBeginInfoMemory allocates memory for type C.VkRenderPassSampleLocationsBeginInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRenderPassSampleLocationsBeginInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRenderPassSampleLocationsBeginInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfRenderPassSampleLocationsBeginInfoValue = unsafe.Sizeof([1]C.VkRenderPassSampleLocationsBeginInfoEXT{})

// copyPAttachmentSampleLocationsBytes copies the data from Go slice as *C.VkAttachmentSampleLocationsEXT.
func copyPAttachmentSampleLocationsBytes(slice *sliceHeader) (*C.VkAttachmentSampleLocationsEXT, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfAttachmentSampleLocationsValue) * slice.Len,
		Cap:  int(sizeOfAttachmentSampleLocationsValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkAttachmentSampleLocationsEXT)(mem0), allocs
}

// copyPSubpassSampleLocationsBytes copies the data from Go slice as *C.VkSubpassSampleLocationsEXT.
func copyPSubpassSampleLocationsBytes(slice *sliceHeader) (*C.VkSubpassSampleLocationsEXT, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfSubpassSampleLocationsValue) * slice.Len,
		Cap:  int(sizeOfSubpassSampleLocationsValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkSubpassSampleLocationsEXT)(mem0), allocs
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RenderPassSampleLocationsBeginInfo) Ref() *C.VkRenderPassSampleLocationsBeginInfoEXT {
	if x == nil {
		return nil
	}
	return x.refb61b51d4
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RenderPassSampleLocationsBeginInfo) Free() {
	if x != nil && x.allocsb61b51d4 != nil {
		x.allocsb61b51d4.(*cgoAllocMap).Free()
		x.refb61b51d4 = nil
	}
}

// NewRenderPassSampleLocationsBeginInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRenderPassSampleLocationsBeginInfoRef(ref unsafe.Pointer) *RenderPassSampleLocationsBeginInfo {
	if ref == nil {
		return nil
	}
	obj := new(RenderPassSampleLocationsBeginInfo)
	obj.refb61b51d4 = (*C.VkRenderPassSampleLocationsBeginInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RenderPassSampleLocationsBeginInfo) PassRef() (*C.VkRenderPassSampleLocationsBeginInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb61b51d4 != nil {
		return x.refb61b51d4, nil
	}
	memb61b51d4 := allocRenderPassSampleLocationsBeginInfoMemory(1)
	refb61b51d4 := (*C.VkRenderPassSampleLocationsBeginInfoEXT)(memb61b51d4)
	allocsb61b51d4 := new(cgoAllocMap)
	allocsb61b51d4.Add(memb61b51d4)

	refb61b51d4.sType = (C.VkStructureType)(x.SType)

	refb61b51d4.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	refb61b51d4.attachmentInitialSampleLocationsCount = (C.uint32_t)(x.AttachmentInitialSampleLocationsCount)

	if x.PAttachmentInitialSampleLocations != nil {
		var cpAttachmentInitialSampleLocations_allocs *cgoAllocMap
		refb61b51d4.pAttachmentInitialSampleLocations, cpAttachmentInitialSampleLocations_allocs = copyPAttachmentSampleLocationsBytes((*sliceHeader)(unsafe.Pointer(&x.PAttachmentInitialSampleLocations)))
		allocsb61b51d4.Borrow(cpAttachmentInitialSampleLocations_allocs)
	}

	refb61b51d4.postSubpassSampleLocationsCount = (C.uint32_t)(x.PostSubpassSampleLocationsCount)

	if x.PPostSubpassSampleLocations != nil {
		var cpPostSubpassSampleLocations_allocs *cgoAllocMap
		refb61b51d4.pPostSubpassSampleLocations, cpPostSubpassSampleLocations_allocs = copyPSubpassSampleLocationsBytes((*sliceHeader)(unsafe.Pointer(&x.PPostSubpassSampleLocations)))
		allocsb61b51d4.Borrow(cpPostSubpassSampleLocations_allocs)
	}

	x.refb61b51d4 = refb61b51d4
	x.allocsb61b51d4 = allocsb61b51d4
	return refb61b51d4, allocsb61b51d4

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RenderPassSampleLocationsBeginInfo) PassValue() (C.VkRenderPassSampleLocationsBeginInfoEXT, *cgoAllocMap) {
	if x.refb61b51d4 != nil {
		return *x.refb61b51d4, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *RenderPassSampleLocationsBeginInfo) Deref() {
	if x.refb61b51d4 == nil {
		return
	}
	x.SType = (StructureType)(x.refb61b51d4.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refb61b51d4.pNext))
	x.AttachmentInitialSampleLocationsCount = (uint32)(x.refb61b51d4.attachmentInitialSampleLocationsCount)
	hxf6a06fa := (*sliceHeader)(unsafe.Pointer(&x.PAttachmentInitialSampleLocations))
	hxf6a06fa.Data = unsafe.Pointer(x.refb61b51d4.pAttachmentInitialSampleLocations)
	hxf6a06fa.Cap = 0x7fffffff
	// hxf6a06fa.Len = ? x.PAttachmentInitialSampleLocations x.refb61b51d4.pAttachmentInitialSampleLocations

	x.PostSubpassSampleLocationsCount = (uint32)(x.refb61b51d4.postSubpassSampleLocationsCount)
	hxf5ba44e := (*sliceHeader)(unsafe.Pointer(&x.PPostSubpassSampleLocations))
	hxf5ba44e.Data = unsafe.Pointer(x.refb61b51d4.pPostSubpassSampleLocations)
	hxf5ba44e.Cap = 0x7fffffff
	// hxf5ba44e.Len = ? x.PPostSubpassSampleLocations x.refb61b51d4.pPostSubpassSampleLocations

}

// allocPipelineSampleLocationsStateCreateInfoMemory allocates memory for type C.VkPipelineSampleLocationsStateCreateInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineSampleLocationsStateCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineSampleLocationsStateCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPipelineSampleLocationsStateCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineSampleLocationsStateCreateInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineSampleLocationsStateCreateInfo) Ref() *C.VkPipelineSampleLocationsStateCreateInfoEXT {
	if x == nil {
		return nil
	}
	return x.ref93a2968f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineSampleLocationsStateCreateInfo) Free() {
	if x != nil && x.allocs93a2968f != nil {
		x.allocs93a2968f.(*cgoAllocMap).Free()
		x.ref93a2968f = nil
	}
}

// NewPipelineSampleLocationsStateCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineSampleLocationsStateCreateInfoRef(ref unsafe.Pointer) *PipelineSampleLocationsStateCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineSampleLocationsStateCreateInfo)
	obj.ref93a2968f = (*C.VkPipelineSampleLocationsStateCreateInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineSampleLocationsStateCreateInfo) PassRef() (*C.VkPipelineSampleLocationsStateCreateInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref93a2968f != nil {
		return x.ref93a2968f, nil
	}
	mem93a2968f := allocPipelineSampleLocationsStateCreateInfoMemory(1)
	ref93a2968f := (*C.VkPipelineSampleLocationsStateCreateInfoEXT)(mem93a2968f)
	allocs93a2968f := new(cgoAllocMap)
	allocs93a2968f.Add(mem93a2968f)

	ref93a2968f.sType = (C.VkStructureType)(x.SType)

	ref93a2968f.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref93a2968f.sampleLocationsEnable = (C.VkBool32)(x.SampleLocationsEnable)

	var csampleLocationsInfo_allocs *cgoAllocMap
	ref93a2968f.sampleLocationsInfo, csampleLocationsInfo_allocs = x.SampleLocationsInfo.PassValue()
	allocs93a2968f.Borrow(csampleLocationsInfo_allocs)

	x.ref93a2968f = ref93a2968f
	x.allocs93a2968f = allocs93a2968f
	return ref93a2968f, allocs93a2968f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineSampleLocationsStateCreateInfo) PassValue() (C.VkPipelineSampleLocationsStateCreateInfoEXT, *cgoAllocMap) {
	if x.ref93a2968f != nil {
		return *x.ref93a2968f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineSampleLocationsStateCreateInfo) Deref() {
	if x.ref93a2968f == nil {
		return
	}
	x.SType = (StructureType)(x.ref93a2968f.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref93a2968f.pNext))
	x.SampleLocationsEnable = (Bool32)(x.ref93a2968f.sampleLocationsEnable)
	x.SampleLocationsInfo = *NewSampleLocationsInfoRef(unsafe.Pointer(&x.ref93a2968f.sampleLocationsInfo))
}

// allocPipelineCoverageModulationStateCreateInfoNVMemory allocates memory for type C.VkPipelineCoverageModulationStateCreateInfoNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineCoverageModulationStateCreateInfoNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineCoverageModulationStateCreateInfoNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPipelineCoverageModulationStateCreateInfoNVValue = unsafe.Sizeof([1]C.VkPipelineCoverageModulationStateCreateInfoNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineCoverageModulationStateCreateInfoNV) Ref() *C.VkPipelineCoverageModulationStateCreateInfoNV {
	if x == nil {
		return nil
	}
	return x.refa081b0ea
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineCoverageModulationStateCreateInfoNV) Free() {
	if x != nil && x.allocsa081b0ea != nil {
		x.allocsa081b0ea.(*cgoAllocMap).Free()
		x.refa081b0ea = nil
	}
}

// NewPipelineCoverageModulationStateCreateInfoNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineCoverageModulationStateCreateInfoNVRef(ref unsafe.Pointer) *PipelineCoverageModulationStateCreateInfoNV {
	if ref == nil {
		return nil
	}
	obj := new(PipelineCoverageModulationStateCreateInfoNV)
	obj.refa081b0ea = (*C.VkPipelineCoverageModulationStateCreateInfoNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineCoverageModulationStateCreateInfoNV) PassRef() (*C.VkPipelineCoverageModulationStateCreateInfoNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa081b0ea != nil {
		return x.refa081b0ea, nil
	}
	mema081b0ea := allocPipelineCoverageModulationStateCreateInfoNVMemory(1)
	refa081b0ea := (*C.VkPipelineCoverageModulationStateCreateInfoNV)(mema081b0ea)
	allocsa081b0ea := new(cgoAllocMap)
	allocsa081b0ea.Add(mema081b0ea)

	refa081b0ea.sType = (C.VkStructureType)(x.SType)

	refa081b0ea.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	refa081b0ea.flags = (C.VkPipelineCoverageModulationStateCreateFlagsNV)(x.Flags)

	refa081b0ea.coverageModulationMode = (C.VkCoverageModulationModeNV)(x.CoverageModulationMode)

	refa081b0ea.coverageModulationTableEnable = (C.VkBool32)(x.CoverageModulationTableEnable)

	refa081b0ea.coverageModulationTableCount = (C.uint32_t)(x.CoverageModulationTableCount)

	if x.PCoverageModulationTable != nil {
		var cpCoverageModulationTable_allocs *cgoAllocMap
		refa081b0ea.pCoverageModulationTable, cpCoverageModulationTable_allocs = copyPFloatBytes((*sliceHeader)(unsafe.Pointer(&x.PCoverageModulationTable)))
		allocsa081b0ea.Borrow(cpCoverageModulationTable_allocs)
	}

	x.refa081b0ea = refa081b0ea
	x.allocsa081b0ea = allocsa081b0ea
	return refa081b0ea, allocsa081b0ea

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineCoverageModulationStateCreateInfoNV) PassValue() (C.VkPipelineCoverageModulationStateCreateInfoNV, *cgoAllocMap) {
	if x.refa081b0ea != nil {
		return *x.refa081b0ea, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineCoverageModulationStateCreateInfoNV) Deref() {
	if x.refa081b0ea == nil {
		return
	}
	x.SType = (StructureType)(x.refa081b0ea.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refa081b0ea.pNext))
	x.Flags = (PipelineCoverageModulationStateCreateFlagsNV)(x.refa081b0ea.flags)
	x.CoverageModulationMode = (CoverageModulationModeNV)(x.refa081b0ea.coverageModulationMode)
	x.CoverageModulationTableEnable = (Bool32)(x.refa081b0ea.coverageModulationTableEnable)
	x.CoverageModulationTableCount = (uint32)(x.refa081b0ea.coverageModulationTableCount)
	hxf1ae993 := (*sliceHeader)(unsafe.Pointer(&x.PCoverageModulationTable))
	hxf1ae993.Data = unsafe.Pointer(x.refa081b0ea.pCoverageModulationTable)
	hxf1ae993.Cap = 0x7fffffff
	// hxf1ae993.Len = ? x.PCoverageModulationTable x.refa081b0ea.pCoverageModulationTable

}

// allocDrmFormatModifierPropertiesListMemory allocates memory for type C.VkDrmFormatModifierPropertiesListEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDrmFormatModifierPropertiesListMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDrmFormatModifierPropertiesListValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDrmFormatModifierPropertiesListValue = unsafe.Sizeof([1]C.VkDrmFormatModifierPropertiesListEXT{})

// copyPDrmFormatModifierPropertiesBytes copies the data from Go slice as *C.VkDrmFormatModifierPropertiesEXT.
func copyPDrmFormatModifierPropertiesBytes(slice *sliceHeader) (*C.VkDrmFormatModifierPropertiesEXT, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfDrmFormatModifierPropertiesValue) * slice.Len,
		Cap:  int(sizeOfDrmFormatModifierPropertiesValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkDrmFormatModifierPropertiesEXT)(mem0), allocs
}

// allocDrmFormatModifierPropertiesMemory allocates memory for type C.VkDrmFormatModifierPropertiesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDrmFormatModifierPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDrmFormatModifierPropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDrmFormatModifierPropertiesValue = unsafe.Sizeof([1]C.VkDrmFormatModifierPropertiesEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DrmFormatModifierPropertiesList) Ref() *C.VkDrmFormatModifierPropertiesListEXT {
	if x == nil {
		return nil
	}
	return x.ref7e3ede2
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DrmFormatModifierPropertiesList) Free() {
	if x != nil && x.allocs7e3ede2 != nil {
		x.allocs7e3ede2.(*cgoAllocMap).Free()
		x.ref7e3ede2 = nil
	}
}

// NewDrmFormatModifierPropertiesListRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDrmFormatModifierPropertiesListRef(ref unsafe.Pointer) *DrmFormatModifierPropertiesList {
	if ref == nil {
		return nil
	}
	obj := new(DrmFormatModifierPropertiesList)
	obj.ref7e3ede2 = (*C.VkDrmFormatModifierPropertiesListEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DrmFormatModifierPropertiesList) PassRef() (*C.VkDrmFormatModifierPropertiesListEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7e3ede2 != nil {
		return x.ref7e3ede2, nil
	}
	mem7e3ede2 := allocDrmFormatModifierPropertiesListMemory(1)
	ref7e3ede2 := (*C.VkDrmFormatModifierPropertiesListEXT)(mem7e3ede2)
	allocs7e3ede2 := new(cgoAllocMap)
	allocs7e3ede2.Add(mem7e3ede2)

	ref7e3ede2.sType = (C.VkStructureType)(x.SType)

	ref7e3ede2.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref7e3ede2.drmFormatModifierCount = (C.uint32_t)(x.DrmFormatModifierCount)

	if x.PDrmFormatModifierProperties != nil {
		var cpDrmFormatModifierProperties_allocs *cgoAllocMap
		ref7e3ede2.pDrmFormatModifierProperties, cpDrmFormatModifierProperties_allocs = copyPDrmFormatModifierPropertiesBytes((*sliceHeader)(unsafe.Pointer(&x.PDrmFormatModifierProperties)))
		allocs7e3ede2.Borrow(cpDrmFormatModifierProperties_allocs)
	}

	x.ref7e3ede2 = ref7e3ede2
	x.allocs7e3ede2 = allocs7e3ede2
	return ref7e3ede2, allocs7e3ede2

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DrmFormatModifierPropertiesList) PassValue() (C.VkDrmFormatModifierPropertiesListEXT, *cgoAllocMap) {
	if x.ref7e3ede2 != nil {
		return *x.ref7e3ede2, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DrmFormatModifierPropertiesList) Deref() {
	if x.ref7e3ede2 == nil {
		return
	}
	x.SType = (StructureType)(x.ref7e3ede2.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref7e3ede2.pNext))
	x.DrmFormatModifierCount = (uint32)(x.ref7e3ede2.drmFormatModifierCount)
	hxf250a52 := (*sliceHeader)(unsafe.Pointer(&x.PDrmFormatModifierProperties))
	hxf250a52.Data = unsafe.Pointer(x.ref7e3ede2.pDrmFormatModifierProperties)
	hxf250a52.Cap = 0x7fffffff
	// hxf250a52.Len = ? x.PDrmFormatModifierProperties x.ref7e3ede2.pDrmFormatModifierProperties

}

// allocPhysicalDeviceImageDrmFormatModifierInfoMemory allocates memory for type C.VkPhysicalDeviceImageDrmFormatModifierInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicalDeviceImageDrmFormatModifierInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicalDeviceImageDrmFormatModifierInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPhysicalDeviceImageDrmFormatModifierInfoValue = unsafe.Sizeof([1]C.VkPhysicalDeviceImageDrmFormatModifierInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicalDeviceImageDrmFormatModifierInfo) Ref() *C.VkPhysicalDeviceImageDrmFormatModifierInfoEXT {
	if x == nil {
		return nil
	}
	return x.refd7abef44
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicalDeviceImageDrmFormatModifierInfo) Free() {
	if x != nil && x.allocsd7abef44 != nil {
		x.allocsd7abef44.(*cgoAllocMap).Free()
		x.refd7abef44 = nil
	}
}

// NewPhysicalDeviceImageDrmFormatModifierInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicalDeviceImageDrmFormatModifierInfoRef(ref unsafe.Pointer) *PhysicalDeviceImageDrmFormatModifierInfo {
	if ref == nil {
		return nil
	}
	obj := new(PhysicalDeviceImageDrmFormatModifierInfo)
	obj.refd7abef44 = (*C.VkPhysicalDeviceImageDrmFormatModifierInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicalDeviceImageDrmFormatModifierInfo) PassRef() (*C.VkPhysicalDeviceImageDrmFormatModifierInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd7abef44 != nil {
		return x.refd7abef44, nil
	}
	memd7abef44 := allocPhysicalDeviceImageDrmFormatModifierInfoMemory(1)
	refd7abef44 := (*C.VkPhysicalDeviceImageDrmFormatModifierInfoEXT)(memd7abef44)
	allocsd7abef44 := new(cgoAllocMap)
	allocsd7abef44.Add(memd7abef44)

	refd7abef44.sType = (C.VkStructureType)(x.SType)

	refd7abef44.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	refd7abef44.drmFormatModifier = (C.uint64_t)(x.DrmFormatModifier)

	refd7abef44.sharingMode = (C.VkSharingMode)(x.SharingMode)

	refd7abef44.queueFamilyIndexCount = (C.uint32_t)(x.QueueFamilyIndexCount)

	if x.PQueueFamilyIndices != nil {
		var cpQueueFamilyIndices_allocs *cgoAllocMap
		refd7abef44.pQueueFamilyIndices, cpQueueFamilyIndices_allocs = copyPUint32_tBytes((*sliceHeader)(unsafe.Pointer(&x.PQueueFamilyIndices)))
		allocsd7abef44.Borrow(cpQueueFamilyIndices_allocs)
	}

	x.refd7abef44 = refd7abef44
	x.allocsd7abef44 = allocsd7abef44
	return refd7abef44, allocsd7abef44

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicalDeviceImageDrmFormatModifierInfo) PassValue() (C.VkPhysicalDeviceImageDrmFormatModifierInfoEXT, *cgoAllocMap) {
	if x.refd7abef44 != nil {
		return *x.refd7abef44, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PhysicalDeviceImageDrmFormatModifierInfo) Deref() {
	if x.refd7abef44 == nil {
		return
	}
	x.SType = (StructureType)(x.refd7abef44.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refd7abef44.pNext))
	x.DrmFormatModifier = (uint64)(x.refd7abef44.drmFormatModifier)
	x.SharingMode = (SharingMode)(x.refd7abef44.sharingMode)
	x.QueueFamilyIndexCount = (uint32)(x.refd7abef44.queueFamilyIndexCount)
	hxfe21083 := (*sliceHeader)(unsafe.Pointer(&x.PQueueFamilyIndices))
	hxfe21083.Data = unsafe.Pointer(x.refd7abef44.pQueueFamilyIndices)
	hxfe21083.Cap = 0x7fffffff
	// hxfe21083.Len = ? x.PQueueFamilyIndices x.refd7abef44.pQueueFamilyIndices

}

// allocImageDrmFormatModifierListCreateInfoMemory allocates memory for type C.VkImageDrmFormatModifierListCreateInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageDrmFormatModifierListCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageDrmFormatModifierListCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfImageDrmFormatModifierListCreateInfoValue = unsafe.Sizeof([1]C.VkImageDrmFormatModifierListCreateInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImageDrmFormatModifierListCreateInfo) Ref() *C.VkImageDrmFormatModifierListCreateInfoEXT {
	if x == nil {
		return nil
	}
	return x.ref544538ab
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImageDrmFormatModifierListCreateInfo) Free() {
	if x != nil && x.allocs544538ab != nil {
		x.allocs544538ab.(*cgoAllocMap).Free()
		x.ref544538ab = nil
	}
}

// NewImageDrmFormatModifierListCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageDrmFormatModifierListCreateInfoRef(ref unsafe.Pointer) *ImageDrmFormatModifierListCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(ImageDrmFormatModifierListCreateInfo)
	obj.ref544538ab = (*C.VkImageDrmFormatModifierListCreateInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImageDrmFormatModifierListCreateInfo) PassRef() (*C.VkImageDrmFormatModifierListCreateInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref544538ab != nil {
		return x.ref544538ab, nil
	}
	mem544538ab := allocImageDrmFormatModifierListCreateInfoMemory(1)
	ref544538ab := (*C.VkImageDrmFormatModifierListCreateInfoEXT)(mem544538ab)
	allocs544538ab := new(cgoAllocMap)
	allocs544538ab.Add(mem544538ab)

	ref544538ab.sType = (C.VkStructureType)(x.SType)

	ref544538ab.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref544538ab.drmFormatModifierCount = (C.uint32_t)(x.DrmFormatModifierCount)

	if x.PDrmFormatModifiers != nil {
		var cpDrmFormatModifiers_allocs *cgoAllocMap
		ref544538ab.pDrmFormatModifiers, cpDrmFormatModifiers_allocs = copyPUint64_tBytes((*sliceHeader)(unsafe.Pointer(&x.PDrmFormatModifiers)))
		allocs544538ab.Borrow(cpDrmFormatModifiers_allocs)
	}

	x.ref544538ab = ref544538ab
	x.allocs544538ab = allocs544538ab
	return ref544538ab, allocs544538ab

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImageDrmFormatModifierListCreateInfo) PassValue() (C.VkImageDrmFormatModifierListCreateInfoEXT, *cgoAllocMap) {
	if x.ref544538ab != nil {
		return *x.ref544538ab, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImageDrmFormatModifierListCreateInfo) Deref() {
	if x.ref544538ab == nil {
		return
	}
	x.SType = (StructureType)(x.ref544538ab.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref544538ab.pNext))
	x.DrmFormatModifierCount = (uint32)(x.ref544538ab.drmFormatModifierCount)
	hxf9c9c15 := (*sliceHeader)(unsafe.Pointer(&x.PDrmFormatModifiers))
	hxf9c9c15.Data = unsafe.Pointer(x.ref544538ab.pDrmFormatModifiers)
	hxf9c9c15.Cap = 0x7fffffff
	// hxf9c9c15.Len = ? x.PDrmFormatModifiers x.ref544538ab.pDrmFormatModifiers

}

// allocImageDrmFormatModifierExplicitCreateInfoMemory allocates memory for type C.VkImageDrmFormatModifierExplicitCreateInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageDrmFormatModifierExplicitCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageDrmFormatModifierExplicitCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfImageDrmFormatModifierExplicitCreateInfoValue = unsafe.Sizeof([1]C.VkImageDrmFormatModifierExplicitCreateInfoEXT{})

// copyPSubresourceLayoutBytes copies the data from Go slice as *C.VkSubresourceLayout.
func copyPSubresourceLayoutBytes(slice *sliceHeader) (*C.VkSubresourceLayout, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfSubresourceLayoutValue) * slice.Len,
		Cap:  int(sizeOfSubresourceLayoutValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkSubresourceLayout)(mem0), allocs
}

// allocSubresourceLayoutMemory allocates memory for type C.VkSubresourceLayout in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSubresourceLayoutMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSubresourceLayoutValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSubresourceLayoutValue = unsafe.Sizeof([1]C.VkSubresourceLayout{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImageDrmFormatModifierExplicitCreateInfo) Ref() *C.VkImageDrmFormatModifierExplicitCreateInfoEXT {
	if x == nil {
		return nil
	}
	return x.ref8fb45ca9
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImageDrmFormatModifierExplicitCreateInfo) Free() {
	if x != nil && x.allocs8fb45ca9 != nil {
		x.allocs8fb45ca9.(*cgoAllocMap).Free()
		x.ref8fb45ca9 = nil
	}
}

// NewImageDrmFormatModifierExplicitCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageDrmFormatModifierExplicitCreateInfoRef(ref unsafe.Pointer) *ImageDrmFormatModifierExplicitCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(ImageDrmFormatModifierExplicitCreateInfo)
	obj.ref8fb45ca9 = (*C.VkImageDrmFormatModifierExplicitCreateInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImageDrmFormatModifierExplicitCreateInfo) PassRef() (*C.VkImageDrmFormatModifierExplicitCreateInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref8fb45ca9 != nil {
		return x.ref8fb45ca9, nil
	}
	mem8fb45ca9 := allocImageDrmFormatModifierExplicitCreateInfoMemory(1)
	ref8fb45ca9 := (*C.VkImageDrmFormatModifierExplicitCreateInfoEXT)(mem8fb45ca9)
	allocs8fb45ca9 := new(cgoAllocMap)
	allocs8fb45ca9.Add(mem8fb45ca9)

	ref8fb45ca9.sType = (C.VkStructureType)(x.SType)

	ref8fb45ca9.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref8fb45ca9.drmFormatModifier = (C.uint64_t)(x.DrmFormatModifier)

	ref8fb45ca9.drmFormatModifierPlaneCount = (C.uint32_t)(x.DrmFormatModifierPlaneCount)

	if x.PPlaneLayouts != nil {
		var cpPlaneLayouts_allocs *cgoAllocMap
		ref8fb45ca9.pPlaneLayouts, cpPlaneLayouts_allocs = copyPSubresourceLayoutBytes((*sliceHeader)(unsafe.Pointer(&x.PPlaneLayouts)))
		allocs8fb45ca9.Borrow(cpPlaneLayouts_allocs)
	}

	x.ref8fb45ca9 = ref8fb45ca9
	x.allocs8fb45ca9 = allocs8fb45ca9
	return ref8fb45ca9, allocs8fb45ca9

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImageDrmFormatModifierExplicitCreateInfo) PassValue() (C.VkImageDrmFormatModifierExplicitCreateInfoEXT, *cgoAllocMap) {
	if x.ref8fb45ca9 != nil {
		return *x.ref8fb45ca9, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImageDrmFormatModifierExplicitCreateInfo) Deref() {
	if x.ref8fb45ca9 == nil {
		return
	}
	x.SType = (StructureType)(x.ref8fb45ca9.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref8fb45ca9.pNext))
	x.DrmFormatModifier = (uint64)(x.ref8fb45ca9.drmFormatModifier)
	x.DrmFormatModifierPlaneCount = (uint32)(x.ref8fb45ca9.drmFormatModifierPlaneCount)
	hxfa3a85e := (*sliceHeader)(unsafe.Pointer(&x.PPlaneLayouts))
	hxfa3a85e.Data = unsafe.Pointer(x.ref8fb45ca9.pPlaneLayouts)
	hxfa3a85e.Cap = 0x7fffffff
	// hxfa3a85e.Len = ? x.PPlaneLayouts x.ref8fb45ca9.pPlaneLayouts

}

// allocDrmFormatModifierPropertiesList2Memory allocates memory for type C.VkDrmFormatModifierPropertiesList2EXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDrmFormatModifierPropertiesList2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDrmFormatModifierPropertiesList2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDrmFormatModifierPropertiesList2Value = unsafe.Sizeof([1]C.VkDrmFormatModifierPropertiesList2EXT{})

// copyPDrmFormatModifierProperties2Bytes copies the data from Go slice as *C.VkDrmFormatModifierProperties2EXT.
func copyPDrmFormatModifierProperties2Bytes(slice *sliceHeader) (*C.VkDrmFormatModifierProperties2EXT, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfDrmFormatModifierProperties2Value) * slice.Len,
		Cap:  int(sizeOfDrmFormatModifierProperties2Value) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkDrmFormatModifierProperties2EXT)(mem0), allocs
}

// allocDrmFormatModifierProperties2Memory allocates memory for type C.VkDrmFormatModifierProperties2EXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDrmFormatModifierProperties2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDrmFormatModifierProperties2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDrmFormatModifierProperties2Value = unsafe.Sizeof([1]C.VkDrmFormatModifierProperties2EXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DrmFormatModifierPropertiesList2) Ref() *C.VkDrmFormatModifierPropertiesList2EXT {
	if x == nil {
		return nil
	}
	return x.refbea4fdd3
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DrmFormatModifierPropertiesList2) Free() {
	if x != nil && x.allocsbea4fdd3 != nil {
		x.allocsbea4fdd3.(*cgoAllocMap).Free()
		x.refbea4fdd3 = nil
	}
}

// NewDrmFormatModifierPropertiesList2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDrmFormatModifierPropertiesList2Ref(ref unsafe.Pointer) *DrmFormatModifierPropertiesList2 {
	if ref == nil {
		return nil
	}
	obj := new(DrmFormatModifierPropertiesList2)
	obj.refbea4fdd3 = (*C.VkDrmFormatModifierPropertiesList2EXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DrmFormatModifierPropertiesList2) PassRef() (*C.VkDrmFormatModifierPropertiesList2EXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refbea4fdd3 != nil {
		return x.refbea4fdd3, nil
	}
	membea4fdd3 := allocDrmFormatModifierPropertiesList2Memory(1)
	refbea4fdd3 := (*C.VkDrmFormatModifierPropertiesList2EXT)(membea4fdd3)
	allocsbea4fdd3 := new(cgoAllocMap)
	allocsbea4fdd3.Add(membea4fdd3)

	refbea4fdd3.sType = (C.VkStructureType)(x.SType)

	refbea4fdd3.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	refbea4fdd3.drmFormatModifierCount = (C.uint32_t)(x.DrmFormatModifierCount)

	if x.PDrmFormatModifierProperties != nil {
		var cpDrmFormatModifierProperties_allocs *cgoAllocMap
		refbea4fdd3.pDrmFormatModifierProperties, cpDrmFormatModifierProperties_allocs = copyPDrmFormatModifierProperties2Bytes((*sliceHeader)(unsafe.Pointer(&x.PDrmFormatModifierProperties)))
		allocsbea4fdd3.Borrow(cpDrmFormatModifierProperties_allocs)
	}

	x.refbea4fdd3 = refbea4fdd3
	x.allocsbea4fdd3 = allocsbea4fdd3
	return refbea4fdd3, allocsbea4fdd3

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DrmFormatModifierPropertiesList2) PassValue() (C.VkDrmFormatModifierPropertiesList2EXT, *cgoAllocMap) {
	if x.refbea4fdd3 != nil {
		return *x.refbea4fdd3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DrmFormatModifierPropertiesList2) Deref() {
	if x.refbea4fdd3 == nil {
		return
	}
	x.SType = (StructureType)(x.refbea4fdd3.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refbea4fdd3.pNext))
	x.DrmFormatModifierCount = (uint32)(x.refbea4fdd3.drmFormatModifierCount)
	hxf2b7090 := (*sliceHeader)(unsafe.Pointer(&x.PDrmFormatModifierProperties))
	hxf2b7090.Data = unsafe.Pointer(x.refbea4fdd3.pDrmFormatModifierProperties)
	hxf2b7090.Cap = 0x7fffffff
	// hxf2b7090.Len = ? x.PDrmFormatModifierProperties x.refbea4fdd3.pDrmFormatModifierProperties

}

// allocShaderModuleValidationCacheCreateInfoMemory allocates memory for type C.VkShaderModuleValidationCacheCreateInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocShaderModuleValidationCacheCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfShaderModuleValidationCacheCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfShaderModuleValidationCacheCreateInfoValue = unsafe.Sizeof([1]C.VkShaderModuleValidationCacheCreateInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ShaderModuleValidationCacheCreateInfo) Ref() *C.VkShaderModuleValidationCacheCreateInfoEXT {
	if x == nil {
		return nil
	}
	return x.ref37065f24
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ShaderModuleValidationCacheCreateInfo) Free() {
	if x != nil && x.allocs37065f24 != nil {
		x.allocs37065f24.(*cgoAllocMap).Free()
		x.ref37065f24 = nil
	}
}

// NewShaderModuleValidationCacheCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewShaderModuleValidationCacheCreateInfoRef(ref unsafe.Pointer) *ShaderModuleValidationCacheCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(ShaderModuleValidationCacheCreateInfo)
	obj.ref37065f24 = (*C.VkShaderModuleValidationCacheCreateInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ShaderModuleValidationCacheCreateInfo) PassRef() (*C.VkShaderModuleValidationCacheCreateInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref37065f24 != nil {
		return x.ref37065f24, nil
	}
	mem37065f24 := allocShaderModuleValidationCacheCreateInfoMemory(1)
	ref37065f24 := (*C.VkShaderModuleValidationCacheCreateInfoEXT)(mem37065f24)
	allocs37065f24 := new(cgoAllocMap)
	allocs37065f24.Add(mem37065f24)

	ref37065f24.sType = (C.VkStructureType)(x.SType)

	ref37065f24.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref37065f24.validationCache = *(*C.VkValidationCacheEXT)(unsafe.Pointer(&x.ValidationCache))

	x.ref37065f24 = ref37065f24
	x.allocs37065f24 = allocs37065f24
	return ref37065f24, allocs37065f24

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ShaderModuleValidationCacheCreateInfo) PassValue() (C.VkShaderModuleValidationCacheCreateInfoEXT, *cgoAllocMap) {
	if x.ref37065f24 != nil {
		return *x.ref37065f24, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ShaderModuleValidationCacheCreateInfo) Deref() {
	if x.ref37065f24 == nil {
		return
	}
	x.SType = (StructureType)(x.ref37065f24.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref37065f24.pNext))
	x.ValidationCache = *(*ValidationCache)(unsafe.Pointer(&x.ref37065f24.validationCache))
}

// allocShadingRatePaletteNVMemory allocates memory for type C.VkShadingRatePaletteNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocShadingRatePaletteNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfShadingRatePaletteNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfShadingRatePaletteNVValue = unsafe.Sizeof([1]C.VkShadingRatePaletteNV{})

// copyPShadingRatePaletteEntryNVBytes copies the data from Go slice as *C.VkShadingRatePaletteEntryNV.
func copyPShadingRatePaletteEntryNVBytes(slice *sliceHeader) (*C.VkShadingRatePaletteEntryNV, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfShadingRatePaletteEntryNVValue) * slice.Len,
		Cap:  int(sizeOfShadingRatePaletteEntryNVValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkShadingRatePaletteEntryNV)(mem0), allocs
}

// allocShadingRatePaletteEntryNVMemory allocates memory for type C.VkShadingRatePaletteEntryNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocShadingRatePaletteEntryNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfShadingRatePaletteEntryNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfShadingRatePaletteEntryNVValue = unsafe.Sizeof([1]C.VkShadingRatePaletteEntryNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ShadingRatePaletteNV) Ref() *C.VkShadingRatePaletteNV {
	if x == nil {
		return nil
	}
	return x.refa5c4ae3a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ShadingRatePaletteNV) Free() {
	if x != nil && x.allocsa5c4ae3a != nil {
		x.allocsa5c4ae3a.(*cgoAllocMap).Free()
		x.refa5c4ae3a = nil
	}
}

// NewShadingRatePaletteNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewShadingRatePaletteNVRef(ref unsafe.Pointer) *ShadingRatePaletteNV {
	if ref == nil {
		return nil
	}
	obj := new(ShadingRatePaletteNV)
	obj.refa5c4ae3a = (*C.VkShadingRatePaletteNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ShadingRatePaletteNV) PassRef() (*C.VkShadingRatePaletteNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa5c4ae3a != nil {
		return x.refa5c4ae3a, nil
	}
	mema5c4ae3a := allocShadingRatePaletteNVMemory(1)
	refa5c4ae3a := (*C.VkShadingRatePaletteNV)(mema5c4ae3a)
	allocsa5c4ae3a := new(cgoAllocMap)
	allocsa5c4ae3a.Add(mema5c4ae3a)

	refa5c4ae3a.shadingRatePaletteEntryCount = (C.uint32_t)(x.ShadingRatePaletteEntryCount)

	if x.PShadingRatePaletteEntries != nil {
		var cpShadingRatePaletteEntries_allocs *cgoAllocMap
		refa5c4ae3a.pShadingRatePaletteEntries, cpShadingRatePaletteEntries_allocs = copyPShadingRatePaletteEntryNVBytes((*sliceHeader)(unsafe.Pointer(&x.PShadingRatePaletteEntries)))
		allocsa5c4ae3a.Borrow(cpShadingRatePaletteEntries_allocs)
	}

	x.refa5c4ae3a = refa5c4ae3a
	x.allocsa5c4ae3a = allocsa5c4ae3a
	return refa5c4ae3a, allocsa5c4ae3a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ShadingRatePaletteNV) PassValue() (C.VkShadingRatePaletteNV, *cgoAllocMap) {
	if x.refa5c4ae3a != nil {
		return *x.refa5c4ae3a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ShadingRatePaletteNV) Deref() {
	if x.refa5c4ae3a == nil {
		return
	}
	x.ShadingRatePaletteEntryCount = (uint32)(x.refa5c4ae3a.shadingRatePaletteEntryCount)
	hxf000188 := (*sliceHeader)(unsafe.Pointer(&x.PShadingRatePaletteEntries))
	hxf000188.Data = unsafe.Pointer(x.refa5c4ae3a.pShadingRatePaletteEntries)
	hxf000188.Cap = 0x7fffffff
	// hxf000188.Len = ? x.PShadingRatePaletteEntries x.refa5c4ae3a.pShadingRatePaletteEntries

}

// allocPipelineViewportShadingRateImageStateCreateInfoNVMemory allocates memory for type C.VkPipelineViewportShadingRateImageStateCreateInfoNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineViewportShadingRateImageStateCreateInfoNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineViewportShadingRateImageStateCreateInfoNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPipelineViewportShadingRateImageStateCreateInfoNVValue = unsafe.Sizeof([1]C.VkPipelineViewportShadingRateImageStateCreateInfoNV{})

// unpackSShadingRatePaletteNV transforms a sliced Go data structure into plain C format.
func unpackSShadingRatePaletteNV(x []ShadingRatePaletteNV) (unpacked *C.VkShadingRatePaletteNV, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocShadingRatePaletteNVMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkShadingRatePaletteNV)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkShadingRatePaletteNV)(h.Data)
	return
}

// packSShadingRatePaletteNV reads sliced Go data structure out from plain C format.
func packSShadingRatePaletteNV(v []ShadingRatePaletteNV, ptr0 *C.VkShadingRatePaletteNV) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfShadingRatePaletteNVValue]C.VkShadingRatePaletteNV)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewShadingRatePaletteNVRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineViewportShadingRateImageStateCreateInfoNV) Ref() *C.VkPipelineViewportShadingRateImageStateCreateInfoNV {
	if x == nil {
		return nil
	}
	return x.ref6f2ec732
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineViewportShadingRateImageStateCreateInfoNV) Free() {
	if x != nil && x.allocs6f2ec732 != nil {
		x.allocs6f2ec732.(*cgoAllocMap).Free()
		x.ref6f2ec732 = nil
	}
}

// NewPipelineViewportShadingRateImageStateCreateInfoNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineViewportShadingRateImageStateCreateInfoNVRef(ref unsafe.Pointer) *PipelineViewportShadingRateImageStateCreateInfoNV {
	if ref == nil {
		return nil
	}
	obj := new(PipelineViewportShadingRateImageStateCreateInfoNV)
	obj.ref6f2ec732 = (*C.VkPipelineViewportShadingRateImageStateCreateInfoNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineViewportShadingRateImageStateCreateInfoNV) PassRef() (*C.VkPipelineViewportShadingRateImageStateCreateInfoNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6f2ec732 != nil {
		return x.ref6f2ec732, nil
	}
	mem6f2ec732 := allocPipelineViewportShadingRateImageStateCreateInfoNVMemory(1)
	ref6f2ec732 := (*C.VkPipelineViewportShadingRateImageStateCreateInfoNV)(mem6f2ec732)
	allocs6f2ec732 := new(cgoAllocMap)
	allocs6f2ec732.Add(mem6f2ec732)

	ref6f2ec732.sType = (C.VkStructureType)(x.SType)

	ref6f2ec732.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref6f2ec732.shadingRateImageEnable = (C.VkBool32)(x.ShadingRateImageEnable)

	ref6f2ec732.viewportCount = (C.uint32_t)(x.ViewportCount)

	var cpShadingRatePalettes_allocs *cgoAllocMap
	ref6f2ec732.pShadingRatePalettes, cpShadingRatePalettes_allocs = unpackSShadingRatePaletteNV(x.PShadingRatePalettes)
	allocs6f2ec732.Borrow(cpShadingRatePalettes_allocs)

	x.ref6f2ec732 = ref6f2ec732
	x.allocs6f2ec732 = allocs6f2ec732
	return ref6f2ec732, allocs6f2ec732

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineViewportShadingRateImageStateCreateInfoNV) PassValue() (C.VkPipelineViewportShadingRateImageStateCreateInfoNV, *cgoAllocMap) {
	if x.ref6f2ec732 != nil {
		return *x.ref6f2ec732, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineViewportShadingRateImageStateCreateInfoNV) Deref() {
	if x.ref6f2ec732 == nil {
		return
	}
	x.SType = (StructureType)(x.ref6f2ec732.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref6f2ec732.pNext))
	x.ShadingRateImageEnable = (Bool32)(x.ref6f2ec732.shadingRateImageEnable)
	x.ViewportCount = (uint32)(x.ref6f2ec732.viewportCount)
	packSShadingRatePaletteNV(x.PShadingRatePalettes, x.ref6f2ec732.pShadingRatePalettes)
}

// allocCoarseSampleOrderCustomNVMemory allocates memory for type C.VkCoarseSampleOrderCustomNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCoarseSampleOrderCustomNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCoarseSampleOrderCustomNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCoarseSampleOrderCustomNVValue = unsafe.Sizeof([1]C.VkCoarseSampleOrderCustomNV{})

// copyPCoarseSampleLocationNVBytes copies the data from Go slice as *C.VkCoarseSampleLocationNV.
func copyPCoarseSampleLocationNVBytes(slice *sliceHeader) (*C.VkCoarseSampleLocationNV, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfCoarseSampleLocationNVValue) * slice.Len,
		Cap:  int(sizeOfCoarseSampleLocationNVValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkCoarseSampleLocationNV)(mem0), allocs
}

// allocCoarseSampleLocationNVMemory allocates memory for type C.VkCoarseSampleLocationNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCoarseSampleLocationNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCoarseSampleLocationNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCoarseSampleLocationNVValue = unsafe.Sizeof([1]C.VkCoarseSampleLocationNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CoarseSampleOrderCustomNV) Ref() *C.VkCoarseSampleOrderCustomNV {
	if x == nil {
		return nil
	}
	return x.ref4524fa09
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CoarseSampleOrderCustomNV) Free() {
	if x != nil && x.allocs4524fa09 != nil {
		x.allocs4524fa09.(*cgoAllocMap).Free()
		x.ref4524fa09 = nil
	}
}

// NewCoarseSampleOrderCustomNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCoarseSampleOrderCustomNVRef(ref unsafe.Pointer) *CoarseSampleOrderCustomNV {
	if ref == nil {
		return nil
	}
	obj := new(CoarseSampleOrderCustomNV)
	obj.ref4524fa09 = (*C.VkCoarseSampleOrderCustomNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CoarseSampleOrderCustomNV) PassRef() (*C.VkCoarseSampleOrderCustomNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4524fa09 != nil {
		return x.ref4524fa09, nil
	}
	mem4524fa09 := allocCoarseSampleOrderCustomNVMemory(1)
	ref4524fa09 := (*C.VkCoarseSampleOrderCustomNV)(mem4524fa09)
	allocs4524fa09 := new(cgoAllocMap)
	allocs4524fa09.Add(mem4524fa09)

	ref4524fa09.shadingRate = (C.VkShadingRatePaletteEntryNV)(x.ShadingRate)

	ref4524fa09.sampleCount = (C.uint32_t)(x.SampleCount)

	ref4524fa09.sampleLocationCount = (C.uint32_t)(x.SampleLocationCount)

	if x.PSampleLocations != nil {
		var cpSampleLocations_allocs *cgoAllocMap
		ref4524fa09.pSampleLocations, cpSampleLocations_allocs = copyPCoarseSampleLocationNVBytes((*sliceHeader)(unsafe.Pointer(&x.PSampleLocations)))
		allocs4524fa09.Borrow(cpSampleLocations_allocs)
	}

	x.ref4524fa09 = ref4524fa09
	x.allocs4524fa09 = allocs4524fa09
	return ref4524fa09, allocs4524fa09

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CoarseSampleOrderCustomNV) PassValue() (C.VkCoarseSampleOrderCustomNV, *cgoAllocMap) {
	if x.ref4524fa09 != nil {
		return *x.ref4524fa09, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CoarseSampleOrderCustomNV) Deref() {
	if x.ref4524fa09 == nil {
		return
	}
	x.ShadingRate = (ShadingRatePaletteEntryNV)(x.ref4524fa09.shadingRate)
	x.SampleCount = (uint32)(x.ref4524fa09.sampleCount)
	x.SampleLocationCount = (uint32)(x.ref4524fa09.sampleLocationCount)
	hxf23c7f0 := (*sliceHeader)(unsafe.Pointer(&x.PSampleLocations))
	hxf23c7f0.Data = unsafe.Pointer(x.ref4524fa09.pSampleLocations)
	hxf23c7f0.Cap = 0x7fffffff
	// hxf23c7f0.Len = ? x.PSampleLocations x.ref4524fa09.pSampleLocations

}

// allocPipelineViewportCoarseSampleOrderStateCreateInfoNVMemory allocates memory for type C.VkPipelineViewportCoarseSampleOrderStateCreateInfoNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineViewportCoarseSampleOrderStateCreateInfoNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineViewportCoarseSampleOrderStateCreateInfoNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPipelineViewportCoarseSampleOrderStateCreateInfoNVValue = unsafe.Sizeof([1]C.VkPipelineViewportCoarseSampleOrderStateCreateInfoNV{})

// unpackSCoarseSampleOrderCustomNV transforms a sliced Go data structure into plain C format.
func unpackSCoarseSampleOrderCustomNV(x []CoarseSampleOrderCustomNV) (unpacked *C.VkCoarseSampleOrderCustomNV, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocCoarseSampleOrderCustomNVMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkCoarseSampleOrderCustomNV)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkCoarseSampleOrderCustomNV)(h.Data)
	return
}

// packSCoarseSampleOrderCustomNV reads sliced Go data structure out from plain C format.
func packSCoarseSampleOrderCustomNV(v []CoarseSampleOrderCustomNV, ptr0 *C.VkCoarseSampleOrderCustomNV) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfCoarseSampleOrderCustomNVValue]C.VkCoarseSampleOrderCustomNV)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewCoarseSampleOrderCustomNVRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineViewportCoarseSampleOrderStateCreateInfoNV) Ref() *C.VkPipelineViewportCoarseSampleOrderStateCreateInfoNV {
	if x == nil {
		return nil
	}
	return x.ref54de8ca6
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineViewportCoarseSampleOrderStateCreateInfoNV) Free() {
	if x != nil && x.allocs54de8ca6 != nil {
		x.allocs54de8ca6.(*cgoAllocMap).Free()
		x.ref54de8ca6 = nil
	}
}

// NewPipelineViewportCoarseSampleOrderStateCreateInfoNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineViewportCoarseSampleOrderStateCreateInfoNVRef(ref unsafe.Pointer) *PipelineViewportCoarseSampleOrderStateCreateInfoNV {
	if ref == nil {
		return nil
	}
	obj := new(PipelineViewportCoarseSampleOrderStateCreateInfoNV)
	obj.ref54de8ca6 = (*C.VkPipelineViewportCoarseSampleOrderStateCreateInfoNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineViewportCoarseSampleOrderStateCreateInfoNV) PassRef() (*C.VkPipelineViewportCoarseSampleOrderStateCreateInfoNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref54de8ca6 != nil {
		return x.ref54de8ca6, nil
	}
	mem54de8ca6 := allocPipelineViewportCoarseSampleOrderStateCreateInfoNVMemory(1)
	ref54de8ca6 := (*C.VkPipelineViewportCoarseSampleOrderStateCreateInfoNV)(mem54de8ca6)
	allocs54de8ca6 := new(cgoAllocMap)
	allocs54de8ca6.Add(mem54de8ca6)

	ref54de8ca6.sType = (C.VkStructureType)(x.SType)

	ref54de8ca6.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref54de8ca6.sampleOrderType = (C.VkCoarseSampleOrderTypeNV)(x.SampleOrderType)

	ref54de8ca6.customSampleOrderCount = (C.uint32_t)(x.CustomSampleOrderCount)

	var cpCustomSampleOrders_allocs *cgoAllocMap
	ref54de8ca6.pCustomSampleOrders, cpCustomSampleOrders_allocs = unpackSCoarseSampleOrderCustomNV(x.PCustomSampleOrders)
	allocs54de8ca6.Borrow(cpCustomSampleOrders_allocs)

	x.ref54de8ca6 = ref54de8ca6
	x.allocs54de8ca6 = allocs54de8ca6
	return ref54de8ca6, allocs54de8ca6

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineViewportCoarseSampleOrderStateCreateInfoNV) PassValue() (C.VkPipelineViewportCoarseSampleOrderStateCreateInfoNV, *cgoAllocMap) {
	if x.ref54de8ca6 != nil {
		return *x.ref54de8ca6, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineViewportCoarseSampleOrderStateCreateInfoNV) Deref() {
	if x.ref54de8ca6 == nil {
		return
	}
	x.SType = (StructureType)(x.ref54de8ca6.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref54de8ca6.pNext))
	x.SampleOrderType = (CoarseSampleOrderTypeNV)(x.ref54de8ca6.sampleOrderType)
	x.CustomSampleOrderCount = (uint32)(x.ref54de8ca6.customSampleOrderCount)
	packSCoarseSampleOrderCustomNV(x.PCustomSampleOrders, x.ref54de8ca6.pCustomSampleOrders)
}

// allocPipelineVertexInputDivisorStateCreateInfoMemory allocates memory for type C.VkPipelineVertexInputDivisorStateCreateInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineVertexInputDivisorStateCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineVertexInputDivisorStateCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPipelineVertexInputDivisorStateCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineVertexInputDivisorStateCreateInfoEXT{})

// copyPVertexInputBindingDivisorDescriptionBytes copies the data from Go slice as *C.VkVertexInputBindingDivisorDescriptionEXT.
func copyPVertexInputBindingDivisorDescriptionBytes(slice *sliceHeader) (*C.VkVertexInputBindingDivisorDescriptionEXT, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfVertexInputBindingDivisorDescriptionValue) * slice.Len,
		Cap:  int(sizeOfVertexInputBindingDivisorDescriptionValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkVertexInputBindingDivisorDescriptionEXT)(mem0), allocs
}

// allocVertexInputBindingDivisorDescriptionMemory allocates memory for type C.VkVertexInputBindingDivisorDescriptionEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVertexInputBindingDivisorDescriptionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVertexInputBindingDivisorDescriptionValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfVertexInputBindingDivisorDescriptionValue = unsafe.Sizeof([1]C.VkVertexInputBindingDivisorDescriptionEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineVertexInputDivisorStateCreateInfo) Ref() *C.VkPipelineVertexInputDivisorStateCreateInfoEXT {
	if x == nil {
		return nil
	}
	return x.ref86096bfd
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineVertexInputDivisorStateCreateInfo) Free() {
	if x != nil && x.allocs86096bfd != nil {
		x.allocs86096bfd.(*cgoAllocMap).Free()
		x.ref86096bfd = nil
	}
}

// NewPipelineVertexInputDivisorStateCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineVertexInputDivisorStateCreateInfoRef(ref unsafe.Pointer) *PipelineVertexInputDivisorStateCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(PipelineVertexInputDivisorStateCreateInfo)
	obj.ref86096bfd = (*C.VkPipelineVertexInputDivisorStateCreateInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineVertexInputDivisorStateCreateInfo) PassRef() (*C.VkPipelineVertexInputDivisorStateCreateInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref86096bfd != nil {
		return x.ref86096bfd, nil
	}
	mem86096bfd := allocPipelineVertexInputDivisorStateCreateInfoMemory(1)
	ref86096bfd := (*C.VkPipelineVertexInputDivisorStateCreateInfoEXT)(mem86096bfd)
	allocs86096bfd := new(cgoAllocMap)
	allocs86096bfd.Add(mem86096bfd)

	ref86096bfd.sType = (C.VkStructureType)(x.SType)

	ref86096bfd.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref86096bfd.vertexBindingDivisorCount = (C.uint32_t)(x.VertexBindingDivisorCount)

	if x.PVertexBindingDivisors != nil {
		var cpVertexBindingDivisors_allocs *cgoAllocMap
		ref86096bfd.pVertexBindingDivisors, cpVertexBindingDivisors_allocs = copyPVertexInputBindingDivisorDescriptionBytes((*sliceHeader)(unsafe.Pointer(&x.PVertexBindingDivisors)))
		allocs86096bfd.Borrow(cpVertexBindingDivisors_allocs)
	}

	x.ref86096bfd = ref86096bfd
	x.allocs86096bfd = allocs86096bfd
	return ref86096bfd, allocs86096bfd

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineVertexInputDivisorStateCreateInfo) PassValue() (C.VkPipelineVertexInputDivisorStateCreateInfoEXT, *cgoAllocMap) {
	if x.ref86096bfd != nil {
		return *x.ref86096bfd, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineVertexInputDivisorStateCreateInfo) Deref() {
	if x.ref86096bfd == nil {
		return
	}
	x.SType = (StructureType)(x.ref86096bfd.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref86096bfd.pNext))
	x.VertexBindingDivisorCount = (uint32)(x.ref86096bfd.vertexBindingDivisorCount)
	hxf750b42 := (*sliceHeader)(unsafe.Pointer(&x.PVertexBindingDivisors))
	hxf750b42.Data = unsafe.Pointer(x.ref86096bfd.pVertexBindingDivisors)
	hxf750b42.Cap = 0x7fffffff
	// hxf750b42.Len = ? x.PVertexBindingDivisors x.ref86096bfd.pVertexBindingDivisors

}

// allocPipelineViewportExclusiveScissorStateCreateInfoNVMemory allocates memory for type C.VkPipelineViewportExclusiveScissorStateCreateInfoNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineViewportExclusiveScissorStateCreateInfoNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineViewportExclusiveScissorStateCreateInfoNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPipelineViewportExclusiveScissorStateCreateInfoNVValue = unsafe.Sizeof([1]C.VkPipelineViewportExclusiveScissorStateCreateInfoNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PipelineViewportExclusiveScissorStateCreateInfoNV) Ref() *C.VkPipelineViewportExclusiveScissorStateCreateInfoNV {
	if x == nil {
		return nil
	}
	return x.refa8715ba6
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PipelineViewportExclusiveScissorStateCreateInfoNV) Free() {
	if x != nil && x.allocsa8715ba6 != nil {
		x.allocsa8715ba6.(*cgoAllocMap).Free()
		x.refa8715ba6 = nil
	}
}

// NewPipelineViewportExclusiveScissorStateCreateInfoNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPipelineViewportExclusiveScissorStateCreateInfoNVRef(ref unsafe.Pointer) *PipelineViewportExclusiveScissorStateCreateInfoNV {
	if ref == nil {
		return nil
	}
	obj := new(PipelineViewportExclusiveScissorStateCreateInfoNV)
	obj.refa8715ba6 = (*C.VkPipelineViewportExclusiveScissorStateCreateInfoNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PipelineViewportExclusiveScissorStateCreateInfoNV) PassRef() (*C.VkPipelineViewportExclusiveScissorStateCreateInfoNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa8715ba6 != nil {
		return x.refa8715ba6, nil
	}
	mema8715ba6 := allocPipelineViewportExclusiveScissorStateCreateInfoNVMemory(1)
	refa8715ba6 := (*C.VkPipelineViewportExclusiveScissorStateCreateInfoNV)(mema8715ba6)
	allocsa8715ba6 := new(cgoAllocMap)
	allocsa8715ba6.Add(mema8715ba6)

	refa8715ba6.sType = (C.VkStructureType)(x.SType)

	refa8715ba6.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	refa8715ba6.exclusiveScissorCount = (C.uint32_t)(x.ExclusiveScissorCount)

	if x.PExclusiveScissors != nil {
		var cpExclusiveScissors_allocs *cgoAllocMap
		refa8715ba6.pExclusiveScissors, cpExclusiveScissors_allocs = copyPRect2DBytes((*sliceHeader)(unsafe.Pointer(&x.PExclusiveScissors)))
		allocsa8715ba6.Borrow(cpExclusiveScissors_allocs)
	}

	x.refa8715ba6 = refa8715ba6
	x.allocsa8715ba6 = allocsa8715ba6
	return refa8715ba6, allocsa8715ba6

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PipelineViewportExclusiveScissorStateCreateInfoNV) PassValue() (C.VkPipelineViewportExclusiveScissorStateCreateInfoNV, *cgoAllocMap) {
	if x.refa8715ba6 != nil {
		return *x.refa8715ba6, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PipelineViewportExclusiveScissorStateCreateInfoNV) Deref() {
	if x.refa8715ba6 == nil {
		return
	}
	x.SType = (StructureType)(x.refa8715ba6.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refa8715ba6.pNext))
	x.ExclusiveScissorCount = (uint32)(x.refa8715ba6.exclusiveScissorCount)
	hxfe6ec59 := (*sliceHeader)(unsafe.Pointer(&x.PExclusiveScissors))
	hxfe6ec59.Data = unsafe.Pointer(x.refa8715ba6.pExclusiveScissors)
	hxfe6ec59.Cap = 0x7fffffff
	// hxfe6ec59.Len = ? x.PExclusiveScissors x.refa8715ba6.pExclusiveScissors

}

// allocPerformanceValueINTELMemory allocates memory for type C.VkPerformanceValueINTEL in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPerformanceValueINTELMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPerformanceValueINTELValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPerformanceValueINTELValue = unsafe.Sizeof([1]C.VkPerformanceValueINTEL{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PerformanceValueINTEL) Ref() *C.VkPerformanceValueINTEL {
	if x == nil {
		return nil
	}
	return x.refe6a134ae
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PerformanceValueINTEL) Free() {
	if x != nil && x.allocse6a134ae != nil {
		x.allocse6a134ae.(*cgoAllocMap).Free()
		x.refe6a134ae = nil
	}
}

// NewPerformanceValueINTELRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPerformanceValueINTELRef(ref unsafe.Pointer) *PerformanceValueINTEL {
	if ref == nil {
		return nil
	}
	obj := new(PerformanceValueINTEL)
	obj.refe6a134ae = (*C.VkPerformanceValueINTEL)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PerformanceValueINTEL) PassRef() (*C.VkPerformanceValueINTEL, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe6a134ae != nil {
		return x.refe6a134ae, nil
	}
	meme6a134ae := allocPerformanceValueINTELMemory(1)
	refe6a134ae := (*C.VkPerformanceValueINTEL)(meme6a134ae)
	allocse6a134ae := new(cgoAllocMap)
	allocse6a134ae.Add(meme6a134ae)

	refe6a134ae._type = (C.VkPerformanceValueTypeINTEL)(x.Type)

	refe6a134ae.data = *(*C.VkPerformanceValueDataINTEL)(unsafe.Pointer(&x.Data))

	x.refe6a134ae = refe6a134ae
	x.allocse6a134ae = allocse6a134ae
	return refe6a134ae, allocse6a134ae

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PerformanceValueINTEL) PassValue() (C.VkPerformanceValueINTEL, *cgoAllocMap) {
	if x.refe6a134ae != nil {
		return *x.refe6a134ae, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PerformanceValueINTEL) Deref() {
	if x.refe6a134ae == nil {
		return
	}
	x.Type = (PerformanceValueTypeINTEL)(x.refe6a134ae._type)
	x.Data = *(*PerformanceValueDataINTEL)(unsafe.Pointer(&x.refe6a134ae.data))
}

// allocValidationFeaturesMemory allocates memory for type C.VkValidationFeaturesEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocValidationFeaturesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfValidationFeaturesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfValidationFeaturesValue = unsafe.Sizeof([1]C.VkValidationFeaturesEXT{})

// copyPValidationFeatureEnableBytes copies the data from Go slice as *C.VkValidationFeatureEnableEXT.
func copyPValidationFeatureEnableBytes(slice *sliceHeader) (*C.VkValidationFeatureEnableEXT, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfValidationFeatureEnableValue) * slice.Len,
		Cap:  int(sizeOfValidationFeatureEnableValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkValidationFeatureEnableEXT)(mem0), allocs
}

// allocValidationFeatureEnableMemory allocates memory for type C.VkValidationFeatureEnableEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocValidationFeatureEnableMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfValidationFeatureEnableValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfValidationFeatureEnableValue = unsafe.Sizeof([1]C.VkValidationFeatureEnableEXT{})

// copyPValidationFeatureDisableBytes copies the data from Go slice as *C.VkValidationFeatureDisableEXT.
func copyPValidationFeatureDisableBytes(slice *sliceHeader) (*C.VkValidationFeatureDisableEXT, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfValidationFeatureDisableValue) * slice.Len,
		Cap:  int(sizeOfValidationFeatureDisableValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkValidationFeatureDisableEXT)(mem0), allocs
}

// allocValidationFeatureDisableMemory allocates memory for type C.VkValidationFeatureDisableEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocValidationFeatureDisableMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfValidationFeatureDisableValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfValidationFeatureDisableValue = unsafe.Sizeof([1]C.VkValidationFeatureDisableEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ValidationFeatures) Ref() *C.VkValidationFeaturesEXT {
	if x == nil {
		return nil
	}
	return x.refcd8794ea
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ValidationFeatures) Free() {
	if x != nil && x.allocscd8794ea != nil {
		x.allocscd8794ea.(*cgoAllocMap).Free()
		x.refcd8794ea = nil
	}
}

// NewValidationFeaturesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewValidationFeaturesRef(ref unsafe.Pointer) *ValidationFeatures {
	if ref == nil {
		return nil
	}
	obj := new(ValidationFeatures)
	obj.refcd8794ea = (*C.VkValidationFeaturesEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ValidationFeatures) PassRef() (*C.VkValidationFeaturesEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refcd8794ea != nil {
		return x.refcd8794ea, nil
	}
	memcd8794ea := allocValidationFeaturesMemory(1)
	refcd8794ea := (*C.VkValidationFeaturesEXT)(memcd8794ea)
	allocscd8794ea := new(cgoAllocMap)
	allocscd8794ea.Add(memcd8794ea)

	refcd8794ea.sType = (C.VkStructureType)(x.SType)

	refcd8794ea.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	refcd8794ea.enabledValidationFeatureCount = (C.uint32_t)(x.EnabledValidationFeatureCount)

	if x.PEnabledValidationFeatures != nil {
		var cpEnabledValidationFeatures_allocs *cgoAllocMap
		refcd8794ea.pEnabledValidationFeatures, cpEnabledValidationFeatures_allocs = copyPValidationFeatureEnableBytes((*sliceHeader)(unsafe.Pointer(&x.PEnabledValidationFeatures)))
		allocscd8794ea.Borrow(cpEnabledValidationFeatures_allocs)
	}

	refcd8794ea.disabledValidationFeatureCount = (C.uint32_t)(x.DisabledValidationFeatureCount)

	if x.PDisabledValidationFeatures != nil {
		var cpDisabledValidationFeatures_allocs *cgoAllocMap
		refcd8794ea.pDisabledValidationFeatures, cpDisabledValidationFeatures_allocs = copyPValidationFeatureDisableBytes((*sliceHeader)(unsafe.Pointer(&x.PDisabledValidationFeatures)))
		allocscd8794ea.Borrow(cpDisabledValidationFeatures_allocs)
	}

	x.refcd8794ea = refcd8794ea
	x.allocscd8794ea = allocscd8794ea
	return refcd8794ea, allocscd8794ea

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ValidationFeatures) PassValue() (C.VkValidationFeaturesEXT, *cgoAllocMap) {
	if x.refcd8794ea != nil {
		return *x.refcd8794ea, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ValidationFeatures) Deref() {
	if x.refcd8794ea == nil {
		return
	}
	x.SType = (StructureType)(x.refcd8794ea.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refcd8794ea.pNext))
	x.EnabledValidationFeatureCount = (uint32)(x.refcd8794ea.enabledValidationFeatureCount)
	hxfbc67d2 := (*sliceHeader)(unsafe.Pointer(&x.PEnabledValidationFeatures))
	hxfbc67d2.Data = unsafe.Pointer(x.refcd8794ea.pEnabledValidationFeatures)
	hxfbc67d2.Cap = 0x7fffffff
	// hxfbc67d2.Len = ? x.PEnabledValidationFeatures x.refcd8794ea.pEnabledValidationFeatures

	x.DisabledValidationFeatureCount = (uint32)(x.refcd8794ea.disabledValidationFeatureCount)
	hxfe29d0c := (*sliceHeader)(unsafe.Pointer(&x.PDisabledValidationFeatures))
	hxfe29d0c.Data = unsafe.Pointer(x.refcd8794ea.pDisabledValidationFeatures)
	hxfe29d0c.Cap = 0x7fffffff
	// hxfe29d0c.Len = ? x.PDisabledValidationFeatures x.refcd8794ea.pDisabledValidationFeatures

}

// allocSurfacePresentModeCompatibilityMemory allocates memory for type C.VkSurfacePresentModeCompatibilityEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSurfacePresentModeCompatibilityMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSurfacePresentModeCompatibilityValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSurfacePresentModeCompatibilityValue = unsafe.Sizeof([1]C.VkSurfacePresentModeCompatibilityEXT{})

// copyPPresentModeBytes copies the data from Go slice as *C.VkPresentModeKHR.
func copyPPresentModeBytes(slice *sliceHeader) (*C.VkPresentModeKHR, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfPresentModeValue) * slice.Len,
		Cap:  int(sizeOfPresentModeValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkPresentModeKHR)(mem0), allocs
}

// allocPresentModeMemory allocates memory for type C.VkPresentModeKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPresentModeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPresentModeValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPresentModeValue = unsafe.Sizeof([1]C.VkPresentModeKHR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SurfacePresentModeCompatibility) Ref() *C.VkSurfacePresentModeCompatibilityEXT {
	if x == nil {
		return nil
	}
	return x.ref61fb395d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SurfacePresentModeCompatibility) Free() {
	if x != nil && x.allocs61fb395d != nil {
		x.allocs61fb395d.(*cgoAllocMap).Free()
		x.ref61fb395d = nil
	}
}

// NewSurfacePresentModeCompatibilityRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSurfacePresentModeCompatibilityRef(ref unsafe.Pointer) *SurfacePresentModeCompatibility {
	if ref == nil {
		return nil
	}
	obj := new(SurfacePresentModeCompatibility)
	obj.ref61fb395d = (*C.VkSurfacePresentModeCompatibilityEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SurfacePresentModeCompatibility) PassRef() (*C.VkSurfacePresentModeCompatibilityEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref61fb395d != nil {
		return x.ref61fb395d, nil
	}
	mem61fb395d := allocSurfacePresentModeCompatibilityMemory(1)
	ref61fb395d := (*C.VkSurfacePresentModeCompatibilityEXT)(mem61fb395d)
	allocs61fb395d := new(cgoAllocMap)
	allocs61fb395d.Add(mem61fb395d)

	ref61fb395d.sType = (C.VkStructureType)(x.SType)

	ref61fb395d.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref61fb395d.presentModeCount = (C.uint32_t)(x.PresentModeCount)

	if x.PPresentModes != nil {
		var cpPresentModes_allocs *cgoAllocMap
		ref61fb395d.pPresentModes, cpPresentModes_allocs = copyPPresentModeBytes((*sliceHeader)(unsafe.Pointer(&x.PPresentModes)))
		allocs61fb395d.Borrow(cpPresentModes_allocs)
	}

	x.ref61fb395d = ref61fb395d
	x.allocs61fb395d = allocs61fb395d
	return ref61fb395d, allocs61fb395d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SurfacePresentModeCompatibility) PassValue() (C.VkSurfacePresentModeCompatibilityEXT, *cgoAllocMap) {
	if x.ref61fb395d != nil {
		return *x.ref61fb395d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SurfacePresentModeCompatibility) Deref() {
	if x.ref61fb395d == nil {
		return
	}
	x.SType = (StructureType)(x.ref61fb395d.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref61fb395d.pNext))
	x.PresentModeCount = (uint32)(x.ref61fb395d.presentModeCount)
	hxfdeace4 := (*sliceHeader)(unsafe.Pointer(&x.PPresentModes))
	hxfdeace4.Data = unsafe.Pointer(x.ref61fb395d.pPresentModes)
	hxfdeace4.Cap = 0x7fffffff
	// hxfdeace4.Len = ? x.PPresentModes x.ref61fb395d.pPresentModes

}

// allocSwapchainPresentFenceInfoMemory allocates memory for type C.VkSwapchainPresentFenceInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSwapchainPresentFenceInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSwapchainPresentFenceInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSwapchainPresentFenceInfoValue = unsafe.Sizeof([1]C.VkSwapchainPresentFenceInfoEXT{})

// copyPFenceBytes copies the data from Go slice as *C.VkFence.
func copyPFenceBytes(slice *sliceHeader) (*C.VkFence, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfFenceValue) * slice.Len,
		Cap:  int(sizeOfFenceValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkFence)(mem0), allocs
}

// allocFenceMemory allocates memory for type C.VkFence in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFenceMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFenceValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFenceValue = unsafe.Sizeof([1]C.VkFence{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SwapchainPresentFenceInfo) Ref() *C.VkSwapchainPresentFenceInfoEXT {
	if x == nil {
		return nil
	}
	return x.reff3a3ddf9
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SwapchainPresentFenceInfo) Free() {
	if x != nil && x.allocsf3a3ddf9 != nil {
		x.allocsf3a3ddf9.(*cgoAllocMap).Free()
		x.reff3a3ddf9 = nil
	}
}

// NewSwapchainPresentFenceInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSwapchainPresentFenceInfoRef(ref unsafe.Pointer) *SwapchainPresentFenceInfo {
	if ref == nil {
		return nil
	}
	obj := new(SwapchainPresentFenceInfo)
	obj.reff3a3ddf9 = (*C.VkSwapchainPresentFenceInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SwapchainPresentFenceInfo) PassRef() (*C.VkSwapchainPresentFenceInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff3a3ddf9 != nil {
		return x.reff3a3ddf9, nil
	}
	memf3a3ddf9 := allocSwapchainPresentFenceInfoMemory(1)
	reff3a3ddf9 := (*C.VkSwapchainPresentFenceInfoEXT)(memf3a3ddf9)
	allocsf3a3ddf9 := new(cgoAllocMap)
	allocsf3a3ddf9.Add(memf3a3ddf9)

	reff3a3ddf9.sType = (C.VkStructureType)(x.SType)

	reff3a3ddf9.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	reff3a3ddf9.swapchainCount = (C.uint32_t)(x.SwapchainCount)

	if x.PFences != nil {
		var cpFences_allocs *cgoAllocMap
		reff3a3ddf9.pFences, cpFences_allocs = copyPFenceBytes((*sliceHeader)(unsafe.Pointer(&x.PFences)))
		allocsf3a3ddf9.Borrow(cpFences_allocs)
	}

	x.reff3a3ddf9 = reff3a3ddf9
	x.allocsf3a3ddf9 = allocsf3a3ddf9
	return reff3a3ddf9, allocsf3a3ddf9

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SwapchainPresentFenceInfo) PassValue() (C.VkSwapchainPresentFenceInfoEXT, *cgoAllocMap) {
	if x.reff3a3ddf9 != nil {
		return *x.reff3a3ddf9, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SwapchainPresentFenceInfo) Deref() {
	if x.reff3a3ddf9 == nil {
		return
	}
	x.SType = (StructureType)(x.reff3a3ddf9.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.reff3a3ddf9.pNext))
	x.SwapchainCount = (uint32)(x.reff3a3ddf9.swapchainCount)
	hxf1a6041 := (*sliceHeader)(unsafe.Pointer(&x.PFences))
	hxf1a6041.Data = unsafe.Pointer(x.reff3a3ddf9.pFences)
	hxf1a6041.Cap = 0x7fffffff
	// hxf1a6041.Len = ? x.PFences x.reff3a3ddf9.pFences

}

// allocSwapchainPresentModesCreateInfoMemory allocates memory for type C.VkSwapchainPresentModesCreateInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSwapchainPresentModesCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSwapchainPresentModesCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSwapchainPresentModesCreateInfoValue = unsafe.Sizeof([1]C.VkSwapchainPresentModesCreateInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SwapchainPresentModesCreateInfo) Ref() *C.VkSwapchainPresentModesCreateInfoEXT {
	if x == nil {
		return nil
	}
	return x.ref27b56519
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SwapchainPresentModesCreateInfo) Free() {
	if x != nil && x.allocs27b56519 != nil {
		x.allocs27b56519.(*cgoAllocMap).Free()
		x.ref27b56519 = nil
	}
}

// NewSwapchainPresentModesCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSwapchainPresentModesCreateInfoRef(ref unsafe.Pointer) *SwapchainPresentModesCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(SwapchainPresentModesCreateInfo)
	obj.ref27b56519 = (*C.VkSwapchainPresentModesCreateInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SwapchainPresentModesCreateInfo) PassRef() (*C.VkSwapchainPresentModesCreateInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref27b56519 != nil {
		return x.ref27b56519, nil
	}
	mem27b56519 := allocSwapchainPresentModesCreateInfoMemory(1)
	ref27b56519 := (*C.VkSwapchainPresentModesCreateInfoEXT)(mem27b56519)
	allocs27b56519 := new(cgoAllocMap)
	allocs27b56519.Add(mem27b56519)

	ref27b56519.sType = (C.VkStructureType)(x.SType)

	ref27b56519.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref27b56519.presentModeCount = (C.uint32_t)(x.PresentModeCount)

	if x.PPresentModes != nil {
		var cpPresentModes_allocs *cgoAllocMap
		ref27b56519.pPresentModes, cpPresentModes_allocs = copyPPresentModeBytes((*sliceHeader)(unsafe.Pointer(&x.PPresentModes)))
		allocs27b56519.Borrow(cpPresentModes_allocs)
	}

	x.ref27b56519 = ref27b56519
	x.allocs27b56519 = allocs27b56519
	return ref27b56519, allocs27b56519

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SwapchainPresentModesCreateInfo) PassValue() (C.VkSwapchainPresentModesCreateInfoEXT, *cgoAllocMap) {
	if x.ref27b56519 != nil {
		return *x.ref27b56519, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SwapchainPresentModesCreateInfo) Deref() {
	if x.ref27b56519 == nil {
		return
	}
	x.SType = (StructureType)(x.ref27b56519.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref27b56519.pNext))
	x.PresentModeCount = (uint32)(x.ref27b56519.presentModeCount)
	hxfe999fb := (*sliceHeader)(unsafe.Pointer(&x.PPresentModes))
	hxfe999fb.Data = unsafe.Pointer(x.ref27b56519.pPresentModes)
	hxfe999fb.Cap = 0x7fffffff
	// hxfe999fb.Len = ? x.PPresentModes x.ref27b56519.pPresentModes

}

// allocSwapchainPresentModeInfoMemory allocates memory for type C.VkSwapchainPresentModeInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSwapchainPresentModeInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSwapchainPresentModeInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSwapchainPresentModeInfoValue = unsafe.Sizeof([1]C.VkSwapchainPresentModeInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SwapchainPresentModeInfo) Ref() *C.VkSwapchainPresentModeInfoEXT {
	if x == nil {
		return nil
	}
	return x.refee48d4d8
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SwapchainPresentModeInfo) Free() {
	if x != nil && x.allocsee48d4d8 != nil {
		x.allocsee48d4d8.(*cgoAllocMap).Free()
		x.refee48d4d8 = nil
	}
}

// NewSwapchainPresentModeInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSwapchainPresentModeInfoRef(ref unsafe.Pointer) *SwapchainPresentModeInfo {
	if ref == nil {
		return nil
	}
	obj := new(SwapchainPresentModeInfo)
	obj.refee48d4d8 = (*C.VkSwapchainPresentModeInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SwapchainPresentModeInfo) PassRef() (*C.VkSwapchainPresentModeInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refee48d4d8 != nil {
		return x.refee48d4d8, nil
	}
	memee48d4d8 := allocSwapchainPresentModeInfoMemory(1)
	refee48d4d8 := (*C.VkSwapchainPresentModeInfoEXT)(memee48d4d8)
	allocsee48d4d8 := new(cgoAllocMap)
	allocsee48d4d8.Add(memee48d4d8)

	refee48d4d8.sType = (C.VkStructureType)(x.SType)

	refee48d4d8.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	refee48d4d8.swapchainCount = (C.uint32_t)(x.SwapchainCount)

	if x.PPresentModes != nil {
		var cpPresentModes_allocs *cgoAllocMap
		refee48d4d8.pPresentModes, cpPresentModes_allocs = copyPPresentModeBytes((*sliceHeader)(unsafe.Pointer(&x.PPresentModes)))
		allocsee48d4d8.Borrow(cpPresentModes_allocs)
	}

	x.refee48d4d8 = refee48d4d8
	x.allocsee48d4d8 = allocsee48d4d8
	return refee48d4d8, allocsee48d4d8

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SwapchainPresentModeInfo) PassValue() (C.VkSwapchainPresentModeInfoEXT, *cgoAllocMap) {
	if x.refee48d4d8 != nil {
		return *x.refee48d4d8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SwapchainPresentModeInfo) Deref() {
	if x.refee48d4d8 == nil {
		return
	}
	x.SType = (StructureType)(x.refee48d4d8.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refee48d4d8.pNext))
	x.SwapchainCount = (uint32)(x.refee48d4d8.swapchainCount)
	hxf61194e := (*sliceHeader)(unsafe.Pointer(&x.PPresentModes))
	hxf61194e.Data = unsafe.Pointer(x.refee48d4d8.pPresentModes)
	hxf61194e.Cap = 0x7fffffff
	// hxf61194e.Len = ? x.PPresentModes x.refee48d4d8.pPresentModes

}

// allocReleaseSwapchainImagesInfoMemory allocates memory for type C.VkReleaseSwapchainImagesInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocReleaseSwapchainImagesInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfReleaseSwapchainImagesInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfReleaseSwapchainImagesInfoValue = unsafe.Sizeof([1]C.VkReleaseSwapchainImagesInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ReleaseSwapchainImagesInfo) Ref() *C.VkReleaseSwapchainImagesInfoEXT {
	if x == nil {
		return nil
	}
	return x.ref6c053bf
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ReleaseSwapchainImagesInfo) Free() {
	if x != nil && x.allocs6c053bf != nil {
		x.allocs6c053bf.(*cgoAllocMap).Free()
		x.ref6c053bf = nil
	}
}

// NewReleaseSwapchainImagesInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewReleaseSwapchainImagesInfoRef(ref unsafe.Pointer) *ReleaseSwapchainImagesInfo {
	if ref == nil {
		return nil
	}
	obj := new(ReleaseSwapchainImagesInfo)
	obj.ref6c053bf = (*C.VkReleaseSwapchainImagesInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ReleaseSwapchainImagesInfo) PassRef() (*C.VkReleaseSwapchainImagesInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6c053bf != nil {
		return x.ref6c053bf, nil
	}
	mem6c053bf := allocReleaseSwapchainImagesInfoMemory(1)
	ref6c053bf := (*C.VkReleaseSwapchainImagesInfoEXT)(mem6c053bf)
	allocs6c053bf := new(cgoAllocMap)
	allocs6c053bf.Add(mem6c053bf)

	ref6c053bf.sType = (C.VkStructureType)(x.SType)

	ref6c053bf.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref6c053bf.swapchain = *(*C.VkSwapchainKHR)(unsafe.Pointer(&x.Swapchain))

	ref6c053bf.imageIndexCount = (C.uint32_t)(x.ImageIndexCount)

	if x.PImageIndices != nil {
		var cpImageIndices_allocs *cgoAllocMap
		ref6c053bf.pImageIndices, cpImageIndices_allocs = copyPUint32_tBytes((*sliceHeader)(unsafe.Pointer(&x.PImageIndices)))
		allocs6c053bf.Borrow(cpImageIndices_allocs)
	}

	x.ref6c053bf = ref6c053bf
	x.allocs6c053bf = allocs6c053bf
	return ref6c053bf, allocs6c053bf

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ReleaseSwapchainImagesInfo) PassValue() (C.VkReleaseSwapchainImagesInfoEXT, *cgoAllocMap) {
	if x.ref6c053bf != nil {
		return *x.ref6c053bf, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ReleaseSwapchainImagesInfo) Deref() {
	if x.ref6c053bf == nil {
		return
	}
	x.SType = (StructureType)(x.ref6c053bf.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref6c053bf.pNext))
	x.Swapchain = *(*Swapchain)(unsafe.Pointer(&x.ref6c053bf.swapchain))
	x.ImageIndexCount = (uint32)(x.ref6c053bf.imageIndexCount)
	hxf31fd96 := (*sliceHeader)(unsafe.Pointer(&x.PImageIndices))
	hxf31fd96.Data = unsafe.Pointer(x.ref6c053bf.pImageIndices)
	hxf31fd96.Cap = 0x7fffffff
	// hxf31fd96.Len = ? x.PImageIndices x.ref6c053bf.pImageIndices

}

// allocGraphicsShaderGroupCreateInfoNVMemory allocates memory for type C.VkGraphicsShaderGroupCreateInfoNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocGraphicsShaderGroupCreateInfoNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfGraphicsShaderGroupCreateInfoNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfGraphicsShaderGroupCreateInfoNVValue = unsafe.Sizeof([1]C.VkGraphicsShaderGroupCreateInfoNV{})

// unpackSPipelineVertexInputStateCreateInfo transforms a sliced Go data structure into plain C format.
func unpackSPipelineVertexInputStateCreateInfo(x []PipelineVertexInputStateCreateInfo) (unpacked *C.VkPipelineVertexInputStateCreateInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPipelineVertexInputStateCreateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkPipelineVertexInputStateCreateInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkPipelineVertexInputStateCreateInfo)(h.Data)
	return
}

// copyPPipelineTessellationStateCreateInfoBytes copies the data from Go slice as *C.VkPipelineTessellationStateCreateInfo.
func copyPPipelineTessellationStateCreateInfoBytes(slice *sliceHeader) (*C.VkPipelineTessellationStateCreateInfo, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfPipelineTessellationStateCreateInfoValue) * slice.Len,
		Cap:  int(sizeOfPipelineTessellationStateCreateInfoValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkPipelineTessellationStateCreateInfo)(mem0), allocs
}

// allocPipelineTessellationStateCreateInfoMemory allocates memory for type C.VkPipelineTessellationStateCreateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineTessellationStateCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineTessellationStateCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPipelineTessellationStateCreateInfoValue = unsafe.Sizeof([1]C.VkPipelineTessellationStateCreateInfo{})

// packSPipelineVertexInputStateCreateInfo reads sliced Go data structure out from plain C format.
func packSPipelineVertexInputStateCreateInfo(v []PipelineVertexInputStateCreateInfo, ptr0 *C.VkPipelineVertexInputStateCreateInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPipelineVertexInputStateCreateInfoValue]C.VkPipelineVertexInputStateCreateInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPipelineVertexInputStateCreateInfoRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *GraphicsShaderGroupCreateInfoNV) Ref() *C.VkGraphicsShaderGroupCreateInfoNV {
	if x == nil {
		return nil
	}
	return x.refa9d954e5
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *GraphicsShaderGroupCreateInfoNV) Free() {
	if x != nil && x.allocsa9d954e5 != nil {
		x.allocsa9d954e5.(*cgoAllocMap).Free()
		x.refa9d954e5 = nil
	}
}

// NewGraphicsShaderGroupCreateInfoNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewGraphicsShaderGroupCreateInfoNVRef(ref unsafe.Pointer) *GraphicsShaderGroupCreateInfoNV {
	if ref == nil {
		return nil
	}
	obj := new(GraphicsShaderGroupCreateInfoNV)
	obj.refa9d954e5 = (*C.VkGraphicsShaderGroupCreateInfoNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *GraphicsShaderGroupCreateInfoNV) PassRef() (*C.VkGraphicsShaderGroupCreateInfoNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa9d954e5 != nil {
		return x.refa9d954e5, nil
	}
	mema9d954e5 := allocGraphicsShaderGroupCreateInfoNVMemory(1)
	refa9d954e5 := (*C.VkGraphicsShaderGroupCreateInfoNV)(mema9d954e5)
	allocsa9d954e5 := new(cgoAllocMap)
	allocsa9d954e5.Add(mema9d954e5)

	refa9d954e5.sType = (C.VkStructureType)(x.SType)

	refa9d954e5.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	refa9d954e5.stageCount = (C.uint32_t)(x.StageCount)

	var cpStages_allocs *cgoAllocMap
	refa9d954e5.pStages, cpStages_allocs = unpackSPipelineShaderStageCreateInfo(x.PStages)
	allocsa9d954e5.Borrow(cpStages_allocs)

	var cpVertexInputState_allocs *cgoAllocMap
	refa9d954e5.pVertexInputState, cpVertexInputState_allocs = unpackSPipelineVertexInputStateCreateInfo(x.PVertexInputState)
	allocsa9d954e5.Borrow(cpVertexInputState_allocs)

	if x.PTessellationState != nil {
		var cpTessellationState_allocs *cgoAllocMap
		refa9d954e5.pTessellationState, cpTessellationState_allocs = copyPPipelineTessellationStateCreateInfoBytes((*sliceHeader)(unsafe.Pointer(&x.PTessellationState)))
		allocsa9d954e5.Borrow(cpTessellationState_allocs)
	}

	x.refa9d954e5 = refa9d954e5
	x.allocsa9d954e5 = allocsa9d954e5
	return refa9d954e5, allocsa9d954e5

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x GraphicsShaderGroupCreateInfoNV) PassValue() (C.VkGraphicsShaderGroupCreateInfoNV, *cgoAllocMap) {
	if x.refa9d954e5 != nil {
		return *x.refa9d954e5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *GraphicsShaderGroupCreateInfoNV) Deref() {
	if x.refa9d954e5 == nil {
		return
	}
	x.SType = (StructureType)(x.refa9d954e5.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refa9d954e5.pNext))
	x.StageCount = (uint32)(x.refa9d954e5.stageCount)
	packSPipelineShaderStageCreateInfo(x.PStages, x.refa9d954e5.pStages)
	packSPipelineVertexInputStateCreateInfo(x.PVertexInputState, x.refa9d954e5.pVertexInputState)
	hxf8e12bb := (*sliceHeader)(unsafe.Pointer(&x.PTessellationState))
	hxf8e12bb.Data = unsafe.Pointer(x.refa9d954e5.pTessellationState)
	hxf8e12bb.Cap = 0x7fffffff
	// hxf8e12bb.Len = ? x.PTessellationState x.refa9d954e5.pTessellationState

}

// allocGraphicsPipelineShaderGroupsCreateInfoNVMemory allocates memory for type C.VkGraphicsPipelineShaderGroupsCreateInfoNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocGraphicsPipelineShaderGroupsCreateInfoNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfGraphicsPipelineShaderGroupsCreateInfoNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfGraphicsPipelineShaderGroupsCreateInfoNVValue = unsafe.Sizeof([1]C.VkGraphicsPipelineShaderGroupsCreateInfoNV{})

// unpackSGraphicsShaderGroupCreateInfoNV transforms a sliced Go data structure into plain C format.
func unpackSGraphicsShaderGroupCreateInfoNV(x []GraphicsShaderGroupCreateInfoNV) (unpacked *C.VkGraphicsShaderGroupCreateInfoNV, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocGraphicsShaderGroupCreateInfoNVMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkGraphicsShaderGroupCreateInfoNV)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkGraphicsShaderGroupCreateInfoNV)(h.Data)
	return
}

// packSGraphicsShaderGroupCreateInfoNV reads sliced Go data structure out from plain C format.
func packSGraphicsShaderGroupCreateInfoNV(v []GraphicsShaderGroupCreateInfoNV, ptr0 *C.VkGraphicsShaderGroupCreateInfoNV) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfGraphicsShaderGroupCreateInfoNVValue]C.VkGraphicsShaderGroupCreateInfoNV)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewGraphicsShaderGroupCreateInfoNVRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *GraphicsPipelineShaderGroupsCreateInfoNV) Ref() *C.VkGraphicsPipelineShaderGroupsCreateInfoNV {
	if x == nil {
		return nil
	}
	return x.refabf1b7d9
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *GraphicsPipelineShaderGroupsCreateInfoNV) Free() {
	if x != nil && x.allocsabf1b7d9 != nil {
		x.allocsabf1b7d9.(*cgoAllocMap).Free()
		x.refabf1b7d9 = nil
	}
}

// NewGraphicsPipelineShaderGroupsCreateInfoNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewGraphicsPipelineShaderGroupsCreateInfoNVRef(ref unsafe.Pointer) *GraphicsPipelineShaderGroupsCreateInfoNV {
	if ref == nil {
		return nil
	}
	obj := new(GraphicsPipelineShaderGroupsCreateInfoNV)
	obj.refabf1b7d9 = (*C.VkGraphicsPipelineShaderGroupsCreateInfoNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *GraphicsPipelineShaderGroupsCreateInfoNV) PassRef() (*C.VkGraphicsPipelineShaderGroupsCreateInfoNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refabf1b7d9 != nil {
		return x.refabf1b7d9, nil
	}
	memabf1b7d9 := allocGraphicsPipelineShaderGroupsCreateInfoNVMemory(1)
	refabf1b7d9 := (*C.VkGraphicsPipelineShaderGroupsCreateInfoNV)(memabf1b7d9)
	allocsabf1b7d9 := new(cgoAllocMap)
	allocsabf1b7d9.Add(memabf1b7d9)

	refabf1b7d9.sType = (C.VkStructureType)(x.SType)

	refabf1b7d9.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	refabf1b7d9.groupCount = (C.uint32_t)(x.GroupCount)

	var cpGroups_allocs *cgoAllocMap
	refabf1b7d9.pGroups, cpGroups_allocs = unpackSGraphicsShaderGroupCreateInfoNV(x.PGroups)
	allocsabf1b7d9.Borrow(cpGroups_allocs)

	refabf1b7d9.pipelineCount = (C.uint32_t)(x.PipelineCount)

	if x.PPipelines != nil {
		var cpPipelines_allocs *cgoAllocMap
		refabf1b7d9.pPipelines, cpPipelines_allocs = copyPPipelineBytes((*sliceHeader)(unsafe.Pointer(&x.PPipelines)))
		allocsabf1b7d9.Borrow(cpPipelines_allocs)
	}

	x.refabf1b7d9 = refabf1b7d9
	x.allocsabf1b7d9 = allocsabf1b7d9
	return refabf1b7d9, allocsabf1b7d9

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x GraphicsPipelineShaderGroupsCreateInfoNV) PassValue() (C.VkGraphicsPipelineShaderGroupsCreateInfoNV, *cgoAllocMap) {
	if x.refabf1b7d9 != nil {
		return *x.refabf1b7d9, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *GraphicsPipelineShaderGroupsCreateInfoNV) Deref() {
	if x.refabf1b7d9 == nil {
		return
	}
	x.SType = (StructureType)(x.refabf1b7d9.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refabf1b7d9.pNext))
	x.GroupCount = (uint32)(x.refabf1b7d9.groupCount)
	packSGraphicsShaderGroupCreateInfoNV(x.PGroups, x.refabf1b7d9.pGroups)
	x.PipelineCount = (uint32)(x.refabf1b7d9.pipelineCount)
	hxff7f3fa := (*sliceHeader)(unsafe.Pointer(&x.PPipelines))
	hxff7f3fa.Data = unsafe.Pointer(x.refabf1b7d9.pPipelines)
	hxff7f3fa.Cap = 0x7fffffff
	// hxff7f3fa.Len = ? x.PPipelines x.refabf1b7d9.pPipelines

}

// allocIndirectCommandsStreamNVMemory allocates memory for type C.VkIndirectCommandsStreamNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocIndirectCommandsStreamNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfIndirectCommandsStreamNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfIndirectCommandsStreamNVValue = unsafe.Sizeof([1]C.VkIndirectCommandsStreamNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *IndirectCommandsStreamNV) Ref() *C.VkIndirectCommandsStreamNV {
	if x == nil {
		return nil
	}
	return x.refc623636a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *IndirectCommandsStreamNV) Free() {
	if x != nil && x.allocsc623636a != nil {
		x.allocsc623636a.(*cgoAllocMap).Free()
		x.refc623636a = nil
	}
}

// NewIndirectCommandsStreamNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewIndirectCommandsStreamNVRef(ref unsafe.Pointer) *IndirectCommandsStreamNV {
	if ref == nil {
		return nil
	}
	obj := new(IndirectCommandsStreamNV)
	obj.refc623636a = (*C.VkIndirectCommandsStreamNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *IndirectCommandsStreamNV) PassRef() (*C.VkIndirectCommandsStreamNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc623636a != nil {
		return x.refc623636a, nil
	}
	memc623636a := allocIndirectCommandsStreamNVMemory(1)
	refc623636a := (*C.VkIndirectCommandsStreamNV)(memc623636a)
	allocsc623636a := new(cgoAllocMap)
	allocsc623636a.Add(memc623636a)

	refc623636a.buffer = *(*C.VkBuffer)(unsafe.Pointer(&x.Buffer))

	refc623636a.offset = (C.VkDeviceSize)(x.Offset)

	x.refc623636a = refc623636a
	x.allocsc623636a = allocsc623636a
	return refc623636a, allocsc623636a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x IndirectCommandsStreamNV) PassValue() (C.VkIndirectCommandsStreamNV, *cgoAllocMap) {
	if x.refc623636a != nil {
		return *x.refc623636a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *IndirectCommandsStreamNV) Deref() {
	if x.refc623636a == nil {
		return
	}
	x.Buffer = *(*Buffer)(unsafe.Pointer(&x.refc623636a.buffer))
	x.Offset = (DeviceSize)(x.refc623636a.offset)
}

// allocIndirectCommandsLayoutTokenNVMemory allocates memory for type C.VkIndirectCommandsLayoutTokenNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocIndirectCommandsLayoutTokenNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfIndirectCommandsLayoutTokenNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfIndirectCommandsLayoutTokenNVValue = unsafe.Sizeof([1]C.VkIndirectCommandsLayoutTokenNV{})

// copyPIndexTypeBytes copies the data from Go slice as *C.VkIndexType.
func copyPIndexTypeBytes(slice *sliceHeader) (*C.VkIndexType, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfIndexTypeValue) * slice.Len,
		Cap:  int(sizeOfIndexTypeValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkIndexType)(mem0), allocs
}

// allocIndexTypeMemory allocates memory for type C.VkIndexType in C.
// The caller is responsible for freeing the this memory via C.free.
func allocIndexTypeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfIndexTypeValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfIndexTypeValue = unsafe.Sizeof([1]C.VkIndexType{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *IndirectCommandsLayoutTokenNV) Ref() *C.VkIndirectCommandsLayoutTokenNV {
	if x == nil {
		return nil
	}
	return x.ref96f52b76
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *IndirectCommandsLayoutTokenNV) Free() {
	if x != nil && x.allocs96f52b76 != nil {
		x.allocs96f52b76.(*cgoAllocMap).Free()
		x.ref96f52b76 = nil
	}
}

// NewIndirectCommandsLayoutTokenNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewIndirectCommandsLayoutTokenNVRef(ref unsafe.Pointer) *IndirectCommandsLayoutTokenNV {
	if ref == nil {
		return nil
	}
	obj := new(IndirectCommandsLayoutTokenNV)
	obj.ref96f52b76 = (*C.VkIndirectCommandsLayoutTokenNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *IndirectCommandsLayoutTokenNV) PassRef() (*C.VkIndirectCommandsLayoutTokenNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref96f52b76 != nil {
		return x.ref96f52b76, nil
	}
	mem96f52b76 := allocIndirectCommandsLayoutTokenNVMemory(1)
	ref96f52b76 := (*C.VkIndirectCommandsLayoutTokenNV)(mem96f52b76)
	allocs96f52b76 := new(cgoAllocMap)
	allocs96f52b76.Add(mem96f52b76)

	ref96f52b76.sType = (C.VkStructureType)(x.SType)

	ref96f52b76.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref96f52b76.tokenType = (C.VkIndirectCommandsTokenTypeNV)(x.TokenType)

	ref96f52b76.stream = (C.uint32_t)(x.Stream)

	ref96f52b76.offset = (C.uint32_t)(x.Offset)

	ref96f52b76.vertexBindingUnit = (C.uint32_t)(x.VertexBindingUnit)

	ref96f52b76.vertexDynamicStride = (C.VkBool32)(x.VertexDynamicStride)

	ref96f52b76.pushconstantPipelineLayout = *(*C.VkPipelineLayout)(unsafe.Pointer(&x.PushconstantPipelineLayout))

	ref96f52b76.pushconstantShaderStageFlags = (C.VkShaderStageFlags)(x.PushconstantShaderStageFlags)

	ref96f52b76.pushconstantOffset = (C.uint32_t)(x.PushconstantOffset)

	ref96f52b76.pushconstantSize = (C.uint32_t)(x.PushconstantSize)

	ref96f52b76.indirectStateFlags = (C.VkIndirectStateFlagsNV)(x.IndirectStateFlags)

	ref96f52b76.indexTypeCount = (C.uint32_t)(x.IndexTypeCount)

	if x.PIndexTypes != nil {
		var cpIndexTypes_allocs *cgoAllocMap
		ref96f52b76.pIndexTypes, cpIndexTypes_allocs = copyPIndexTypeBytes((*sliceHeader)(unsafe.Pointer(&x.PIndexTypes)))
		allocs96f52b76.Borrow(cpIndexTypes_allocs)
	}

	if x.PIndexTypeValues != nil {
		var cpIndexTypeValues_allocs *cgoAllocMap
		ref96f52b76.pIndexTypeValues, cpIndexTypeValues_allocs = copyPUint32_tBytes((*sliceHeader)(unsafe.Pointer(&x.PIndexTypeValues)))
		allocs96f52b76.Borrow(cpIndexTypeValues_allocs)
	}

	x.ref96f52b76 = ref96f52b76
	x.allocs96f52b76 = allocs96f52b76
	return ref96f52b76, allocs96f52b76

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x IndirectCommandsLayoutTokenNV) PassValue() (C.VkIndirectCommandsLayoutTokenNV, *cgoAllocMap) {
	if x.ref96f52b76 != nil {
		return *x.ref96f52b76, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *IndirectCommandsLayoutTokenNV) Deref() {
	if x.ref96f52b76 == nil {
		return
	}
	x.SType = (StructureType)(x.ref96f52b76.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref96f52b76.pNext))
	x.TokenType = (IndirectCommandsTokenTypeNV)(x.ref96f52b76.tokenType)
	x.Stream = (uint32)(x.ref96f52b76.stream)
	x.Offset = (uint32)(x.ref96f52b76.offset)
	x.VertexBindingUnit = (uint32)(x.ref96f52b76.vertexBindingUnit)
	x.VertexDynamicStride = (Bool32)(x.ref96f52b76.vertexDynamicStride)
	x.PushconstantPipelineLayout = *(*PipelineLayout)(unsafe.Pointer(&x.ref96f52b76.pushconstantPipelineLayout))
	x.PushconstantShaderStageFlags = (ShaderStageFlags)(x.ref96f52b76.pushconstantShaderStageFlags)
	x.PushconstantOffset = (uint32)(x.ref96f52b76.pushconstantOffset)
	x.PushconstantSize = (uint32)(x.ref96f52b76.pushconstantSize)
	x.IndirectStateFlags = (IndirectStateFlagsNV)(x.ref96f52b76.indirectStateFlags)
	x.IndexTypeCount = (uint32)(x.ref96f52b76.indexTypeCount)
	hxf96661a := (*sliceHeader)(unsafe.Pointer(&x.PIndexTypes))
	hxf96661a.Data = unsafe.Pointer(x.ref96f52b76.pIndexTypes)
	hxf96661a.Cap = 0x7fffffff
	// hxf96661a.Len = ? x.PIndexTypes x.ref96f52b76.pIndexTypes

	hxf216f94 := (*sliceHeader)(unsafe.Pointer(&x.PIndexTypeValues))
	hxf216f94.Data = unsafe.Pointer(x.ref96f52b76.pIndexTypeValues)
	hxf216f94.Cap = 0x7fffffff
	// hxf216f94.Len = ? x.PIndexTypeValues x.ref96f52b76.pIndexTypeValues

}

// allocIndirectCommandsLayoutCreateInfoNVMemory allocates memory for type C.VkIndirectCommandsLayoutCreateInfoNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocIndirectCommandsLayoutCreateInfoNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfIndirectCommandsLayoutCreateInfoNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfIndirectCommandsLayoutCreateInfoNVValue = unsafe.Sizeof([1]C.VkIndirectCommandsLayoutCreateInfoNV{})

// unpackSIndirectCommandsLayoutTokenNV transforms a sliced Go data structure into plain C format.
func unpackSIndirectCommandsLayoutTokenNV(x []IndirectCommandsLayoutTokenNV) (unpacked *C.VkIndirectCommandsLayoutTokenNV, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocIndirectCommandsLayoutTokenNVMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkIndirectCommandsLayoutTokenNV)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkIndirectCommandsLayoutTokenNV)(h.Data)
	return
}

// packSIndirectCommandsLayoutTokenNV reads sliced Go data structure out from plain C format.
func packSIndirectCommandsLayoutTokenNV(v []IndirectCommandsLayoutTokenNV, ptr0 *C.VkIndirectCommandsLayoutTokenNV) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfIndirectCommandsLayoutTokenNVValue]C.VkIndirectCommandsLayoutTokenNV)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewIndirectCommandsLayoutTokenNVRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *IndirectCommandsLayoutCreateInfoNV) Ref() *C.VkIndirectCommandsLayoutCreateInfoNV {
	if x == nil {
		return nil
	}
	return x.ref48273185
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *IndirectCommandsLayoutCreateInfoNV) Free() {
	if x != nil && x.allocs48273185 != nil {
		x.allocs48273185.(*cgoAllocMap).Free()
		x.ref48273185 = nil
	}
}

// NewIndirectCommandsLayoutCreateInfoNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewIndirectCommandsLayoutCreateInfoNVRef(ref unsafe.Pointer) *IndirectCommandsLayoutCreateInfoNV {
	if ref == nil {
		return nil
	}
	obj := new(IndirectCommandsLayoutCreateInfoNV)
	obj.ref48273185 = (*C.VkIndirectCommandsLayoutCreateInfoNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *IndirectCommandsLayoutCreateInfoNV) PassRef() (*C.VkIndirectCommandsLayoutCreateInfoNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref48273185 != nil {
		return x.ref48273185, nil
	}
	mem48273185 := allocIndirectCommandsLayoutCreateInfoNVMemory(1)
	ref48273185 := (*C.VkIndirectCommandsLayoutCreateInfoNV)(mem48273185)
	allocs48273185 := new(cgoAllocMap)
	allocs48273185.Add(mem48273185)

	ref48273185.sType = (C.VkStructureType)(x.SType)

	ref48273185.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref48273185.flags = (C.VkIndirectCommandsLayoutUsageFlagsNV)(x.Flags)

	ref48273185.pipelineBindPoint = (C.VkPipelineBindPoint)(x.PipelineBindPoint)

	ref48273185.tokenCount = (C.uint32_t)(x.TokenCount)

	var cpTokens_allocs *cgoAllocMap
	ref48273185.pTokens, cpTokens_allocs = unpackSIndirectCommandsLayoutTokenNV(x.PTokens)
	allocs48273185.Borrow(cpTokens_allocs)

	ref48273185.streamCount = (C.uint32_t)(x.StreamCount)

	if x.PStreamStrides != nil {
		var cpStreamStrides_allocs *cgoAllocMap
		ref48273185.pStreamStrides, cpStreamStrides_allocs = copyPUint32_tBytes((*sliceHeader)(unsafe.Pointer(&x.PStreamStrides)))
		allocs48273185.Borrow(cpStreamStrides_allocs)
	}

	x.ref48273185 = ref48273185
	x.allocs48273185 = allocs48273185
	return ref48273185, allocs48273185

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x IndirectCommandsLayoutCreateInfoNV) PassValue() (C.VkIndirectCommandsLayoutCreateInfoNV, *cgoAllocMap) {
	if x.ref48273185 != nil {
		return *x.ref48273185, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *IndirectCommandsLayoutCreateInfoNV) Deref() {
	if x.ref48273185 == nil {
		return
	}
	x.SType = (StructureType)(x.ref48273185.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref48273185.pNext))
	x.Flags = (IndirectCommandsLayoutUsageFlagsNV)(x.ref48273185.flags)
	x.PipelineBindPoint = (PipelineBindPoint)(x.ref48273185.pipelineBindPoint)
	x.TokenCount = (uint32)(x.ref48273185.tokenCount)
	packSIndirectCommandsLayoutTokenNV(x.PTokens, x.ref48273185.pTokens)
	x.StreamCount = (uint32)(x.ref48273185.streamCount)
	hxf124faa := (*sliceHeader)(unsafe.Pointer(&x.PStreamStrides))
	hxf124faa.Data = unsafe.Pointer(x.ref48273185.pStreamStrides)
	hxf124faa.Cap = 0x7fffffff
	// hxf124faa.Len = ? x.PStreamStrides x.ref48273185.pStreamStrides

}

// allocGeneratedCommandsInfoNVMemory allocates memory for type C.VkGeneratedCommandsInfoNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocGeneratedCommandsInfoNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfGeneratedCommandsInfoNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfGeneratedCommandsInfoNVValue = unsafe.Sizeof([1]C.VkGeneratedCommandsInfoNV{})

// unpackSIndirectCommandsStreamNV transforms a sliced Go data structure into plain C format.
func unpackSIndirectCommandsStreamNV(x []IndirectCommandsStreamNV) (unpacked *C.VkIndirectCommandsStreamNV, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocIndirectCommandsStreamNVMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkIndirectCommandsStreamNV)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkIndirectCommandsStreamNV)(h.Data)
	return
}

// packSIndirectCommandsStreamNV reads sliced Go data structure out from plain C format.
func packSIndirectCommandsStreamNV(v []IndirectCommandsStreamNV, ptr0 *C.VkIndirectCommandsStreamNV) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfIndirectCommandsStreamNVValue]C.VkIndirectCommandsStreamNV)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewIndirectCommandsStreamNVRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *GeneratedCommandsInfoNV) Ref() *C.VkGeneratedCommandsInfoNV {
	if x == nil {
		return nil
	}
	return x.refc05396ea
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *GeneratedCommandsInfoNV) Free() {
	if x != nil && x.allocsc05396ea != nil {
		x.allocsc05396ea.(*cgoAllocMap).Free()
		x.refc05396ea = nil
	}
}

// NewGeneratedCommandsInfoNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewGeneratedCommandsInfoNVRef(ref unsafe.Pointer) *GeneratedCommandsInfoNV {
	if ref == nil {
		return nil
	}
	obj := new(GeneratedCommandsInfoNV)
	obj.refc05396ea = (*C.VkGeneratedCommandsInfoNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *GeneratedCommandsInfoNV) PassRef() (*C.VkGeneratedCommandsInfoNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc05396ea != nil {
		return x.refc05396ea, nil
	}
	memc05396ea := allocGeneratedCommandsInfoNVMemory(1)
	refc05396ea := (*C.VkGeneratedCommandsInfoNV)(memc05396ea)
	allocsc05396ea := new(cgoAllocMap)
	allocsc05396ea.Add(memc05396ea)

	refc05396ea.sType = (C.VkStructureType)(x.SType)

	refc05396ea.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	refc05396ea.pipelineBindPoint = (C.VkPipelineBindPoint)(x.PipelineBindPoint)

	refc05396ea.pipeline = *(*C.VkPipeline)(unsafe.Pointer(&x.Pipeline))

	refc05396ea.indirectCommandsLayout = *(*C.VkIndirectCommandsLayoutNV)(unsafe.Pointer(&x.IndirectCommandsLayout))

	refc05396ea.streamCount = (C.uint32_t)(x.StreamCount)

	var cpStreams_allocs *cgoAllocMap
	refc05396ea.pStreams, cpStreams_allocs = unpackSIndirectCommandsStreamNV(x.PStreams)
	allocsc05396ea.Borrow(cpStreams_allocs)

	refc05396ea.sequencesCount = (C.uint32_t)(x.SequencesCount)

	refc05396ea.preprocessBuffer = *(*C.VkBuffer)(unsafe.Pointer(&x.PreprocessBuffer))

	refc05396ea.preprocessOffset = (C.VkDeviceSize)(x.PreprocessOffset)

	refc05396ea.preprocessSize = (C.VkDeviceSize)(x.PreprocessSize)

	refc05396ea.sequencesCountBuffer = *(*C.VkBuffer)(unsafe.Pointer(&x.SequencesCountBuffer))

	refc05396ea.sequencesCountOffset = (C.VkDeviceSize)(x.SequencesCountOffset)

	refc05396ea.sequencesIndexBuffer = *(*C.VkBuffer)(unsafe.Pointer(&x.SequencesIndexBuffer))

	refc05396ea.sequencesIndexOffset = (C.VkDeviceSize)(x.SequencesIndexOffset)

	x.refc05396ea = refc05396ea
	x.allocsc05396ea = allocsc05396ea
	return refc05396ea, allocsc05396ea

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x GeneratedCommandsInfoNV) PassValue() (C.VkGeneratedCommandsInfoNV, *cgoAllocMap) {
	if x.refc05396ea != nil {
		return *x.refc05396ea, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *GeneratedCommandsInfoNV) Deref() {
	if x.refc05396ea == nil {
		return
	}
	x.SType = (StructureType)(x.refc05396ea.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refc05396ea.pNext))
	x.PipelineBindPoint = (PipelineBindPoint)(x.refc05396ea.pipelineBindPoint)
	x.Pipeline = *(*Pipeline)(unsafe.Pointer(&x.refc05396ea.pipeline))
	x.IndirectCommandsLayout = *(*IndirectCommandsLayoutNV)(unsafe.Pointer(&x.refc05396ea.indirectCommandsLayout))
	x.StreamCount = (uint32)(x.refc05396ea.streamCount)
	packSIndirectCommandsStreamNV(x.PStreams, x.refc05396ea.pStreams)
	x.SequencesCount = (uint32)(x.refc05396ea.sequencesCount)
	x.PreprocessBuffer = *(*Buffer)(unsafe.Pointer(&x.refc05396ea.preprocessBuffer))
	x.PreprocessOffset = (DeviceSize)(x.refc05396ea.preprocessOffset)
	x.PreprocessSize = (DeviceSize)(x.refc05396ea.preprocessSize)
	x.SequencesCountBuffer = *(*Buffer)(unsafe.Pointer(&x.refc05396ea.sequencesCountBuffer))
	x.SequencesCountOffset = (DeviceSize)(x.refc05396ea.sequencesCountOffset)
	x.SequencesIndexBuffer = *(*Buffer)(unsafe.Pointer(&x.refc05396ea.sequencesIndexBuffer))
	x.SequencesIndexOffset = (DeviceSize)(x.refc05396ea.sequencesIndexOffset)
}

// allocGeneratedCommandsMemoryRequirementsInfoNVMemory allocates memory for type C.VkGeneratedCommandsMemoryRequirementsInfoNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocGeneratedCommandsMemoryRequirementsInfoNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfGeneratedCommandsMemoryRequirementsInfoNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfGeneratedCommandsMemoryRequirementsInfoNVValue = unsafe.Sizeof([1]C.VkGeneratedCommandsMemoryRequirementsInfoNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *GeneratedCommandsMemoryRequirementsInfoNV) Ref() *C.VkGeneratedCommandsMemoryRequirementsInfoNV {
	if x == nil {
		return nil
	}
	return x.refe82e5c4c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *GeneratedCommandsMemoryRequirementsInfoNV) Free() {
	if x != nil && x.allocse82e5c4c != nil {
		x.allocse82e5c4c.(*cgoAllocMap).Free()
		x.refe82e5c4c = nil
	}
}

// NewGeneratedCommandsMemoryRequirementsInfoNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewGeneratedCommandsMemoryRequirementsInfoNVRef(ref unsafe.Pointer) *GeneratedCommandsMemoryRequirementsInfoNV {
	if ref == nil {
		return nil
	}
	obj := new(GeneratedCommandsMemoryRequirementsInfoNV)
	obj.refe82e5c4c = (*C.VkGeneratedCommandsMemoryRequirementsInfoNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *GeneratedCommandsMemoryRequirementsInfoNV) PassRef() (*C.VkGeneratedCommandsMemoryRequirementsInfoNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe82e5c4c != nil {
		return x.refe82e5c4c, nil
	}
	meme82e5c4c := allocGeneratedCommandsMemoryRequirementsInfoNVMemory(1)
	refe82e5c4c := (*C.VkGeneratedCommandsMemoryRequirementsInfoNV)(meme82e5c4c)
	allocse82e5c4c := new(cgoAllocMap)
	allocse82e5c4c.Add(meme82e5c4c)

	refe82e5c4c.sType = (C.VkStructureType)(x.SType)

	refe82e5c4c.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	refe82e5c4c.pipelineBindPoint = (C.VkPipelineBindPoint)(x.PipelineBindPoint)

	refe82e5c4c.pipeline = *(*C.VkPipeline)(unsafe.Pointer(&x.Pipeline))

	refe82e5c4c.indirectCommandsLayout = *(*C.VkIndirectCommandsLayoutNV)(unsafe.Pointer(&x.IndirectCommandsLayout))

	refe82e5c4c.maxSequencesCount = (C.uint32_t)(x.MaxSequencesCount)

	x.refe82e5c4c = refe82e5c4c
	x.allocse82e5c4c = allocse82e5c4c
	return refe82e5c4c, allocse82e5c4c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x GeneratedCommandsMemoryRequirementsInfoNV) PassValue() (C.VkGeneratedCommandsMemoryRequirementsInfoNV, *cgoAllocMap) {
	if x.refe82e5c4c != nil {
		return *x.refe82e5c4c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *GeneratedCommandsMemoryRequirementsInfoNV) Deref() {
	if x.refe82e5c4c == nil {
		return
	}
	x.SType = (StructureType)(x.refe82e5c4c.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refe82e5c4c.pNext))
	x.PipelineBindPoint = (PipelineBindPoint)(x.refe82e5c4c.pipelineBindPoint)
	x.Pipeline = *(*Pipeline)(unsafe.Pointer(&x.refe82e5c4c.pipeline))
	x.IndirectCommandsLayout = *(*IndirectCommandsLayoutNV)(unsafe.Pointer(&x.refe82e5c4c.indirectCommandsLayout))
	x.MaxSequencesCount = (uint32)(x.refe82e5c4c.maxSequencesCount)
}

// allocCommandBufferInheritanceViewportScissorInfoNVMemory allocates memory for type C.VkCommandBufferInheritanceViewportScissorInfoNV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCommandBufferInheritanceViewportScissorInfoNVMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCommandBufferInheritanceViewportScissorInfoNVValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCommandBufferInheritanceViewportScissorInfoNVValue = unsafe.Sizeof([1]C.VkCommandBufferInheritanceViewportScissorInfoNV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CommandBufferInheritanceViewportScissorInfoNV) Ref() *C.VkCommandBufferInheritanceViewportScissorInfoNV {
	if x == nil {
		return nil
	}
	return x.refc206d63
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CommandBufferInheritanceViewportScissorInfoNV) Free() {
	if x != nil && x.allocsc206d63 != nil {
		x.allocsc206d63.(*cgoAllocMap).Free()
		x.refc206d63 = nil
	}
}

// NewCommandBufferInheritanceViewportScissorInfoNVRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCommandBufferInheritanceViewportScissorInfoNVRef(ref unsafe.Pointer) *CommandBufferInheritanceViewportScissorInfoNV {
	if ref == nil {
		return nil
	}
	obj := new(CommandBufferInheritanceViewportScissorInfoNV)
	obj.refc206d63 = (*C.VkCommandBufferInheritanceViewportScissorInfoNV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CommandBufferInheritanceViewportScissorInfoNV) PassRef() (*C.VkCommandBufferInheritanceViewportScissorInfoNV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc206d63 != nil {
		return x.refc206d63, nil
	}
	memc206d63 := allocCommandBufferInheritanceViewportScissorInfoNVMemory(1)
	refc206d63 := (*C.VkCommandBufferInheritanceViewportScissorInfoNV)(memc206d63)
	allocsc206d63 := new(cgoAllocMap)
	allocsc206d63.Add(memc206d63)

	refc206d63.sType = (C.VkStructureType)(x.SType)

	refc206d63.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	refc206d63.viewportScissor2D = (C.VkBool32)(x.ViewportScissor2D)

	refc206d63.viewportDepthCount = (C.uint32_t)(x.ViewportDepthCount)

	if x.PViewportDepths != nil {
		var cpViewportDepths_allocs *cgoAllocMap
		refc206d63.pViewportDepths, cpViewportDepths_allocs = copyPViewportBytes((*sliceHeader)(unsafe.Pointer(&x.PViewportDepths)))
		allocsc206d63.Borrow(cpViewportDepths_allocs)
	}

	x.refc206d63 = refc206d63
	x.allocsc206d63 = allocsc206d63
	return refc206d63, allocsc206d63

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CommandBufferInheritanceViewportScissorInfoNV) PassValue() (C.VkCommandBufferInheritanceViewportScissorInfoNV, *cgoAllocMap) {
	if x.refc206d63 != nil {
		return *x.refc206d63, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CommandBufferInheritanceViewportScissorInfoNV) Deref() {
	if x.refc206d63 == nil {
		return
	}
	x.SType = (StructureType)(x.refc206d63.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refc206d63.pNext))
	x.ViewportScissor2D = (Bool32)(x.refc206d63.viewportScissor2D)
	x.ViewportDepthCount = (uint32)(x.refc206d63.viewportDepthCount)
	hxf401b49 := (*sliceHeader)(unsafe.Pointer(&x.PViewportDepths))
	hxf401b49.Data = unsafe.Pointer(x.refc206d63.pViewportDepths)
	hxf401b49.Cap = 0x7fffffff
	// hxf401b49.Len = ? x.PViewportDepths x.refc206d63.pViewportDepths

}

func (x DeviceMemoryReportCallbackFunc) PassRef() (ref *C.PFN_vkDeviceMemoryReportCallbackEXT, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if deviceMemoryReportCallbackFuncE34D104CFunc == nil {
		deviceMemoryReportCallbackFuncE34D104CFunc = x
	}
	return (*C.PFN_vkDeviceMemoryReportCallbackEXT)(C.PFN_vkDeviceMemoryReportCallbackEXT_e34d104c), nil
}

func (x DeviceMemoryReportCallbackFunc) PassValue() (ref C.PFN_vkDeviceMemoryReportCallbackEXT, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if deviceMemoryReportCallbackFuncE34D104CFunc == nil {
		deviceMemoryReportCallbackFuncE34D104CFunc = x
	}
	return (C.PFN_vkDeviceMemoryReportCallbackEXT)(C.PFN_vkDeviceMemoryReportCallbackEXT_e34d104c), nil
}

func NewDeviceMemoryReportCallbackFuncRef(ref unsafe.Pointer) *DeviceMemoryReportCallbackFunc {
	return (*DeviceMemoryReportCallbackFunc)(ref)
}

//export deviceMemoryReportCallbackFuncE34D104C
func deviceMemoryReportCallbackFuncE34D104C(cpCallbackData *C.VkDeviceMemoryReportCallbackDataEXT, cpUserData unsafe.Pointer) {
	if deviceMemoryReportCallbackFuncE34D104CFunc != nil {
		var pCallbackDatae34d104c []DeviceMemoryReportCallbackData
		hxf987077 := (*sliceHeader)(unsafe.Pointer(&pCallbackDatae34d104c))
		hxf987077.Data = unsafe.Pointer(cpCallbackData)
		hxf987077.Cap = 0x7fffffff
		// hxf987077.Len = ?

		pUserDatae34d104c := (unsafe.Pointer)(unsafe.Pointer(cpUserData))
		deviceMemoryReportCallbackFuncE34D104CFunc(pCallbackDatae34d104c, pUserDatae34d104c)
		return
	}
	panic("callback func has not been set (race?)")
}

var deviceMemoryReportCallbackFuncE34D104CFunc DeviceMemoryReportCallbackFunc

// allocDeviceDeviceMemoryReportCreateInfoMemory allocates memory for type C.VkDeviceDeviceMemoryReportCreateInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceDeviceMemoryReportCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceDeviceMemoryReportCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDeviceDeviceMemoryReportCreateInfoValue = unsafe.Sizeof([1]C.VkDeviceDeviceMemoryReportCreateInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DeviceDeviceMemoryReportCreateInfo) Ref() *C.VkDeviceDeviceMemoryReportCreateInfoEXT {
	if x == nil {
		return nil
	}
	return x.refe99f2c76
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DeviceDeviceMemoryReportCreateInfo) Free() {
	if x != nil && x.allocse99f2c76 != nil {
		x.allocse99f2c76.(*cgoAllocMap).Free()
		x.refe99f2c76 = nil
	}
}

// NewDeviceDeviceMemoryReportCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDeviceDeviceMemoryReportCreateInfoRef(ref unsafe.Pointer) *DeviceDeviceMemoryReportCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(DeviceDeviceMemoryReportCreateInfo)
	obj.refe99f2c76 = (*C.VkDeviceDeviceMemoryReportCreateInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DeviceDeviceMemoryReportCreateInfo) PassRef() (*C.VkDeviceDeviceMemoryReportCreateInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe99f2c76 != nil {
		return x.refe99f2c76, nil
	}
	meme99f2c76 := allocDeviceDeviceMemoryReportCreateInfoMemory(1)
	refe99f2c76 := (*C.VkDeviceDeviceMemoryReportCreateInfoEXT)(meme99f2c76)
	allocse99f2c76 := new(cgoAllocMap)
	allocse99f2c76.Add(meme99f2c76)

	refe99f2c76.sType = (C.VkStructureType)(x.SType)

	refe99f2c76.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	refe99f2c76.flags = (C.VkDeviceMemoryReportFlagsEXT)(x.Flags)

	var cpfnUserCallback_allocs *cgoAllocMap
	refe99f2c76.pfnUserCallback, cpfnUserCallback_allocs = x.PfnUserCallback.PassValue()
	allocse99f2c76.Borrow(cpfnUserCallback_allocs)

	refe99f2c76.pUserData = *(*unsafe.Pointer)(unsafe.Pointer(&x.PUserData))

	x.refe99f2c76 = refe99f2c76
	x.allocse99f2c76 = allocse99f2c76
	return refe99f2c76, allocse99f2c76

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DeviceDeviceMemoryReportCreateInfo) PassValue() (C.VkDeviceDeviceMemoryReportCreateInfoEXT, *cgoAllocMap) {
	if x.refe99f2c76 != nil {
		return *x.refe99f2c76, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DeviceDeviceMemoryReportCreateInfo) Deref() {
	if x.refe99f2c76 == nil {
		return
	}
	x.SType = (StructureType)(x.refe99f2c76.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refe99f2c76.pNext))
	x.Flags = (DeviceMemoryReportFlags)(x.refe99f2c76.flags)
	x.PfnUserCallback = *NewDeviceMemoryReportCallbackFuncRef(unsafe.Pointer(&x.refe99f2c76.pfnUserCallback))
	x.PUserData = (unsafe.Pointer)(unsafe.Pointer(x.refe99f2c76.pUserData))
}

// allocSamplerCustomBorderColorCreateInfoMemory allocates memory for type C.VkSamplerCustomBorderColorCreateInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSamplerCustomBorderColorCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSamplerCustomBorderColorCreateInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSamplerCustomBorderColorCreateInfoValue = unsafe.Sizeof([1]C.VkSamplerCustomBorderColorCreateInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SamplerCustomBorderColorCreateInfo) Ref() *C.VkSamplerCustomBorderColorCreateInfoEXT {
	if x == nil {
		return nil
	}
	return x.refcac2582e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SamplerCustomBorderColorCreateInfo) Free() {
	if x != nil && x.allocscac2582e != nil {
		x.allocscac2582e.(*cgoAllocMap).Free()
		x.refcac2582e = nil
	}
}

// NewSamplerCustomBorderColorCreateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSamplerCustomBorderColorCreateInfoRef(ref unsafe.Pointer) *SamplerCustomBorderColorCreateInfo {
	if ref == nil {
		return nil
	}
	obj := new(SamplerCustomBorderColorCreateInfo)
	obj.refcac2582e = (*C.VkSamplerCustomBorderColorCreateInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SamplerCustomBorderColorCreateInfo) PassRef() (*C.VkSamplerCustomBorderColorCreateInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refcac2582e != nil {
		return x.refcac2582e, nil
	}
	memcac2582e := allocSamplerCustomBorderColorCreateInfoMemory(1)
	refcac2582e := (*C.VkSamplerCustomBorderColorCreateInfoEXT)(memcac2582e)
	allocscac2582e := new(cgoAllocMap)
	allocscac2582e.Add(memcac2582e)

	refcac2582e.sType = (C.VkStructureType)(x.SType)

	refcac2582e.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	refcac2582e.customBorderColor = *(*C.VkClearColorValue)(unsafe.Pointer(&x.CustomBorderColor))

	refcac2582e.format = (C.VkFormat)(x.Format)

	x.refcac2582e = refcac2582e
	x.allocscac2582e = allocscac2582e
	return refcac2582e, allocscac2582e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SamplerCustomBorderColorCreateInfo) PassValue() (C.VkSamplerCustomBorderColorCreateInfoEXT, *cgoAllocMap) {
	if x.refcac2582e != nil {
		return *x.refcac2582e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SamplerCustomBorderColorCreateInfo) Deref() {
	if x.refcac2582e == nil {
		return
	}
	x.SType = (StructureType)(x.refcac2582e.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refcac2582e.pNext))
	x.CustomBorderColor = *(*ClearColorValue)(unsafe.Pointer(&x.refcac2582e.customBorderColor))
	x.Format = (Format)(x.refcac2582e.format)
}

// allocDescriptorBufferBindingPushDescriptorBufferHandleMemory allocates memory for type C.VkDescriptorBufferBindingPushDescriptorBufferHandleEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDescriptorBufferBindingPushDescriptorBufferHandleMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDescriptorBufferBindingPushDescriptorBufferHandleValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDescriptorBufferBindingPushDescriptorBufferHandleValue = unsafe.Sizeof([1]C.VkDescriptorBufferBindingPushDescriptorBufferHandleEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DescriptorBufferBindingPushDescriptorBufferHandle) Ref() *C.VkDescriptorBufferBindingPushDescriptorBufferHandleEXT {
	if x == nil {
		return nil
	}
	return x.ref14f143c5
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DescriptorBufferBindingPushDescriptorBufferHandle) Free() {
	if x != nil && x.allocs14f143c5 != nil {
		x.allocs14f143c5.(*cgoAllocMap).Free()
		x.ref14f143c5 = nil
	}
}

// NewDescriptorBufferBindingPushDescriptorBufferHandleRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDescriptorBufferBindingPushDescriptorBufferHandleRef(ref unsafe.Pointer) *DescriptorBufferBindingPushDescriptorBufferHandle {
	if ref == nil {
		return nil
	}
	obj := new(DescriptorBufferBindingPushDescriptorBufferHandle)
	obj.ref14f143c5 = (*C.VkDescriptorBufferBindingPushDescriptorBufferHandleEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DescriptorBufferBindingPushDescriptorBufferHandle) PassRef() (*C.VkDescriptorBufferBindingPushDescriptorBufferHandleEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref14f143c5 != nil {
		return x.ref14f143c5, nil
	}
	mem14f143c5 := allocDescriptorBufferBindingPushDescriptorBufferHandleMemory(1)
	ref14f143c5 := (*C.VkDescriptorBufferBindingPushDescriptorBufferHandleEXT)(mem14f143c5)
	allocs14f143c5 := new(cgoAllocMap)
	allocs14f143c5.Add(mem14f143c5)

	ref14f143c5.sType = (C.VkStructureType)(x.SType)

	ref14f143c5.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref14f143c5.buffer = *(*C.VkBuffer)(unsafe.Pointer(&x.Buffer))

	x.ref14f143c5 = ref14f143c5
	x.allocs14f143c5 = allocs14f143c5
	return ref14f143c5, allocs14f143c5

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DescriptorBufferBindingPushDescriptorBufferHandle) PassValue() (C.VkDescriptorBufferBindingPushDescriptorBufferHandleEXT, *cgoAllocMap) {
	if x.ref14f143c5 != nil {
		return *x.ref14f143c5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DescriptorBufferBindingPushDescriptorBufferHandle) Deref() {
	if x.ref14f143c5 == nil {
		return
	}
	x.SType = (StructureType)(x.ref14f143c5.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref14f143c5.pNext))
	x.Buffer = *(*Buffer)(unsafe.Pointer(&x.ref14f143c5.buffer))
}

// allocDescriptorGetInfoMemory allocates memory for type C.VkDescriptorGetInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDescriptorGetInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDescriptorGetInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDescriptorGetInfoValue = unsafe.Sizeof([1]C.VkDescriptorGetInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DescriptorGetInfo) Ref() *C.VkDescriptorGetInfoEXT {
	if x == nil {
		return nil
	}
	return x.ref15e17023
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DescriptorGetInfo) Free() {
	if x != nil && x.allocs15e17023 != nil {
		x.allocs15e17023.(*cgoAllocMap).Free()
		x.ref15e17023 = nil
	}
}

// NewDescriptorGetInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDescriptorGetInfoRef(ref unsafe.Pointer) *DescriptorGetInfo {
	if ref == nil {
		return nil
	}
	obj := new(DescriptorGetInfo)
	obj.ref15e17023 = (*C.VkDescriptorGetInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DescriptorGetInfo) PassRef() (*C.VkDescriptorGetInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref15e17023 != nil {
		return x.ref15e17023, nil
	}
	mem15e17023 := allocDescriptorGetInfoMemory(1)
	ref15e17023 := (*C.VkDescriptorGetInfoEXT)(mem15e17023)
	allocs15e17023 := new(cgoAllocMap)
	allocs15e17023.Add(mem15e17023)

	ref15e17023.sType = (C.VkStructureType)(x.SType)

	ref15e17023.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref15e17023._type = (C.VkDescriptorType)(x.Type)

	ref15e17023.data = *(*C.VkDescriptorDataEXT)(unsafe.Pointer(&x.Data))

	x.ref15e17023 = ref15e17023
	x.allocs15e17023 = allocs15e17023
	return ref15e17023, allocs15e17023

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DescriptorGetInfo) PassValue() (C.VkDescriptorGetInfoEXT, *cgoAllocMap) {
	if x.ref15e17023 != nil {
		return *x.ref15e17023, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DescriptorGetInfo) Deref() {
	if x.ref15e17023 == nil {
		return
	}
	x.SType = (StructureType)(x.ref15e17023.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref15e17023.pNext))
	x.Type = (DescriptorType)(x.ref15e17023._type)
	x.Data = *(*DescriptorData)(unsafe.Pointer(&x.ref15e17023.data))
}

// allocBufferCaptureDescriptorDataInfoMemory allocates memory for type C.VkBufferCaptureDescriptorDataInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBufferCaptureDescriptorDataInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBufferCaptureDescriptorDataInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBufferCaptureDescriptorDataInfoValue = unsafe.Sizeof([1]C.VkBufferCaptureDescriptorDataInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BufferCaptureDescriptorDataInfo) Ref() *C.VkBufferCaptureDescriptorDataInfoEXT {
	if x == nil {
		return nil
	}
	return x.ref7d170bdd
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BufferCaptureDescriptorDataInfo) Free() {
	if x != nil && x.allocs7d170bdd != nil {
		x.allocs7d170bdd.(*cgoAllocMap).Free()
		x.ref7d170bdd = nil
	}
}

// NewBufferCaptureDescriptorDataInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBufferCaptureDescriptorDataInfoRef(ref unsafe.Pointer) *BufferCaptureDescriptorDataInfo {
	if ref == nil {
		return nil
	}
	obj := new(BufferCaptureDescriptorDataInfo)
	obj.ref7d170bdd = (*C.VkBufferCaptureDescriptorDataInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BufferCaptureDescriptorDataInfo) PassRef() (*C.VkBufferCaptureDescriptorDataInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7d170bdd != nil {
		return x.ref7d170bdd, nil
	}
	mem7d170bdd := allocBufferCaptureDescriptorDataInfoMemory(1)
	ref7d170bdd := (*C.VkBufferCaptureDescriptorDataInfoEXT)(mem7d170bdd)
	allocs7d170bdd := new(cgoAllocMap)
	allocs7d170bdd.Add(mem7d170bdd)

	ref7d170bdd.sType = (C.VkStructureType)(x.SType)

	ref7d170bdd.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref7d170bdd.buffer = *(*C.VkBuffer)(unsafe.Pointer(&x.Buffer))

	x.ref7d170bdd = ref7d170bdd
	x.allocs7d170bdd = allocs7d170bdd
	return ref7d170bdd, allocs7d170bdd

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BufferCaptureDescriptorDataInfo) PassValue() (C.VkBufferCaptureDescriptorDataInfoEXT, *cgoAllocMap) {
	if x.ref7d170bdd != nil {
		return *x.ref7d170bdd, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BufferCaptureDescriptorDataInfo) Deref() {
	if x.ref7d170bdd == nil {
		return
	}
	x.SType = (StructureType)(x.ref7d170bdd.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref7d170bdd.pNext))
	x.Buffer = *(*Buffer)(unsafe.Pointer(&x.ref7d170bdd.buffer))
}

// allocImageCaptureDescriptorDataInfoMemory allocates memory for type C.VkImageCaptureDescriptorDataInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageCaptureDescriptorDataInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageCaptureDescriptorDataInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfImageCaptureDescriptorDataInfoValue = unsafe.Sizeof([1]C.VkImageCaptureDescriptorDataInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImageCaptureDescriptorDataInfo) Ref() *C.VkImageCaptureDescriptorDataInfoEXT {
	if x == nil {
		return nil
	}
	return x.refc02d1ea8
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImageCaptureDescriptorDataInfo) Free() {
	if x != nil && x.allocsc02d1ea8 != nil {
		x.allocsc02d1ea8.(*cgoAllocMap).Free()
		x.refc02d1ea8 = nil
	}
}

// NewImageCaptureDescriptorDataInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageCaptureDescriptorDataInfoRef(ref unsafe.Pointer) *ImageCaptureDescriptorDataInfo {
	if ref == nil {
		return nil
	}
	obj := new(ImageCaptureDescriptorDataInfo)
	obj.refc02d1ea8 = (*C.VkImageCaptureDescriptorDataInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImageCaptureDescriptorDataInfo) PassRef() (*C.VkImageCaptureDescriptorDataInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc02d1ea8 != nil {
		return x.refc02d1ea8, nil
	}
	memc02d1ea8 := allocImageCaptureDescriptorDataInfoMemory(1)
	refc02d1ea8 := (*C.VkImageCaptureDescriptorDataInfoEXT)(memc02d1ea8)
	allocsc02d1ea8 := new(cgoAllocMap)
	allocsc02d1ea8.Add(memc02d1ea8)

	refc02d1ea8.sType = (C.VkStructureType)(x.SType)

	refc02d1ea8.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	refc02d1ea8.image = *(*C.VkImage)(unsafe.Pointer(&x.Image))

	x.refc02d1ea8 = refc02d1ea8
	x.allocsc02d1ea8 = allocsc02d1ea8
	return refc02d1ea8, allocsc02d1ea8

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImageCaptureDescriptorDataInfo) PassValue() (C.VkImageCaptureDescriptorDataInfoEXT, *cgoAllocMap) {
	if x.refc02d1ea8 != nil {
		return *x.refc02d1ea8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImageCaptureDescriptorDataInfo) Deref() {
	if x.refc02d1ea8 == nil {
		return
	}
	x.SType = (StructureType)(x.refc02d1ea8.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refc02d1ea8.pNext))
	x.Image = *(*Image)(unsafe.Pointer(&x.refc02d1ea8.image))
}

// allocImageViewCaptureDescriptorDataInfoMemory allocates memory for type C.VkImageViewCaptureDescriptorDataInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageViewCaptureDescriptorDataInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageViewCaptureDescriptorDataInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfImageViewCaptureDescriptorDataInfoValue = unsafe.Sizeof([1]C.VkImageViewCaptureDescriptorDataInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImageViewCaptureDescriptorDataInfo) Ref() *C.VkImageViewCaptureDescriptorDataInfoEXT {
	if x == nil {
		return nil
	}
	return x.refe2b761d2
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImageViewCaptureDescriptorDataInfo) Free() {
	if x != nil && x.allocse2b761d2 != nil {
		x.allocse2b761d2.(*cgoAllocMap).Free()
		x.refe2b761d2 = nil
	}
}

// NewImageViewCaptureDescriptorDataInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageViewCaptureDescriptorDataInfoRef(ref unsafe.Pointer) *ImageViewCaptureDescriptorDataInfo {
	if ref == nil {
		return nil
	}
	obj := new(ImageViewCaptureDescriptorDataInfo)
	obj.refe2b761d2 = (*C.VkImageViewCaptureDescriptorDataInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImageViewCaptureDescriptorDataInfo) PassRef() (*C.VkImageViewCaptureDescriptorDataInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe2b761d2 != nil {
		return x.refe2b761d2, nil
	}
	meme2b761d2 := allocImageViewCaptureDescriptorDataInfoMemory(1)
	refe2b761d2 := (*C.VkImageViewCaptureDescriptorDataInfoEXT)(meme2b761d2)
	allocse2b761d2 := new(cgoAllocMap)
	allocse2b761d2.Add(meme2b761d2)

	refe2b761d2.sType = (C.VkStructureType)(x.SType)

	refe2b761d2.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	refe2b761d2.imageView = *(*C.VkImageView)(unsafe.Pointer(&x.ImageView))

	x.refe2b761d2 = refe2b761d2
	x.allocse2b761d2 = allocse2b761d2
	return refe2b761d2, allocse2b761d2

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImageViewCaptureDescriptorDataInfo) PassValue() (C.VkImageViewCaptureDescriptorDataInfoEXT, *cgoAllocMap) {
	if x.refe2b761d2 != nil {
		return *x.refe2b761d2, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImageViewCaptureDescriptorDataInfo) Deref() {
	if x.refe2b761d2 == nil {
		return
	}
	x.SType = (StructureType)(x.refe2b761d2.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.refe2b761d2.pNext))
	x.ImageView = *(*ImageView)(unsafe.Pointer(&x.refe2b761d2.imageView))
}

// allocSamplerCaptureDescriptorDataInfoMemory allocates memory for type C.VkSamplerCaptureDescriptorDataInfoEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSamplerCaptureDescriptorDataInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSamplerCaptureDescriptorDataInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSamplerCaptureDescriptorDataInfoValue = unsafe.Sizeof([1]C.VkSamplerCaptureDescriptorDataInfoEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SamplerCaptureDescriptorDataInfo) Ref() *C.VkSamplerCaptureDescriptorDataInfoEXT {
	if x == nil {
		return nil
	}
	return x.ref2455cc7e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SamplerCaptureDescriptorDataInfo) Free() {
	if x != nil && x.allocs2455cc7e != nil {
		x.allocs2455cc7e.(*cgoAllocMap).Free()
		x.ref2455cc7e = nil
	}
}

// NewSamplerCaptureDescriptorDataInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSamplerCaptureDescriptorDataInfoRef(ref unsafe.Pointer) *SamplerCaptureDescriptorDataInfo {
	if ref == nil {
		return nil
	}
	obj := new(SamplerCaptureDescriptorDataInfo)
	obj.ref2455cc7e = (*C.VkSamplerCaptureDescriptorDataInfoEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SamplerCaptureDescriptorDataInfo) PassRef() (*C.VkSamplerCaptureDescriptorDataInfoEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2455cc7e != nil {
		return x.ref2455cc7e, nil
	}
	mem2455cc7e := allocSamplerCaptureDescriptorDataInfoMemory(1)
	ref2455cc7e := (*C.VkSamplerCaptureDescriptorDataInfoEXT)(mem2455cc7e)
	allocs2455cc7e := new(cgoAllocMap)
	allocs2455cc7e.Add(mem2455cc7e)

	ref2455cc7e.sType = (C.VkStructureType)(x.SType)

	ref2455cc7e.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref2455cc7e.sampler = *(*C.VkSampler)(unsafe.Pointer(&x.Sampler))

	x.ref2455cc7e = ref2455cc7e
	x.allocs2455cc7e = allocs2455cc7e
	return ref2455cc7e, allocs2455cc7e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SamplerCaptureDescriptorDataInfo) PassValue() (C.VkSamplerCaptureDescriptorDataInfoEXT, *cgoAllocMap) {
	if x.ref2455cc7e != nil {
		return *x.ref2455cc7e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SamplerCaptureDescriptorDataInfo) Deref() {
	if x.ref2455cc7e == nil {
		return
	}
	x.SType = (StructureType)(x.ref2455cc7e.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref2455cc7e.pNext))
	x.Sampler = *(*Sampler)(unsafe.Pointer(&x.ref2455cc7e.sampler))
}

// allocImageCompressionControlMemory allocates memory for type C.VkImageCompressionControlEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageCompressionControlMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageCompressionControlValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfImageCompressionControlValue = unsafe.Sizeof([1]C.VkImageCompressionControlEXT{})

// copyPImageCompressionFixedRateFlagsBytes copies the data from Go slice as *C.VkImageCompressionFixedRateFlagsEXT.
func copyPImageCompressionFixedRateFlagsBytes(slice *sliceHeader) (*C.VkImageCompressionFixedRateFlagsEXT, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfImageCompressionFixedRateFlagsValue) * slice.Len,
		Cap:  int(sizeOfImageCompressionFixedRateFlagsValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkImageCompressionFixedRateFlagsEXT)(mem0), allocs
}

// allocImageCompressionFixedRateFlagsMemory allocates memory for type C.VkImageCompressionFixedRateFlagsEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageCompressionFixedRateFlagsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageCompressionFixedRateFlagsValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfImageCompressionFixedRateFlagsValue = unsafe.Sizeof([1]C.VkImageCompressionFixedRateFlagsEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ImageCompressionControl) Ref() *C.VkImageCompressionControlEXT {
	if x == nil {
		return nil
	}
	return x.ref37cbe96e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ImageCompressionControl) Free() {
	if x != nil && x.allocs37cbe96e != nil {
		x.allocs37cbe96e.(*cgoAllocMap).Free()
		x.ref37cbe96e = nil
	}
}

// NewImageCompressionControlRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageCompressionControlRef(ref unsafe.Pointer) *ImageCompressionControl {
	if ref == nil {
		return nil
	}
	obj := new(ImageCompressionControl)
	obj.ref37cbe96e = (*C.VkImageCompressionControlEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ImageCompressionControl) PassRef() (*C.VkImageCompressionControlEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref37cbe96e != nil {
		return x.ref37cbe96e, nil
	}
	mem37cbe96e := allocImageCompressionControlMemory(1)
	ref37cbe96e := (*C.VkImageCompressionControlEXT)(mem37cbe96e)
	allocs37cbe96e := new(cgoAllocMap)
	allocs37cbe96e.Add(mem37cbe96e)

	ref37cbe96e.sType = (C.VkStructureType)(x.SType)

	ref37cbe96e.pNext = *(*unsafe.Pointer)(unsafe.Pointer(&x.PNext))

	ref37cbe96e.flags = (C.VkImageCompressionFlagsEXT)(x.Flags)

	ref37cbe96e.compressionControlPlaneCount = (C.uint32_t)(x.CompressionControlPlaneCount)

	if x.PFixedRateFlags != nil {
		var cpFixedRateFlags_allocs *cgoAllocMap
		ref37cbe96e.pFixedRateFlags, cpFixedRateFlags_allocs = copyPImageCompressionFixedRateFlagsBytes((*sliceHeader)(unsafe.Pointer(&x.PFixedRateFlags)))
		allocs37cbe96e.Borrow(cpFixedRateFlags_allocs)
	}

	x.ref37cbe96e = ref37cbe96e
	x.allocs37cbe96e = allocs37cbe96e
	return ref37cbe96e, allocs37cbe96e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ImageCompressionControl) PassValue() (C.VkImageCompressionControlEXT, *cgoAllocMap) {
	if x.ref37cbe96e != nil {
		return *x.ref37cbe96e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ImageCompressionControl) Deref() {
	if x.ref37cbe96e == nil {
		return
	}
	x.SType = (StructureType)(x.ref37cbe96e.sType)
	x.PNext = (unsafe.Pointer)(unsafe.Pointer(x.ref37cbe96e.pNext))
	x.Flags = (ImageCompressionFlags)(x.ref37cbe96e.flags)
	x.CompressionControlPlaneCount = (uint32)(x.ref37cbe96e.compressionControlPlaneCount)
	hxf5eacde := (*sliceHeader)(unsafe.Pointer(&x.PFixedRateFlags))
	hxf5eacde.Data = unsafe.Pointer(x.ref37cbe96e.pFixedRateFlags)
	hxf5eacde.Cap = 0x7fffffff
	// hxf5eacde.Len = ? x.PFixedRateFlags x.ref37cbe96e.pFixedRateFlags

}

// copyPQueueFamilyPropertiesBytes copies the data from Go slice as *C.VkQueueFamilyProperties.
func copyPQueueFamilyPropertiesBytes(slice *sliceHeader) (*C.VkQueueFamilyProperties, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfQueueFamilyPropertiesValue) * slice.Len,
		Cap:  int(sizeOfQueueFamilyPropertiesValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkQueueFamilyProperties)(mem0), allocs
}

// allocQueueFamilyPropertiesMemory allocates memory for type C.VkQueueFamilyProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocQueueFamilyPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfQueueFamilyPropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfQueueFamilyPropertiesValue = unsafe.Sizeof([1]C.VkQueueFamilyProperties{})

// unpackArgSExtensionProperties transforms a sliced Go data structure into plain C format.
func unpackArgSExtensionProperties(x []ExtensionProperties) (unpacked *C.VkExtensionProperties, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocExtensionPropertiesMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkExtensionProperties)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkExtensionProperties)(h.Data)
	return
}

// unpackArgSLayerProperties transforms a sliced Go data structure into plain C format.
func unpackArgSLayerProperties(x []LayerProperties) (unpacked *C.VkLayerProperties, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocLayerPropertiesMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkLayerProperties)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkLayerProperties)(h.Data)
	return
}

// packSLayerProperties reads sliced Go data structure out from plain C format.
func packSLayerProperties(v []LayerProperties, ptr0 *C.VkLayerProperties) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfLayerPropertiesValue]C.VkLayerProperties)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewLayerPropertiesRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSSubmitInfo transforms a sliced Go data structure into plain C format.
func unpackArgSSubmitInfo(x []SubmitInfo) (unpacked *C.VkSubmitInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocSubmitInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSubmitInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSubmitInfo)(h.Data)
	return
}

// unpackArgSMappedMemoryRange transforms a sliced Go data structure into plain C format.
func unpackArgSMappedMemoryRange(x []MappedMemoryRange) (unpacked *C.VkMappedMemoryRange, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocMappedMemoryRangeMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkMappedMemoryRange)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkMappedMemoryRange)(h.Data)
	return
}

// copyPSparseImageMemoryRequirementsBytes copies the data from Go slice as *C.VkSparseImageMemoryRequirements.
func copyPSparseImageMemoryRequirementsBytes(slice *sliceHeader) (*C.VkSparseImageMemoryRequirements, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfSparseImageMemoryRequirementsValue) * slice.Len,
		Cap:  int(sizeOfSparseImageMemoryRequirementsValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkSparseImageMemoryRequirements)(mem0), allocs
}

// allocSparseImageMemoryRequirementsMemory allocates memory for type C.VkSparseImageMemoryRequirements in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSparseImageMemoryRequirementsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSparseImageMemoryRequirementsValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSparseImageMemoryRequirementsValue = unsafe.Sizeof([1]C.VkSparseImageMemoryRequirements{})

// copyPSparseImageFormatPropertiesBytes copies the data from Go slice as *C.VkSparseImageFormatProperties.
func copyPSparseImageFormatPropertiesBytes(slice *sliceHeader) (*C.VkSparseImageFormatProperties, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfSparseImageFormatPropertiesValue) * slice.Len,
		Cap:  int(sizeOfSparseImageFormatPropertiesValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkSparseImageFormatProperties)(mem0), allocs
}

// allocSparseImageFormatPropertiesMemory allocates memory for type C.VkSparseImageFormatProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSparseImageFormatPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSparseImageFormatPropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSparseImageFormatPropertiesValue = unsafe.Sizeof([1]C.VkSparseImageFormatProperties{})

// unpackArgSBindSparseInfo transforms a sliced Go data structure into plain C format.
func unpackArgSBindSparseInfo(x []BindSparseInfo) (unpacked *C.VkBindSparseInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocBindSparseInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkBindSparseInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkBindSparseInfo)(h.Data)
	return
}

// copyPPipelineCacheBytes copies the data from Go slice as *C.VkPipelineCache.
func copyPPipelineCacheBytes(slice *sliceHeader) (*C.VkPipelineCache, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfPipelineCacheValue) * slice.Len,
		Cap:  int(sizeOfPipelineCacheValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkPipelineCache)(mem0), allocs
}

// allocPipelineCacheMemory allocates memory for type C.VkPipelineCache in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPipelineCacheMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPipelineCacheValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPipelineCacheValue = unsafe.Sizeof([1]C.VkPipelineCache{})

// unpackArgSGraphicsPipelineCreateInfo transforms a sliced Go data structure into plain C format.
func unpackArgSGraphicsPipelineCreateInfo(x []GraphicsPipelineCreateInfo) (unpacked *C.VkGraphicsPipelineCreateInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocGraphicsPipelineCreateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkGraphicsPipelineCreateInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkGraphicsPipelineCreateInfo)(h.Data)
	return
}

// unpackArgSComputePipelineCreateInfo transforms a sliced Go data structure into plain C format.
func unpackArgSComputePipelineCreateInfo(x []ComputePipelineCreateInfo) (unpacked *C.VkComputePipelineCreateInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocComputePipelineCreateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkComputePipelineCreateInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkComputePipelineCreateInfo)(h.Data)
	return
}

// unpackArgSWriteDescriptorSet transforms a sliced Go data structure into plain C format.
func unpackArgSWriteDescriptorSet(x []WriteDescriptorSet) (unpacked *C.VkWriteDescriptorSet, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocWriteDescriptorSetMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkWriteDescriptorSet)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkWriteDescriptorSet)(h.Data)
	return
}

// unpackArgSCopyDescriptorSet transforms a sliced Go data structure into plain C format.
func unpackArgSCopyDescriptorSet(x []CopyDescriptorSet) (unpacked *C.VkCopyDescriptorSet, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocCopyDescriptorSetMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkCopyDescriptorSet)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkCopyDescriptorSet)(h.Data)
	return
}

// copyPDescriptorSetBytes copies the data from Go slice as *C.VkDescriptorSet.
func copyPDescriptorSetBytes(slice *sliceHeader) (*C.VkDescriptorSet, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfDescriptorSetValue) * slice.Len,
		Cap:  int(sizeOfDescriptorSetValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkDescriptorSet)(mem0), allocs
}

// allocDescriptorSetMemory allocates memory for type C.VkDescriptorSet in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDescriptorSetMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDescriptorSetValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDescriptorSetValue = unsafe.Sizeof([1]C.VkDescriptorSet{})

// copyPBufferBytes copies the data from Go slice as *C.VkBuffer.
func copyPBufferBytes(slice *sliceHeader) (*C.VkBuffer, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfBufferValue) * slice.Len,
		Cap:  int(sizeOfBufferValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkBuffer)(mem0), allocs
}

// allocBufferMemory allocates memory for type C.VkBuffer in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBufferMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBufferValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBufferValue = unsafe.Sizeof([1]C.VkBuffer{})

// copyPDeviceSizeBytes copies the data from Go slice as *C.VkDeviceSize.
func copyPDeviceSizeBytes(slice *sliceHeader) (*C.VkDeviceSize, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfDeviceSizeValue) * slice.Len,
		Cap:  int(sizeOfDeviceSizeValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkDeviceSize)(mem0), allocs
}

// allocDeviceSizeMemory allocates memory for type C.VkDeviceSize in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceSizeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceSizeValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDeviceSizeValue = unsafe.Sizeof([1]C.VkDeviceSize{})

// copyPBufferCopyBytes copies the data from Go slice as *C.VkBufferCopy.
func copyPBufferCopyBytes(slice *sliceHeader) (*C.VkBufferCopy, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfBufferCopyValue) * slice.Len,
		Cap:  int(sizeOfBufferCopyValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkBufferCopy)(mem0), allocs
}

// allocBufferCopyMemory allocates memory for type C.VkBufferCopy in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBufferCopyMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBufferCopyValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBufferCopyValue = unsafe.Sizeof([1]C.VkBufferCopy{})

// copyPImageCopyBytes copies the data from Go slice as *C.VkImageCopy.
func copyPImageCopyBytes(slice *sliceHeader) (*C.VkImageCopy, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfImageCopyValue) * slice.Len,
		Cap:  int(sizeOfImageCopyValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkImageCopy)(mem0), allocs
}

// allocImageCopyMemory allocates memory for type C.VkImageCopy in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageCopyMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageCopyValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfImageCopyValue = unsafe.Sizeof([1]C.VkImageCopy{})

// copyPImageBlitBytes copies the data from Go slice as *C.VkImageBlit.
func copyPImageBlitBytes(slice *sliceHeader) (*C.VkImageBlit, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfImageBlitValue) * slice.Len,
		Cap:  int(sizeOfImageBlitValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkImageBlit)(mem0), allocs
}

// allocImageBlitMemory allocates memory for type C.VkImageBlit in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageBlitMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageBlitValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfImageBlitValue = unsafe.Sizeof([1]C.VkImageBlit{})

// copyPBufferImageCopyBytes copies the data from Go slice as *C.VkBufferImageCopy.
func copyPBufferImageCopyBytes(slice *sliceHeader) (*C.VkBufferImageCopy, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfBufferImageCopyValue) * slice.Len,
		Cap:  int(sizeOfBufferImageCopyValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkBufferImageCopy)(mem0), allocs
}

// allocBufferImageCopyMemory allocates memory for type C.VkBufferImageCopy in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBufferImageCopyMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBufferImageCopyValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBufferImageCopyValue = unsafe.Sizeof([1]C.VkBufferImageCopy{})

// copyPImageSubresourceRangeBytes copies the data from Go slice as *C.VkImageSubresourceRange.
func copyPImageSubresourceRangeBytes(slice *sliceHeader) (*C.VkImageSubresourceRange, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfImageSubresourceRangeValue) * slice.Len,
		Cap:  int(sizeOfImageSubresourceRangeValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkImageSubresourceRange)(mem0), allocs
}

// allocImageSubresourceRangeMemory allocates memory for type C.VkImageSubresourceRange in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageSubresourceRangeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageSubresourceRangeValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfImageSubresourceRangeValue = unsafe.Sizeof([1]C.VkImageSubresourceRange{})

// unpackArgSClearAttachment transforms a sliced Go data structure into plain C format.
func unpackArgSClearAttachment(x []ClearAttachment) (unpacked *C.VkClearAttachment, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocClearAttachmentMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkClearAttachment)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkClearAttachment)(h.Data)
	return
}

// copyPClearRectBytes copies the data from Go slice as *C.VkClearRect.
func copyPClearRectBytes(slice *sliceHeader) (*C.VkClearRect, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfClearRectValue) * slice.Len,
		Cap:  int(sizeOfClearRectValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkClearRect)(mem0), allocs
}

// allocClearRectMemory allocates memory for type C.VkClearRect in C.
// The caller is responsible for freeing the this memory via C.free.
func allocClearRectMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfClearRectValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfClearRectValue = unsafe.Sizeof([1]C.VkClearRect{})

// copyPImageResolveBytes copies the data from Go slice as *C.VkImageResolve.
func copyPImageResolveBytes(slice *sliceHeader) (*C.VkImageResolve, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfImageResolveValue) * slice.Len,
		Cap:  int(sizeOfImageResolveValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkImageResolve)(mem0), allocs
}

// allocImageResolveMemory allocates memory for type C.VkImageResolve in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageResolveMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageResolveValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfImageResolveValue = unsafe.Sizeof([1]C.VkImageResolve{})

// copyPEventBytes copies the data from Go slice as *C.VkEvent.
func copyPEventBytes(slice *sliceHeader) (*C.VkEvent, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfEventValue) * slice.Len,
		Cap:  int(sizeOfEventValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkEvent)(mem0), allocs
}

// allocEventMemory allocates memory for type C.VkEvent in C.
// The caller is responsible for freeing the this memory via C.free.
func allocEventMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfEventValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfEventValue = unsafe.Sizeof([1]C.VkEvent{})

// copyPMemoryBarrierBytes copies the data from Go slice as *C.VkMemoryBarrier.
func copyPMemoryBarrierBytes(slice *sliceHeader) (*C.VkMemoryBarrier, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfMemoryBarrierValue) * slice.Len,
		Cap:  int(sizeOfMemoryBarrierValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkMemoryBarrier)(mem0), allocs
}

// allocMemoryBarrierMemory allocates memory for type C.VkMemoryBarrier in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMemoryBarrierMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMemoryBarrierValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfMemoryBarrierValue = unsafe.Sizeof([1]C.VkMemoryBarrier{})

// unpackArgSBufferMemoryBarrier transforms a sliced Go data structure into plain C format.
func unpackArgSBufferMemoryBarrier(x []BufferMemoryBarrier) (unpacked *C.VkBufferMemoryBarrier, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocBufferMemoryBarrierMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkBufferMemoryBarrier)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkBufferMemoryBarrier)(h.Data)
	return
}

// unpackArgSImageMemoryBarrier transforms a sliced Go data structure into plain C format.
func unpackArgSImageMemoryBarrier(x []ImageMemoryBarrier) (unpacked *C.VkImageMemoryBarrier, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocImageMemoryBarrierMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkImageMemoryBarrier)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkImageMemoryBarrier)(h.Data)
	return
}

// copyPSurfaceFormatBytes copies the data from Go slice as *C.VkSurfaceFormatKHR.
func copyPSurfaceFormatBytes(slice *sliceHeader) (*C.VkSurfaceFormatKHR, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfSurfaceFormatValue) * slice.Len,
		Cap:  int(sizeOfSurfaceFormatValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkSurfaceFormatKHR)(mem0), allocs
}

// allocSurfaceFormatMemory allocates memory for type C.VkSurfaceFormatKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSurfaceFormatMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSurfaceFormatValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSurfaceFormatValue = unsafe.Sizeof([1]C.VkSurfaceFormatKHR{})

// copyPImageBytes copies the data from Go slice as *C.VkImage.
func copyPImageBytes(slice *sliceHeader) (*C.VkImage, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfImageValue) * slice.Len,
		Cap:  int(sizeOfImageValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkImage)(mem0), allocs
}

// allocImageMemory allocates memory for type C.VkImage in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfImageValue = unsafe.Sizeof([1]C.VkImage{})

// unpackArgSDisplayProperties transforms a sliced Go data structure into plain C format.
func unpackArgSDisplayProperties(x []DisplayProperties) (unpacked *C.VkDisplayPropertiesKHR, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocDisplayPropertiesMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkDisplayPropertiesKHR)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkDisplayPropertiesKHR)(h.Data)
	return
}

// packSDisplayProperties reads sliced Go data structure out from plain C format.
func packSDisplayProperties(v []DisplayProperties, ptr0 *C.VkDisplayPropertiesKHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDisplayPropertiesValue]C.VkDisplayPropertiesKHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDisplayPropertiesRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSDisplayPlaneProperties transforms a sliced Go data structure into plain C format.
func unpackArgSDisplayPlaneProperties(x []DisplayPlaneProperties) (unpacked *C.VkDisplayPlanePropertiesKHR, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocDisplayPlanePropertiesMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkDisplayPlanePropertiesKHR)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkDisplayPlanePropertiesKHR)(h.Data)
	return
}

// packSDisplayPlaneProperties reads sliced Go data structure out from plain C format.
func packSDisplayPlaneProperties(v []DisplayPlaneProperties, ptr0 *C.VkDisplayPlanePropertiesKHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDisplayPlanePropertiesValue]C.VkDisplayPlanePropertiesKHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDisplayPlanePropertiesRef(unsafe.Pointer(&ptr1))
	}
}

// copyPDisplayBytes copies the data from Go slice as *C.VkDisplayKHR.
func copyPDisplayBytes(slice *sliceHeader) (*C.VkDisplayKHR, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfDisplayValue) * slice.Len,
		Cap:  int(sizeOfDisplayValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VkDisplayKHR)(mem0), allocs
}

// allocDisplayMemory allocates memory for type C.VkDisplayKHR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDisplayMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDisplayValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDisplayValue = unsafe.Sizeof([1]C.VkDisplayKHR{})

// unpackArgSDisplayModeProperties transforms a sliced Go data structure into plain C format.
func unpackArgSDisplayModeProperties(x []DisplayModeProperties) (unpacked *C.VkDisplayModePropertiesKHR, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocDisplayModePropertiesMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkDisplayModePropertiesKHR)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkDisplayModePropertiesKHR)(h.Data)
	return
}

// packSDisplayModeProperties reads sliced Go data structure out from plain C format.
func packSDisplayModeProperties(v []DisplayModeProperties, ptr0 *C.VkDisplayModePropertiesKHR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDisplayModePropertiesValue]C.VkDisplayModePropertiesKHR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDisplayModePropertiesRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSSwapchainCreateInfo transforms a sliced Go data structure into plain C format.
func unpackArgSSwapchainCreateInfo(x []SwapchainCreateInfo) (unpacked *C.VkSwapchainCreateInfoKHR, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocSwapchainCreateInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.VkSwapchainCreateInfoKHR)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.VkSwapchainCreateInfoKHR)(h.Data)
	return
}
